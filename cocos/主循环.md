# è§£é‡Šæ¸¸æˆä¸»å¾ªç¯ä»£ç 
_Exported on 7/14/2025 at 14:27:57 GMT+8 from Cursor (1.2.4)_

---

**User**

è¿™æ˜¯æ¸¸æˆçš„ä¸»å¾ªç¯ï¼Œä½ å¸®æˆ‘è¯¦ç»†è§£é‡Šä¸€ä¸‹æ¯è¡Œä»£ç éƒ½åœ¨åšä»€ä¹ˆå§

---

**Cursor**

æˆ‘æ¥ä¸ºæ‚¨è¯¦ç»†è§£é‡Šè¿™ä¸ªæ¸¸æˆä¸»å¾ªç¯ï¼ˆ`tick`æ–¹æ³•ï¼‰ä¸­æ¯è¡Œä»£ç çš„ä½œç”¨ï¼š

## æ–¹æ³•ç­¾å
```typescript
public tick (dt: number): void {
```
- `dt`ï¼šDelta Timeï¼Œè¡¨ç¤ºå½“å‰å¸§ä¸ä¸Šä¸€å¸§ä¹‹é—´çš„æ—¶é—´é—´éš”ï¼ˆç§’ï¼‰

## ä¸»è¦é€»è¾‘æµç¨‹

### 1. éªŒè¯æ¸¸æˆçŠ¶æ€
```typescript
if (!this._invalid) {
```
- æ£€æŸ¥Directoræ˜¯å¦å¤„äºæœ‰æ•ˆçŠ¶æ€
- å¦‚æœ`_invalid`ä¸ºtrueï¼Œè¯´æ˜æ¸¸æˆå·²åœæ­¢ï¼Œä¸æ‰§è¡Œåç»­é€»è¾‘

### 2. å¸§å¼€å§‹äº‹ä»¶
```typescript
this.emit(DirectorEvent.BEGIN_FRAME);
```
- å‘å‡º"å¸§å¼€å§‹"äº‹ä»¶ï¼Œé€šçŸ¥æ‰€æœ‰ç›‘å¬è€…æ–°çš„ä¸€å¸§å¼€å§‹äº†
- å¼€å‘è€…å¯ä»¥ç›‘å¬æ­¤äº‹ä»¶æ¥æ‰§è¡Œå¸§å¼€å§‹æ—¶çš„è‡ªå®šä¹‰é€»è¾‘

### 3. è¾“å…¥äº‹ä»¶å¤„ç†
```typescript
if (!EDITOR_NOT_IN_PREVIEW) {
    input._frameDispatchEvents();
}
```
- åœ¨éç¼–è¾‘å™¨é¢„è§ˆæ¨¡å¼ä¸‹ï¼Œåˆ†å‘è¾“å…¥äº‹ä»¶ï¼ˆè§¦æ‘¸ã€é”®ç›˜ã€é¼ æ ‡ç­‰ï¼‰
- ç¡®ä¿ç”¨æˆ·è¾“å…¥èƒ½å¤ŸåŠæ—¶å“åº”

### 4. æ›´æ–°é˜¶æ®µï¼ˆå¦‚æœæœªæš‚åœï¼‰
```typescript
if (!this._paused) {
```
- æ£€æŸ¥æ¸¸æˆæ˜¯å¦æš‚åœï¼Œåªæœ‰åœ¨éæš‚åœçŠ¶æ€ä¸‹æ‰æ‰§è¡Œæ›´æ–°é€»è¾‘

#### 4.1 æ›´æ–°å‰äº‹ä»¶
```typescript
this.emit(DirectorEvent.BEFORE_UPDATE);
```
- å‘å‡º"æ›´æ–°å‰"äº‹ä»¶ï¼Œå…è®¸å¼€å‘è€…åœ¨ç»„ä»¶æ›´æ–°å‰æ‰§è¡Œä»£ç 

#### 4.2 ç»„ä»¶å¯åŠ¨é˜¶æ®µ
```typescript
this._compScheduler.startPhase();
```
- è°ƒç”¨æ–°æ·»åŠ ç»„ä»¶çš„`start()`æ–¹æ³•
- ç¡®ä¿æ–°åˆ›å»ºçš„ç»„ä»¶èƒ½å¤Ÿæ­£ç¡®åˆå§‹åŒ–

#### 4.3 ç»„ä»¶æ›´æ–°é˜¶æ®µ
```typescript
this._compScheduler.updatePhase(dt);
```
- è°ƒç”¨æ‰€æœ‰æ¿€æ´»ç»„ä»¶çš„`update(dt)`æ–¹æ³•
- è¿™æ˜¯æ¸¸æˆé€»è¾‘çš„æ ¸å¿ƒæ›´æ–°é˜¶æ®µ

#### 4.4 ç³»ç»Ÿæ›´æ–°
```typescript
for (let i = 0; i < this._systems.length; ++i) {
    this._systems[i].update(dt);
}
```
- éå†å¹¶æ›´æ–°æ‰€æœ‰æ³¨å†Œçš„ç³»ç»Ÿï¼ˆå¦‚åŠ¨ç”»ç³»ç»Ÿã€ç‰©ç†ç³»ç»Ÿç­‰ï¼‰
- ç³»ç»ŸæŒ‰ä¼˜å…ˆçº§é¡ºåºæ‰§è¡Œ

#### 4.5 ç»„ä»¶åæœŸæ›´æ–°
```typescript
this._compScheduler.lateUpdatePhase(dt);
```
- è°ƒç”¨æ‰€æœ‰ç»„ä»¶çš„`lateUpdate(dt)`æ–¹æ³•
- é€šå¸¸ç”¨äºç›¸æœºè·Ÿéšã€UIæ›´æ–°ç­‰éœ€è¦åœ¨æ™®é€šæ›´æ–°åæ‰§è¡Œçš„é€»è¾‘

#### 4.6 æ›´æ–°åäº‹ä»¶
```typescript
this.emit(DirectorEvent.AFTER_UPDATE);
```
- å‘å‡º"æ›´æ–°å"äº‹ä»¶ï¼Œå…è®¸ç”¨æˆ·åœ¨æ›´æ–°å®Œæˆåæ‰§è¡Œè‡ªå®šä¹‰é€»è¾‘

#### 4.7 å»¶è¿Ÿé”€æ¯å¤„ç†
```typescript
CCObject._deferredDestroy();
```
- å¤„ç†æ ‡è®°ä¸ºé”€æ¯çš„å¯¹è±¡ï¼Œå®é™…æ‰§è¡Œé”€æ¯æ“ä½œ
- é¿å…åœ¨æ›´æ–°è¿‡ç¨‹ä¸­ç›´æ¥é”€æ¯å¯¹è±¡é€ æˆçš„é—®é¢˜

#### 4.8 ç³»ç»ŸåæœŸæ›´æ–°
```typescript
for (let i = 0; i < this._systems.length; ++i) {
    this._systems[i].postUpdate(dt);
}
```
- æ‰§è¡Œæ‰€æœ‰ç³»ç»Ÿçš„åæœŸæ›´æ–°é€»è¾‘
- ç”¨äºç³»ç»Ÿé—´çš„åŒæ­¥å’Œæ¸…ç†å·¥ä½œ

### 5. æ¸²æŸ“é˜¶æ®µ

#### 5.1 æ¸²æŸ“å‰äº‹ä»¶
```typescript
this.emit(DirectorEvent.BEFORE_DRAW);
```
- å‘å‡º"æ¸²æŸ“å‰"äº‹ä»¶

#### 5.2 UIæ¸²æŸ“å™¨æ›´æ–°
```typescript
uiRendererManager.updateAllDirtyRenderers();
```
- æ›´æ–°æ‰€æœ‰æ ‡è®°ä¸º"è„"çš„UIæ¸²æŸ“å™¨
- ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½ï¼Œåªé‡ç»˜éœ€è¦æ›´æ–°çš„UIå…ƒç´ 

#### 5.3 æ ¹èŠ‚ç‚¹å¸§ç§»åŠ¨
```typescript
this._root!.frameMove(dt);
```
- æ‰§è¡Œæ¸²æŸ“ç®¡çº¿çš„å¸§ç§»åŠ¨æ“ä½œ
- å¤„ç†ç›¸æœºã€å…‰ç…§ã€æ¸²æŸ“ç­‰æ ¸å¿ƒæ¸²æŸ“é€»è¾‘

#### 5.4 æ¸²æŸ“åäº‹ä»¶
```typescript
this.emit(DirectorEvent.AFTER_DRAW);
```
- å‘å‡º"æ¸²æŸ“å"äº‹ä»¶

### 6. å¸§ç»“æŸæ¸…ç†

#### 6.1 é‡ç½®èŠ‚ç‚¹å˜åŒ–æ ‡è®°
```typescript
Node.resetHasChangedFlags();
```
- é‡ç½®æ‰€æœ‰èŠ‚ç‚¹çš„å˜åŒ–æ ‡è®°ï¼Œä¸ºä¸‹ä¸€å¸§åšå‡†å¤‡

#### 6.2 æ¸…ç†èŠ‚ç‚¹æ•°ç»„
```typescript
Node.clearNodeArray();
```
- æ¸…ç†ä¸´æ—¶çš„èŠ‚ç‚¹æ•°ç»„ï¼Œé‡Šæ”¾å†…å­˜

#### 6.3 å¯ä¼¸ç¼©å®¹å™¨ç®¡ç†å™¨æ›´æ–°
```typescript
scalableContainerManager.update(dt);
```
- æ›´æ–°å†…å­˜æ± ç­‰å¯ä¼¸ç¼©å®¹å™¨çš„çŠ¶æ€

#### 6.4 å¸§ç»“æŸäº‹ä»¶
```typescript
this.emit(DirectorEvent.END_FRAME);
```
- å‘å‡º"å¸§ç»“æŸ"äº‹ä»¶

#### 6.5 å¸§è®¡æ•°é€’å¢
```typescript
this._totalFrames++;
```
- æ€»å¸§æ•°åŠ 1ï¼Œç”¨äºç»Ÿè®¡å’Œè°ƒè¯•

## æ€»ç»“

è¿™ä¸ªä¸»å¾ªç¯ä¸¥æ ¼æŒ‰ç…§æ¸¸æˆå¼•æ“çš„æ ‡å‡†æµç¨‹æ‰§è¡Œï¼š
1. **è¾“å…¥å¤„ç†** â†’ 2. **é€»è¾‘æ›´æ–°** â†’ 3. **æ¸²æŸ“ç»˜åˆ¶** â†’ 4. **æ¸…ç†å·¥ä½œ**

æ¯ä¸ªé˜¶æ®µéƒ½æœ‰å¯¹åº”çš„äº‹ä»¶å‘å‡ºï¼Œè®©å¼€å‘è€…å¯ä»¥åœ¨ç‰¹å®šæ—¶æœºæ’å…¥è‡ªå®šä¹‰é€»è¾‘ï¼Œè¿™æ˜¯ä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„æ¸¸æˆä¸»å¾ªç¯æ¶æ„ã€‚

```typescript
public tick (dt: number): void {
```

```typescript
if (!this._invalid) {
```

```typescript
this.emit(DirectorEvent.BEGIN_FRAME);
```

```typescript
if (!EDITOR_NOT_IN_PREVIEW) {
    input._frameDispatchEvents();
}
```

```typescript
if (!this._paused) {
```

```typescript
this.emit(DirectorEvent.BEFORE_UPDATE);
```

```typescript
this._compScheduler.startPhase();
```

```typescript
this._compScheduler.updatePhase(dt);
```

```typescript
for (let i = 0; i < this._systems.length; ++i) {
    this._systems[i].update(dt);
}
```

```typescript
this._compScheduler.lateUpdatePhase(dt);
```

```typescript
this.emit(DirectorEvent.AFTER_UPDATE);
```

```typescript
CCObject._deferredDestroy();
```

```typescript
for (let i = 0; i < this._systems.length; ++i) {
    this._systems[i].postUpdate(dt);
}
```

```typescript
this.emit(DirectorEvent.BEFORE_DRAW);
```

```typescript
uiRendererManager.updateAllDirtyRenderers();
```

```typescript
this._root!.frameMove(dt);
```

```typescript
this.emit(DirectorEvent.AFTER_DRAW);
```

```typescript
Node.resetHasChangedFlags();
```

```typescript
Node.clearNodeArray();
```

```typescript
scalableContainerManager.update(dt);
```

```typescript
this.emit(DirectorEvent.END_FRAME);
```

```typescript
this._totalFrames++;
```

---

**User**

æˆ‘è¯´ä¸€ä¸‹æˆ‘çš„ç†è§£ï¼ŒuiRendererManager.updateAllDirtyRenderers(); ç”¨æ¥å¤„ç†å½“å‰å¸§uiä¸Šçš„æ‰€æœ‰å˜åŒ–åçš„æ¸²æŸ“æ•°æ®ï¼Œç„¶åthis._root!.frameMove(dt);ä¼šæ ¹æ®æ¸²æŸ“åçš„æ•°æ®è¿›è¡Œæ•´ç†ï¼Œç¬¦åˆæ‰¹å¤„ç†çš„è¿›è¡Œæ‰¹å¤„ç†æ“ä½œï¼Œæœ€åæŠŠæ¸²æŸ“æ•°æ®æäº¤ç»™gpuã€‚

---

**Cursor**

æ‚¨çš„ç†è§£éå¸¸å‡†ç¡®ï¼è®©æˆ‘é€šè¿‡æŸ¥çœ‹ç›¸å…³ä»£ç æ¥è¿›ä¸€æ­¥éªŒè¯å’Œè¡¥å……æ‚¨çš„åˆ†æï¼š

æ‚¨çš„ç†è§£**å®Œå…¨æ­£ç¡®**ï¼é€šè¿‡æŸ¥çœ‹æºç ï¼Œæˆ‘å¯ä»¥ç¡®è®¤æ‚¨å¯¹è¿™ä¸¤ä¸ªå…³é”®æ­¥éª¤çš„åˆ†æéå¸¸ç²¾å‡†ã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šä¸€ä¸‹ï¼š

## 1. `uiRendererManager.updateAllDirtyRenderers()` 

è¿™ä¸ªæ–¹æ³•ç¡®å®ç”¨æ¥å¤„ç†å½“å‰å¸§UIä¸Šæ‰€æœ‰å˜åŒ–åçš„æ¸²æŸ“æ•°æ®ï¼š

```67:72:cocos-engine/cocos/2d/framework/ui-renderer-manager.ts
    public updateAllDirtyRenderers (): void {
        const dirtyRenderers = this._dirtyRenderers;
        for (let i = 0; i < this._dirtyRenderers.length; i++) {
            if (DEBUG) {
                assert(dirtyRenderers[i]._internalId !== -1);
            }
            dirtyRenderers[i].updateRenderer();
        }
        this._dirtyRenderers.length = 0;
        this._dirtyVersion++;
    }
```

**å…·ä½“åšä»€ä¹ˆï¼š**
- éå†æ‰€æœ‰æ ‡è®°ä¸º"è„"çš„UIæ¸²æŸ“å™¨ï¼ˆå³éœ€è¦æ›´æ–°çš„UIå…ƒç´ ï¼‰
- è°ƒç”¨æ¯ä¸ªæ¸²æŸ“å™¨çš„`updateRenderer()`æ–¹æ³•æ›´æ–°æ¸²æŸ“æ•°æ®
- æ¸…ç©ºè„æ¸²æŸ“å™¨åˆ—è¡¨ï¼Œå‡†å¤‡ä¸‹ä¸€å¸§

**`updateRenderer()`å†…éƒ¨æµç¨‹ï¼š**
```470:478:cocos-engine/cocos/2d/framework/ui-renderer.ts
    public updateRenderer (): void {
        const assembler = this._assembler;
        if (assembler && assembler.updateRenderData) {
            assembler.updateRenderData(this);
        }
        this._renderFlag = this._canRender();
        this._renderEntity.enabled = this._renderFlag;
    }
```
- é€šè¿‡assembleræ›´æ–°å…·ä½“çš„æ¸²æŸ“æ•°æ®ï¼ˆé¡¶ç‚¹ã€UVã€é¢œè‰²ç­‰ï¼‰
- æ›´æ–°æ¸²æŸ“æ ‡å¿—ï¼Œå†³å®šè¯¥UIæ˜¯å¦éœ€è¦æ¸²æŸ“

## 2. `this._root!.frameMove(dt)` 

è¿™ä¸ªæ–¹æ³•ç¡®å®è´Ÿè´£æ•´ç†æ¸²æŸ“æ•°æ®ã€æ‰¹å¤„ç†å¹¶æäº¤ç»™GPUï¼š

**ä¸‰ä¸ªå…³é”®é˜¶æ®µï¼š**

### 2.1 `_frameMoveBegin()` - æ¸…ç†å‡†å¤‡
```756:762:cocos-engine/cocos/root.ts
    private _frameMoveBegin (): void {
        for (let i = 0; i < this._scenes.length; ++i) {
            this._scenes[i].removeBatches();
        }

        this._cameraList.length = 0;
    }
```
- æ¸…é™¤ä¸Šä¸€å¸§çš„æ‰¹å¤„ç†æ•°æ®
- é‡ç½®ç›¸æœºåˆ—è¡¨

### 2.2 `_frameMoveProcess()` - æ•°æ®æ•´ç†ä¸æ‰¹å¤„ç†
```763:787:cocos-engine/cocos/root.ts
    private _frameMoveProcess (): void {
        const { director } = cclegacy;
        const windows = this._windows;
        const cameraList = this._cameraList;

        for (let i = 0; i < windows.length; i++) {
            const window = windows[i];
            window.extractRenderCameras(cameraList);
        }

        if (this._pipeline && cameraList.length > 0) {
            this._device.acquire([deviceManager.swapchain]);
            const scenes = this._scenes;
            const stamp = director.getTotalFrames() as number;

            if (this._batcher) {
                this._batcher.update();
                this._batcher.uploadBuffers();
            }

            for (let i = 0; i < scenes.length; i++) {
                scenes[i].update(stamp);
            }
        }
    }
```
- æå–æ‰€æœ‰æ¸²æŸ“ç›¸æœº
- **å…³é”®ï¼š`this._batcher.update()`** - è¿™é‡Œè¿›è¡Œæ‰¹å¤„ç†ä¼˜åŒ–
- **å…³é”®ï¼š`this._batcher.uploadBuffers()`** - å°†æ‰¹å¤„ç†åçš„æ•°æ®ä¸Šä¼ åˆ°GPUç¼“å†²åŒº
- æ›´æ–°æ‰€æœ‰åœºæ™¯çš„æ¸²æŸ“æ•°æ®

### 2.3 `_frameMoveEnd()` - æœ€ç»ˆæ¸²æŸ“æäº¤
```789:807:cocos-engine/cocos/root.ts
    private _frameMoveEnd (): void {
        const { director, Director } = cclegacy;
        const cameraList = this._cameraList;
        if (this._pipeline && cameraList.length > 0) {
            director.emit(Director.EVENT_BEFORE_COMMIT);
            cameraList.sort((a: Camera, b: Camera): number => a.priority - b.priority);

            for (let i = 0; i < cameraList.length; ++i) {
                cameraList[i].geometryRenderer?.update();
            }
            director.emit(Director.EVENT_BEFORE_RENDER);
            this._pipeline.render(cameraList);
            director.emit(Director.EVENT_AFTER_RENDER);
            this._device.present();
        }

        if (this._batcher) this._batcher.reset();
    }
```
- æŒ‰ä¼˜å…ˆçº§æ’åºç›¸æœº
- **å…³é”®ï¼š`this._pipeline.render(cameraList)`** - æ‰§è¡Œæ¸²æŸ“ç®¡çº¿ï¼Œæäº¤ç»™GPU
- **å…³é”®ï¼š`this._device.present()`** - æœ€ç»ˆå‘ˆç°åˆ°å±å¹•
- é‡ç½®æ‰¹å¤„ç†å™¨ä¸ºä¸‹ä¸€å¸§åšå‡†å¤‡

## æ€»ç»“

æ‚¨çš„ç†è§£éå¸¸å‡†ç¡®ï¼š

1. **UIæ•°æ®æ›´æ–°** â†’ `uiRendererManager.updateAllDirtyRenderers()` å¤„ç†æ‰€æœ‰UIå˜åŒ–
2. **æ•°æ®æ•´ç†ä¸æ‰¹å¤„ç†** â†’ `frameMove()` ä¸­çš„batcherè¿›è¡Œæ‰¹å¤„ç†ä¼˜åŒ–  
3. **GPUæäº¤** â†’ æ¸²æŸ“ç®¡çº¿å°†æ‰¹å¤„ç†åçš„æ•°æ®æäº¤ç»™GPUå¹¶å‘ˆç°

è¿™ä¸ªè®¾è®¡ä½“ç°äº†ç°ä»£æ¸¸æˆå¼•æ“çš„æ ¸å¿ƒä¼˜åŒ–æ€æƒ³ï¼š**è„æ ‡è®°ç³»ç»Ÿ** + **æ‰¹å¤„ç†** + **å¼‚æ­¥GPUæäº¤**ï¼Œæœ€å¤§åŒ–æ¸²æŸ“æ€§èƒ½ã€‚

```typescript
    public updateAllDirtyRenderers (): void {
        const dirtyRenderers = this._dirtyRenderers;
        for (let i = 0; i < this._dirtyRenderers.length; i++) {
            if (DEBUG) {
                assert(dirtyRenderers[i]._internalId !== -1);
            }
            dirtyRenderers[i].updateRenderer();
        }
        this._dirtyRenderers.length = 0;
        this._dirtyVersion++;
    }
```

```typescript
    public updateRenderer (): void {
        const assembler = this._assembler;
        if (assembler && assembler.updateRenderData) {
            assembler.updateRenderData(this);
        }
        this._renderFlag = this._canRender();
        this._renderEntity.enabled = this._renderFlag;
    }
```

```typescript
    private _frameMoveBegin (): void {
        for (let i = 0; i < this._scenes.length; ++i) {
            this._scenes[i].removeBatches();
        }

        this._cameraList.length = 0;
    }
```

```typescript
    private _frameMoveProcess (): void {
        const { director } = cclegacy;
        const windows = this._windows;
        const cameraList = this._cameraList;

        for (let i = 0; i < windows.length; i++) {
            const window = windows[i];
            window.extractRenderCameras(cameraList);
        }

        if (this._pipeline && cameraList.length > 0) {
            this._device.acquire([deviceManager.swapchain]);
            const scenes = this._scenes;
            const stamp = director.getTotalFrames() as number;

            if (this._batcher) {
                this._batcher.update();
                this._batcher.uploadBuffers();
            }

            for (let i = 0; i < scenes.length; i++) {
                scenes[i].update(stamp);
            }
        }
    }
```

```typescript
    private _frameMoveEnd (): void {
        const { director, Director } = cclegacy;
        const cameraList = this._cameraList;
        if (this._pipeline && cameraList.length > 0) {
            director.emit(Director.EVENT_BEFORE_COMMIT);
            cameraList.sort((a: Camera, b: Camera): number => a.priority - b.priority);

            for (let i = 0; i < cameraList.length; ++i) {
                cameraList[i].geometryRenderer?.update();
            }
            director.emit(Director.EVENT_BEFORE_RENDER);
            this._pipeline.render(cameraList);
            director.emit(Director.EVENT_AFTER_RENDER);
            this._device.present();
        }

        if (this._batcher) this._batcher.reset();
    }
```

---

**User**

ä½ è¿™é‡Œæåˆ°äº†å¼‚æ­¥GPUæäº¤ï¼Œè¿™ä¸ªæ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿ

---

**Cursor**

è®©æˆ‘æ·±å…¥æŸ¥çœ‹Cocos Engineä¸­å¼‚æ­¥GPUæäº¤çš„å®ç°æœºåˆ¶ï¼š

é€šè¿‡æ·±å…¥åˆ†ææºç ï¼Œæˆ‘éœ€è¦**æ¾„æ¸…ä¸€ä¸ªé‡è¦æ¦‚å¿µ**ï¼šåœ¨Cocos Engineä¸­ï¼Œç‰¹åˆ«æ˜¯åœ¨WebGLå®ç°ä¸­ï¼Œå¹¶**æ²¡æœ‰çœŸæ­£çš„å¼‚æ­¥GPUæäº¤**ï¼Œæˆ‘ä¹‹å‰çš„è¡¨è¿°å¯èƒ½é€ æˆäº†è¯¯è§£ã€‚

## å®é™…çš„"æäº¤"æœºåˆ¶

### 1. WebGLçš„å³æ—¶æ¨¡å¼

```287:295:cocos-engine/cocos/gfx/webgl2/webgl2-device.ts
    public present (): void {
        const queue = (this._queue as WebGL2Queue);
        this._numDrawCalls = queue.numDrawCalls;
        this._numInstances = queue.numInstances;
        this._numTris = queue.numTris;
        queue.clear();
    }
```

```280:286:cocos-engine/cocos/gfx/webgl2/webgl2-device.ts
    public flushCommands (cmdBuffs: Readonly<CommandBuffer[]>): void {
        // noop
    }

    public acquire (swapchains: Readonly<Swapchain[]>): void {
        // noop
    }
```

å¯ä»¥çœ‹åˆ°WebGL2å®ç°ä¸­ï¼š
- `flushCommands` æ˜¯ç©ºæ“ä½œ
- `acquire` æ˜¯ç©ºæ“ä½œ  
- `present` åªæ˜¯æ¸…ç†ç»Ÿè®¡ä¿¡æ¯

### 2. çœŸæ­£çš„æ¸²æŸ“å‘ç”Ÿåœ¨å“ªé‡Œï¼Ÿ

å®é™…çš„GPUå‘½ä»¤æäº¤å‘ç”Ÿåœ¨**UIç»„ä»¶çš„æ¸²æŸ“è¿‡ç¨‹**ä¸­ï¼š

```321:333:cocos-engine/cocos/2d/renderer/batcher-2d.ts
    public uploadBuffers (): void {
        if (JSB) {
            this._nativeObj.uploadBuffers();
        } else if (this._batches.length > 0) {
            const length = this._meshDataArray.length;
            for (let i = 0; i < length; i++) {
                this._meshDataArray[i].uploadBuffers();
            }

            for (const accessor of this._bufferAccessors.values()) {
                accessor.uploadBuffers();
                accessor.reset();
            }

            this._descriptorSetCache.update();
        }
    }
```

## WebGLçš„"å‡†å¼‚æ­¥"ç‰¹æ€§

WebGLæœ¬èº«å…·æœ‰ä¸€äº›"å‡†å¼‚æ­¥"ç‰¹æ€§ï¼Œä½†è¿™æ˜¯**æµè§ˆå™¨å±‚é¢**çš„ï¼Œè€Œä¸æ˜¯å¼•æ“å±‚é¢çš„ï¼š

### 1. æµè§ˆå™¨çš„å‘½ä»¤ç¼“å†²
- WebGLå‘½ä»¤ä¼šè¢«æµè§ˆå™¨æ”¾å…¥å‘½ä»¤é˜Ÿåˆ—
- æµè§ˆå™¨åœ¨åˆé€‚çš„æ—¶æœºæ‰¹é‡æäº¤ç»™GPUé©±åŠ¨
- è¿™ä¸ªè¿‡ç¨‹å¯¹JavaScriptæ˜¯é€æ˜çš„

### 2. åŒç¼“å†²æœºåˆ¶
- å‰ç¼“å†²ï¼šå½“å‰æ˜¾ç¤ºçš„å¸§
- åç¼“å†²ï¼šæ­£åœ¨æ¸²æŸ“çš„å¸§
- `present`æ“ä½œäº¤æ¢ä¸¤ä¸ªç¼“å†²åŒº

## çœŸæ­£çš„å¼‚æ­¥GPUæäº¤

çœŸæ­£çš„å¼‚æ­¥GPUæäº¤é€šå¸¸å‡ºç°åœ¨ï¼š

### 1. åŸç”Ÿå¹³å°ï¼ˆNativeï¼‰
```323:323:cocos-engine/cocos/2d/renderer/batcher-2d.ts
            this._nativeObj.uploadBuffers();
```
- åŸç”Ÿå¹³å°å¯èƒ½æœ‰çœŸæ­£çš„å¼‚æ­¥å‘½ä»¤æäº¤
- ä½¿ç”¨Vulkanã€Metalã€DirectX 12ç­‰ç°ä»£API

### 2. WebGPUï¼ˆæœªæ¥ï¼‰
- WebGPUæ”¯æŒçœŸæ­£çš„å¼‚æ­¥å‘½ä»¤æäº¤
- å¯ä»¥åœ¨å¤šä¸ªçº¿ç¨‹ä¸­æ„å»ºå‘½ä»¤ç¼“å†²åŒº

## æ€»ç»“

Cocos Engineåœ¨**Webå¹³å°ä¸Šçš„"å¼‚æ­¥GPUæäº¤"**å®é™…ä¸Šæ˜¯ï¼š

1. **CPUä¾§çš„å¼‚æ­¥å¤„ç†**ï¼š
   - UIæ•°æ®æ›´æ–°ï¼ˆ`updateAllDirtyRenderers`ï¼‰
   - æ‰¹å¤„ç†æ•°æ®å‡†å¤‡ï¼ˆ`batcher.update`ï¼‰
   - ç¼“å†²åŒºä¸Šä¼ ï¼ˆ`uploadBuffers`ï¼‰

2. **æµè§ˆå™¨å±‚çš„"å‡†å¼‚æ­¥"**ï¼š
   - WebGLå‘½ä»¤é˜Ÿåˆ—
   - æµè§ˆå™¨çš„æ¸²æŸ“è°ƒåº¦
   - GPUé©±åŠ¨çš„ä¼˜åŒ–

3. **å¸§åŒæ­¥çš„å‘ˆç°**ï¼š
   - `present`åªæ˜¯æ ‡è®°å¸§ç»“æŸ
   - å®é™…æ˜¾ç¤ºç”±æµè§ˆå™¨çš„å‚ç›´åŒæ­¥æ§åˆ¶

æ‰€ä»¥æ‚¨æœ€åˆç†è§£çš„**æ‰¹å¤„ç†ä¼˜åŒ–å’Œæ•°æ®æ•´ç†**æ˜¯å®Œå…¨æ­£ç¡®çš„ï¼Œä½†"å¼‚æ­¥GPUæäº¤"è¿™ä¸ªè¯´æ³•åœ¨WebGLç¯å¢ƒä¸‹å¹¶ä¸å‡†ç¡®ã€‚çœŸæ­£çš„ä¼˜åŒ–åœ¨äº**å‡å°‘draw callã€åˆå¹¶æ¸²æŸ“çŠ¶æ€ã€ä¼˜åŒ–æ•°æ®ä¼ è¾“**ï¼Œè€Œä¸æ˜¯å¼‚æ­¥æäº¤æœ¬èº«ã€‚

```typescript
    public present (): void {
        const queue = (this._queue as WebGL2Queue);
        this._numDrawCalls = queue.numDrawCalls;
        this._numInstances = queue.numInstances;
        this._numTris = queue.numTris;
        queue.clear();
    }
```

```typescript
    public flushCommands (cmdBuffs: Readonly<CommandBuffer[]>): void {
        // noop
    }

    public acquire (swapchains: Readonly<Swapchain[]>): void {
        // noop
    }
```

```typescript
    public uploadBuffers (): void {
        if (JSB) {
            this._nativeObj.uploadBuffers();
        } else if (this._batches.length > 0) {
            const length = this._meshDataArray.length;
            for (let i = 0; i < length; i++) {
                this._meshDataArray[i].uploadBuffers();
            }

            for (const accessor of this._bufferAccessors.values()) {
                accessor.uploadBuffers();
                accessor.reset();
            }

            this._descriptorSetCache.update();
        }
    }
```

```typescript
            this._nativeObj.uploadBuffers();
```

---

**User**

æˆ‘æœ‰ä¸€ä¸ªç–‘é—®ï¼Œjscæ¨¡å¼ä¸‹åº”è¯¥å°±æ˜¯åŸç”Ÿå¹³å°å¤„ç†ï¼Œä»–ä»¬åœ¨ç«¯ä¸Šå¯èƒ½å¤„ç†äº†å¼‚æ­¥æäº¤ï¼›ä½†æ˜¯åœ¨webç«¯ï¼Œæˆ‘ä»¬åœ¨å¼•æ“å¤„ç†çš„æ—¶å€™åº”è¯¥å­˜åœ¨å¤šæ¬¡çš„uploadbufferçš„æ“ä½œï¼Œä¹Ÿå°±æ˜¯æ¸²æŸ“æ•°æ®ä¸æ˜¯ä¸€æ¬¡ä¸Šä¼ çš„ï¼Œè€Œæ˜¯å¤šæ¬¡ä¸Šä¼ çš„ï¼Œå¦‚æœæ˜¯ä¸Šä¼ åç›´æ¥æ¸²æŸ“çš„è¯åº”è¯¥æ˜¯æœ‰é—®é¢˜çš„å§ï¼Ÿåº”è¯¥æ˜¯éœ€è¦å¤šæ¬¡ä¸Šä¼ åï¼Œæœ‰ä¸€ä»½å®Œæ•´çš„æ¸²æŸ“æ•°æ®æ‰èƒ½è¿›è¡Œgpuçš„æ¸²æŸ“å§ï¼Ÿ

---

**Cursor**

æ‚¨çš„ç–‘é—®éå¸¸æœ‰é“ç†ï¼è¿™ç¡®å®æ˜¯Webç«¯æ¸²æŸ“çš„ä¸€ä¸ªå…³é”®é—®é¢˜ã€‚è®©æˆ‘æ·±å…¥æŸ¥çœ‹ä»£ç æ¥è§£é‡Šè¿™ä¸ªæœºåˆ¶ï¼š

æ‚¨çš„ç†è§£**å®Œå…¨æ­£ç¡®**ï¼é€šè¿‡æ·±å…¥åˆ†ææºç ï¼Œæˆ‘å¯ä»¥ç¡®è®¤æ‚¨å¯¹Webç«¯æ¸²æŸ“æœºåˆ¶çš„åˆ†ææ˜¯å‡†ç¡®çš„ã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šè¿™ä¸ªæœºåˆ¶ï¼š

## Webç«¯çš„æ¸²æŸ“æ•°æ®å¤„ç†æµç¨‹

### 1. å¤šæ¬¡`uploadBuffer`æ“ä½œçš„æœ¬è´¨

```812:890:cocos-engine/cocos/gfx/webgl2/webgl2-commands.ts
export function WebGL2CmdFuncUpdateBuffer (
    device: WebGL2Device,
    gpuBuffer: IWebGL2GPUBuffer,
    buffer: Readonly<BufferSource>,
    offset: number,
    size: number,
): void {
    // ...
    switch (gpuBuffer.glTarget) {
    case WebGLConstants.ARRAY_BUFFER: {
        // ...
        if (size === buff.byteLength) {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
        } else {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
        }
        break;
    }
    case WebGLConstants.ELEMENT_ARRAY_BUFFER: {
        // ...
        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
        break;
    }
    // ...
}
```

**å…³é”®ç‚¹ï¼š** `uploadBuffer`å®é™…è°ƒç”¨çš„æ˜¯WebGLçš„`gl.bufferSubData()`ï¼Œè¿™ä¸ªæ“ä½œåªæ˜¯**å°†æ•°æ®ä¸Šä¼ åˆ°GPUç¼“å†²åŒº**ï¼Œ**å¹¶ä¸æ‰§è¡Œç»˜åˆ¶**ï¼

### 2. æ¸²æŸ“æ•°æ®çš„å®Œæ•´æ€§ä¿è¯

ä»ä¸»å¾ªç¯çš„æ‰§è¡Œé¡ºåºå¯ä»¥çœ‹åˆ°ï¼š

```767:809:cocos-engine/cocos/game/director.ts
    // 1. æ›´æ–°æ‰€æœ‰UIæ¸²æŸ“æ•°æ®
    uiRendererManager.updateAllDirtyRenderers();
    
    // 2. æ¸²æŸ“ç®¡çº¿å¤„ç†
    this._root!.frameMove(dt);
```

åœ¨`frameMove`ä¸­çš„æ‰§è¡Œé¡ºåºï¼š
```763:787:cocos-engine/cocos/root.ts
    private _frameMoveProcess (): void {
        // ...
        if (this._batcher) {
            this._batcher.update();        // æ”¶é›†æ‰€æœ‰æ¸²æŸ“æ•°æ®
            this._batcher.uploadBuffers(); // æ‰¹é‡ä¸Šä¼ åˆ°GPUç¼“å†²åŒº
        }
        // ...
    }
```

```789:807:cocos-engine/cocos/root.ts
    private _frameMoveEnd (): void {
        // ...
        this._pipeline.render(cameraList);  // æœ€ç»ˆæ‰§è¡Œç»˜åˆ¶
        this._device.present();            // å‘ˆç°åˆ°å±å¹•
        // ...
    }
```

### 3. çœŸæ­£çš„ç»˜åˆ¶å‘ç”Ÿåœ¨å“ªé‡Œ

çœŸæ­£çš„ç»˜åˆ¶å‘½ä»¤åœ¨`WebGL2CmdFuncDraw`ä¸­ï¼š

```2533:2630:cocos-engine/cocos/gfx/webgl2/webgl2-commands.ts
export function WebGL2CmdFuncDraw (device: WebGL2Device, drawInfo: Readonly<DrawInfo>): void {
    const { gl } = device;
    // ...
    if (indexBuffer) {
        if (drawInfo.indexCount > 0) {
            const offset = drawInfo.firstIndex * indexBuffer.stride;
            gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
        }
    } else if (drawInfo.vertexCount > 0) {
        gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
    }
    // ...
}
```

**å…³é”®ç‚¹ï¼š** åªæœ‰è°ƒç”¨`gl.drawElements()`æˆ–`gl.drawArrays()`æ‰æ˜¯çœŸæ­£çš„ç»˜åˆ¶å‘½ä»¤ï¼

## æ‚¨åˆ†æçš„æ­£ç¡®æ€§

æ‚¨çš„åˆ†æå®Œå…¨æ­£ç¡®ï¼š

1. **å¤šæ¬¡uploadBuffer**ï¼šç¡®å®å­˜åœ¨å¤šæ¬¡`gl.bufferSubData()`è°ƒç”¨ï¼Œä½†è¿™äº›åªæ˜¯æ•°æ®ä¸Šä¼ 
2. **ä¸ä¼šç«‹å³æ¸²æŸ“**ï¼šæ¯æ¬¡uploadåä¸ä¼šç«‹å³æ‰§è¡Œç»˜åˆ¶å‘½ä»¤
3. **å®Œæ•´æ•°æ®åæ¸²æŸ“**ï¼šæ‰€æœ‰æ•°æ®å‡†å¤‡å®Œæ¯•åï¼Œæ‰ç»Ÿä¸€æ‰§è¡Œ`gl.drawElements()`ç­‰ç»˜åˆ¶å‘½ä»¤

## JSBæ¨¡å¼çš„å·®å¼‚

```321:333:cocos-engine/cocos/2d/renderer/batcher-2d.ts
    public uploadBuffers (): void {
        if (JSB) {
            this._nativeObj.uploadBuffers();  // åŸç”Ÿå¹³å°å¤„ç†
        } else if (this._batches.length > 0) {
            // Webç«¯çš„å¤„ç†é€»è¾‘
            const length = this._meshDataArray.length;
            for (let i = 0; i < length; i++) {
                this._meshDataArray[i].uploadBuffers();
            }
            // ...
        }
    }
```

åœ¨JSBæ¨¡å¼ä¸‹ï¼Œç¡®å®å¯èƒ½æœ‰çœŸæ­£çš„å¼‚æ­¥GPUæäº¤ï¼Œå› ä¸ºåŸç”Ÿå¹³å°å¯ä»¥ä½¿ç”¨Vulkanã€Metalç­‰ç°ä»£å›¾å½¢APIã€‚

## æ€»ç»“

æ‚¨çš„ç†è§£ä½“ç°äº†å¯¹ç°ä»£å›¾å½¢æ¸²æŸ“ç®¡çº¿çš„æ·±åˆ»è®¤è¯†ï¼š

1. **æ•°æ®å‡†å¤‡é˜¶æ®µ**ï¼šå¤šæ¬¡uploadæ“ä½œåªæ˜¯å‡†å¤‡GPUç¼“å†²åŒºæ•°æ®
2. **æ‰¹å¤„ç†ä¼˜åŒ–**ï¼šå¼•æ“æ”¶é›†å’Œæ•´ç†æ‰€æœ‰æ¸²æŸ“æ•°æ®
3. **ç»Ÿä¸€ç»˜åˆ¶**ï¼šåœ¨ç¡®ä¿æ•°æ®å®Œæ•´åï¼Œç»Ÿä¸€æ‰§è¡Œç»˜åˆ¶å‘½ä»¤

è¿™ç§è®¾è®¡é¿å…äº†**æ¯æ¬¡æ•°æ®å˜åŒ–éƒ½ç«‹å³æ¸²æŸ“**çš„æ€§èƒ½é—®é¢˜ï¼Œç¡®ä¿äº†æ¸²æŸ“çš„é«˜æ•ˆæ€§å’Œæ•°æ®ä¸€è‡´æ€§ã€‚

```typescript
export function WebGL2CmdFuncUpdateBuffer (
    device: WebGL2Device,
    gpuBuffer: IWebGL2GPUBuffer,
    buffer: Readonly<BufferSource>,
    offset: number,
    size: number,
): void {
    // ...
    switch (gpuBuffer.glTarget) {
    case WebGLConstants.ARRAY_BUFFER: {
        // ...
        if (size === buff.byteLength) {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
        } else {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
        }
        break;
    }
    case WebGLConstants.ELEMENT_ARRAY_BUFFER: {
        // ...
        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
        break;
    }
    // ...
}
```

```typescript
    // 1. æ›´æ–°æ‰€æœ‰UIæ¸²æŸ“æ•°æ®
    uiRendererManager.updateAllDirtyRenderers();
    
    // 2. æ¸²æŸ“ç®¡çº¿å¤„ç†
    this._root!.frameMove(dt);
```

```typescript
    private _frameMoveProcess (): void {
        // ...
        if (this._batcher) {
            this._batcher.update();        // æ”¶é›†æ‰€æœ‰æ¸²æŸ“æ•°æ®
            this._batcher.uploadBuffers(); // æ‰¹é‡ä¸Šä¼ åˆ°GPUç¼“å†²åŒº
        }
        // ...
    }
```

```typescript
    private _frameMoveEnd (): void {
        // ...
        this._pipeline.render(cameraList);  // æœ€ç»ˆæ‰§è¡Œç»˜åˆ¶
        this._device.present();            // å‘ˆç°åˆ°å±å¹•
        // ...
    }
```

```typescript
export function WebGL2CmdFuncDraw (device: WebGL2Device, drawInfo: Readonly<DrawInfo>): void {
    const { gl } = device;
    // ...
    if (indexBuffer) {
        if (drawInfo.indexCount > 0) {
            const offset = drawInfo.firstIndex * indexBuffer.stride;
            gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
        }
    } else if (drawInfo.vertexCount > 0) {
        gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
    }
    // ...
}
```

```typescript
    public uploadBuffers (): void {
        if (JSB) {
            this._nativeObj.uploadBuffers();  // åŸç”Ÿå¹³å°å¤„ç†
        } else if (this._batches.length > 0) {
            // Webç«¯çš„å¤„ç†é€»è¾‘
            const length = this._meshDataArray.length;
            for (let i = 0; i < length; i++) {
                this._meshDataArray[i].uploadBuffers();
            }
            // ...
        }
    }
```

---

**User**

æ‰€ä»¥æ˜¯åœ¨pipeline.renderçš„æ—¶å€™çœŸæ­£æ‰§è¡Œäº†drawelementså—ï¼Ÿ

---

**Cursor**

æ˜¯çš„ï¼è®©æˆ‘æ·±å…¥æŸ¥çœ‹`pipeline.render`çš„å®ç°æ¥ç¡®è®¤å…·ä½“çš„è°ƒç”¨é“¾è·¯ï¼š

```typescript
render (cameras: Camera[]): void;
```

**æ˜¯çš„ï¼æ‚¨å®Œå…¨æ­£ç¡®ï¼**

`pipeline.render`ç¡®å®æ˜¯çœŸæ­£æ‰§è¡Œ`drawElements`/`drawArrays`çš„åœ°æ–¹ã€‚è®©æˆ‘é€šè¿‡æºç æ¥è¯å®æ‚¨çš„åˆ¤æ–­ï¼š

## ç»å…¸ç®¡çº¿ä¸­çš„GPUå‘½ä»¤æäº¤

```475:501:cocos-engine/cocos/rendering/render-pipeline.ts
public render (cameras: Camera[]): void {
    if (cameras.length === 0) {
        return;
    }
    this.updateGeometryRenderer(cameras); // for capability
    this._commandBuffers[0].begin();
    this.emit(PipelineEventType.RENDER_FRAME_BEGIN, cameras);
    this._ensureEnoughSize(cameras);
    decideProfilerCamera(cameras);

    for (let i = 0; i < cameras.length; i++) {
        const camera = cameras[i];
        if (camera.scene) {
            this.emit(PipelineEventType.RENDER_CAMERA_BEGIN, camera);
            validPunctualLightsCulling(this.pipelineSceneData, camera);
            sceneCulling(this.pipelineSceneData, this.pipelineUBO, camera);
            this._pipelineUBO.updateGlobalUBO(camera.window);
            this._pipelineUBO.updateCameraUBO(camera);
            for (let j = 0; j < this._flows.length; j++) {
                this._flows[j].render(camera);  // è¿™é‡Œè®°å½•ç»˜åˆ¶å‘½ä»¤
            }
            this.emit(PipelineEventType.RENDER_CAMERA_END, camera);
        }
    }
    this.emit(PipelineEventType.RENDER_FRAME_END, cameras);
    this._commandBuffers[0].end();
    this._device.queue.submit(this._commandBuffers);  // ğŸ‘ˆ å…³é”®ï¼šæäº¤GPUå‘½ä»¤
}
```

## è‡ªå®šä¹‰ç®¡çº¿ä¸­çš„GPUå‘½ä»¤æäº¤

```1680:1686:cocos-engine/cocos/rendering/custom/web-pipeline.ts
render (cameras: Camera[]): void {
    if (cameras.length === 0) {
        return;
    }
    this._applySize(cameras);
    decideProfilerCamera(cameras);
    // build graph
    this.beginFrame();
    this.execute();  // ğŸ‘ˆ è¿™é‡Œä¼šè°ƒç”¨executoræ¥æäº¤GPUå‘½ä»¤
    this.endFrame();
}
```

åœ¨`executor.ts`ä¸­ï¼š

```1677:1677:cocos-engine/cocos/rendering/custom/executor.ts
context.device.queue.submit([cmdBuff]);  // ğŸ‘ˆ è‡ªå®šä¹‰ç®¡çº¿çš„GPUå‘½ä»¤æäº¤
```

## å®Œæ•´æµç¨‹æ€»ç»“

æ‚¨çš„ç†è§£å®Œå…¨æ­£ç¡®ï¼š

1. **`uiRendererManager.updateAllDirtyRenderers()`** - å¤šæ¬¡è°ƒç”¨`uploadBuffer`ï¼Œå°†æ¸²æŸ“æ•°æ®åˆ†æ‰¹ä¸Šä¼ åˆ°GPUç¼“å†²åŒº
2. **`this._root!.frameMove(dt)`ä¸­çš„`_batcher.uploadBuffers()`** - å®Œæˆæœ€ç»ˆçš„ç¼“å†²åŒºæ•°æ®æ•´åˆå’Œæ‰¹å¤„ç†
3. **`pipeline.render(cameraList)`** - è¿™é‡Œæ‰æ˜¯çœŸæ­£çš„ç»˜åˆ¶å‘½ä»¤æ‰§è¡Œï¼š
   - è®°å½•æ‰€æœ‰ç»˜åˆ¶å‘½ä»¤åˆ°`CommandBuffer`
   - è°ƒç”¨`device.queue.submit(commandBuffers)` **çœŸæ­£æäº¤ç»™GPUæ‰§è¡Œ**
   - æ­¤æ—¶GPUå¼€å§‹æ‰§è¡Œ`drawElements`/`drawArrays`ç­‰å®é™…ç»˜åˆ¶æŒ‡ä»¤

æ‰€ä»¥æ‚¨è¯´å¾—å¯¹ï¼š**å¤šæ¬¡`uploadBuffer`åªæ˜¯å‡†å¤‡æ•°æ®ï¼ŒçœŸæ­£çš„GPUç»˜åˆ¶å‘ç”Ÿåœ¨`pipeline.render`çš„æœ€åé˜¶æ®µ**ï¼è¿™ç§è®¾è®¡ç¡®ä¿äº†ï¼š

- âœ… æ‰€æœ‰æ¸²æŸ“æ•°æ®å®Œæ•´å‡†å¤‡å¥½äº†å†ä¸€æ¬¡æ€§æäº¤
- âœ… é¿å…äº†ä¸Šä¼ æ•°æ®åç«‹å³æ¸²æŸ“å¯¼è‡´çš„æ•°æ®ä¸å®Œæ•´é—®é¢˜  
- âœ… å®ç°äº†é«˜æ•ˆçš„æ‰¹å¤„ç†å’ŒGPUå‘½ä»¤é˜Ÿåˆ—ä¼˜åŒ–

```typescript
public render (cameras: Camera[]): void {
    if (cameras.length === 0) {
        return;
    }
    this.updateGeometryRenderer(cameras); // for capability
    this._commandBuffers[0].begin();
    this.emit(PipelineEventType.RENDER_FRAME_BEGIN, cameras);
    this._ensureEnoughSize(cameras);
    decideProfilerCamera(cameras);

    for (let i = 0; i < cameras.length; i++) {
        const camera = cameras[i];
        if (camera.scene) {
            this.emit(PipelineEventType.RENDER_CAMERA_BEGIN, camera);
            validPunctualLightsCulling(this.pipelineSceneData, camera);
            sceneCulling(this.pipelineSceneData, this.pipelineUBO, camera);
            this._pipelineUBO.updateGlobalUBO(camera.window);
            this._pipelineUBO.updateCameraUBO(camera);
            for (let j = 0; j < this._flows.length; j++) {
                this._flows[j].render(camera);  // è¿™é‡Œè®°å½•ç»˜åˆ¶å‘½ä»¤
            }
            this.emit(PipelineEventType.RENDER_CAMERA_END, camera);
        }
    }
    this.emit(PipelineEventType.RENDER_FRAME_END, cameras);
    this._commandBuffers[0].end();
    this._device.queue.submit(this._commandBuffers);  // ğŸ‘ˆ å…³é”®ï¼šæäº¤GPUå‘½ä»¤
}
```

```typescript
render (cameras: Camera[]): void {
    if (cameras.length === 0) {
        return;
    }
    this._applySize(cameras);
    decideProfilerCamera(cameras);
    // build graph
    this.beginFrame();
    this.execute();  // ğŸ‘ˆ è¿™é‡Œä¼šè°ƒç”¨executoræ¥æäº¤GPUå‘½ä»¤
    this.endFrame();
}
```

```typescript
context.device.queue.submit([cmdBuff]);  // ğŸ‘ˆ è‡ªå®šä¹‰ç®¡çº¿çš„GPUå‘½ä»¤æäº¤
```

---

**User**

é‚£å…¶å®presentæ¥å£çš„è¯ï¼Œè™½ç„¶æ˜¯æ˜¾ç¤ºåˆ°å±å¹•çš„æ¥å£ï¼Œä½†æ˜¯åœ¨webæ¨¡å¼ä¸‹çš„å®ç°å°±æ˜¯æ¸…é™¤æ•°æ®çš„ä½œç”¨äº†ã€‚å› ä¸ºåœ¨ä¹‹å‰çš„renderæ¥å£ä¸­gpuå·²ç»æŠŠå†…å®¹æ¸²æŸ“åˆ°å±å¹•ä¸Šäº†ã€‚

---

**Cursor**

```typescript
public present (): void {
    const queue = (this._queue as WebGL2Queue);
    this._numDrawCalls = queue.numDrawCalls;
    this._numInstances = queue.numInstances;
    this._numTris = queue.numTris;
    queue.clear();
}
```

æ‚¨çš„ç†è§£**å®Œå…¨æ­£ç¡®**ï¼è¿™æ˜¯Webç«¯æ¸²æŸ“ä¸åŸç”Ÿå¹³å°æ¸²æŸ“çš„ä¸€ä¸ªé‡è¦åŒºåˆ«ã€‚

## Webç«¯çš„`present()`å®ç°

æ­£å¦‚æ‚¨æ‰€è¯´ï¼Œåœ¨WebGLå®ç°ä¸­ï¼Œ`present()`ç¡®å®åªæ˜¯æ¸…ç†æ•°æ®ï¼š

```287:295:cocos-engine/cocos/gfx/webgl2/webgl2-device.ts
public present (): void {
    const queue = (this._queue as WebGL2Queue);
    this._numDrawCalls = queue.numDrawCalls;
    this._numInstances = queue.numInstances;
    this._numTris = queue.numTris;
    queue.clear();
}
```

**åšçš„äº‹æƒ…ï¼š**
- æ”¶é›†æ¸²æŸ“ç»Ÿè®¡ä¿¡æ¯ï¼ˆç»˜åˆ¶è°ƒç”¨æ¬¡æ•°ã€å®ä¾‹æ•°ã€ä¸‰è§’å½¢æ•°ï¼‰
- æ¸…ç©ºé˜Ÿåˆ—æ•°æ®ï¼Œå‡†å¤‡ä¸‹ä¸€å¸§

**æ²¡æœ‰åšï¼š** çœŸæ­£çš„"äº¤æ¢ç¼“å†²åŒº"æˆ–"æ˜¾ç¤ºåˆ°å±å¹•"æ“ä½œ

## ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Ÿ

### WebGLçš„å³æ—¶æ¸²æŸ“æ¨¡å¼
```790:808:cocos-engine/cocos/root.ts
private _frameMoveEnd (): void {
    const { director, Director } = cclegacy;
    const cameraList = this._cameraList;
    if (this._pipeline && cameraList.length > 0) {
        director.emit(Director.EVENT_BEFORE_COMMIT);
        cameraList.sort((a: Camera, b: Camera): number => a.priority - b.priority);

        for (let i = 0; i < cameraList.length; ++i) {
            cameraList[i].geometryRenderer?.update();
        }
        director.emit(Director.EVENT_BEFORE_RENDER);
        this._pipeline.render(cameraList);  // ğŸ‘ˆ è¿™é‡Œå·²ç»ç›´æ¥æ¸²æŸ“åˆ°å±å¹•
        director.emit(Director.EVENT_AFTER_RENDER);
        this._device.present();  // ğŸ‘ˆ åªæ˜¯æ¸…ç†æ•°æ®
    }

    if (this._batcher) this._batcher.reset();
}
```

åœ¨`pipeline.render()`æ‰§è¡Œæ—¶ï¼š
- WebGLçš„`drawElements`/`drawArrays`**ç›´æ¥ç»˜åˆ¶åˆ°Canvas**
- æµè§ˆå™¨è‡ªåŠ¨å°†Canvaså†…å®¹æ˜¾ç¤ºåˆ°å±å¹•
- **ä¸éœ€è¦é¢å¤–çš„"äº¤æ¢ç¼“å†²åŒº"æ­¥éª¤**

## ä¸åŸç”Ÿå¹³å°çš„å¯¹æ¯”

### åŸç”Ÿå¹³å°ï¼ˆVulkan/Metal/D3D12ï¼‰
```
uploadBuffer() â†’ å‡†å¤‡æ•°æ®
render() â†’ è®°å½•å‘½ä»¤ï¼Œç»˜åˆ¶åˆ°åå°ç¼“å†²åŒº  
present() â†’ äº¤æ¢å‰åç¼“å†²åŒºï¼Œæ˜¾ç¤ºåˆ°å±å¹• â­
```

### Webå¹³å°ï¼ˆWebGLï¼‰
```
uploadBuffer() â†’ å‡†å¤‡æ•°æ®
render() â†’ ç›´æ¥ç»˜åˆ¶åˆ°Canvaså¹¶æ˜¾ç¤º â­
present() â†’ æ¸…ç†ç»Ÿè®¡æ•°æ®
```

## è®¾è®¡åŸå› 

è¿™ç§è®¾è®¡å·®å¼‚æºäºï¼š

1. **WebGLè§„èŒƒé™åˆ¶** - WebGLæ²¡æœ‰æ˜¾å¼çš„äº¤æ¢é“¾æ¦‚å¿µ
2. **æµè§ˆå™¨è‡ªåŠ¨æ˜¾ç¤º** - æµè§ˆå™¨è´Ÿè´£å°†Canvaså†…å®¹åˆæˆåˆ°é¡µé¢
3. **APIç»Ÿä¸€æ€§** - Cocosä¿æŒè·¨å¹³å°APIä¸€è‡´ï¼Œå³ä½¿æŸäº›å¹³å°çš„`present()`æ˜¯ç©ºæ“ä½œ

æ‚¨çš„åˆ†æéå¸¸ç²¾å‡†ï¼š**åœ¨Webç«¯ï¼Œ`present()`è™½ç„¶åä¸º"æ˜¾ç¤º"ï¼Œä½†å®é™…åªæ˜¯"æ¸…ç†"ï¼ŒçœŸæ­£çš„æ˜¾ç¤ºå·²ç»åœ¨`render()`é˜¶æ®µå®Œæˆäº†**ï¼

```typescript
public present (): void {
    const queue = (this._queue as WebGL2Queue);
    this._numDrawCalls = queue.numDrawCalls;
    this._numInstances = queue.numInstances;
    this._numTris = queue.numTris;
    queue.clear();
}
```

```typescript
private _frameMoveEnd (): void {
    const { director, Director } = cclegacy;
    const cameraList = this._cameraList;
    if (this._pipeline && cameraList.length > 0) {
        director.emit(Director.EVENT_BEFORE_COMMIT);
        cameraList.sort((a: Camera, b: Camera): number => a.priority - b.priority);

        for (let i = 0; i < cameraList.length; ++i) {
            cameraList[i].geometryRenderer?.update();
        }
        director.emit(Director.EVENT_BEFORE_RENDER);
        this._pipeline.render(cameraList);  // ğŸ‘ˆ è¿™é‡Œå·²ç»ç›´æ¥æ¸²æŸ“åˆ°å±å¹•
        director.emit(Director.EVENT_AFTER_RENDER);
        this._device.present();  // ğŸ‘ˆ åªæ˜¯æ¸…ç†æ•°æ®
    }

    if (this._batcher) this._batcher.reset();
}
```

```plaintext
uploadBuffer() â†’ å‡†å¤‡æ•°æ®
render() â†’ è®°å½•å‘½ä»¤ï¼Œç»˜åˆ¶åˆ°åå°ç¼“å†²åŒº  
present() â†’ äº¤æ¢å‰åç¼“å†²åŒºï¼Œæ˜¾ç¤ºåˆ°å±å¹• â­
```

```plaintext
uploadBuffer() â†’ å‡†å¤‡æ•°æ®
render() â†’ ç›´æ¥ç»˜åˆ¶åˆ°Canvaså¹¶æ˜¾ç¤º â­
present() â†’ æ¸…ç†ç»Ÿè®¡æ•°æ®
```

---

**User**

æˆ‘çŸ¥é“äº†åœ¨æ¸²æŸ“è¿‡ç¨‹ä¸­æœ‰ä¸€ä¸ªé‡è¦çš„å¢åŠ æ•ˆç‡çš„æ“ä½œæ˜¯æ‰¹å¤„ç†çš„è¿‡ç¨‹ï¼Œé‚£ä¹ˆæˆ‘æœ‰ä¸€ä¸ªé—®é¢˜å°±æ˜¯ï¼Œåœ¨æ•´ä¸ªçš„æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œè¿˜æ²¡æœ‰å…¶ä»–çš„ç±»ä¼¼æ“ä½œæˆ–è€…å·²ç»å®ç°æˆ–è€…å¯ä»¥å®ç°çš„ä¼˜åŒ–çš„æ–¹å¼å‘¢ï¼Ÿ

---

**Cursor**

è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„é—®é¢˜ï¼é™¤äº†æ‰¹å¤„ç†ä¹‹å¤–ï¼ŒCocos Engineä¸­ç¡®å®è¿˜æœ‰å¾ˆå¤šæ¸²æŸ“ä¼˜åŒ–æŠ€æœ¯ã€‚è®©æˆ‘æ·±å…¥æŸ¥çœ‹æºç æ¥ä¸ºæ‚¨åˆ†æï¼š

å¤ªå¥½äº†ï¼é€šè¿‡æ·±å…¥åˆ†ææºç ï¼Œæˆ‘å‘ç°Cocos Engineä¸­é™¤äº†æ‰¹å¤„ç†å¤–ï¼Œè¿˜å®ç°äº†å¾ˆå¤šå…¶ä»–é‡è¦çš„æ¸²æŸ“ä¼˜åŒ–æŠ€æœ¯ã€‚è®©æˆ‘ä¸ºæ‚¨è¯¦ç»†ä»‹ç»ï¼š

## ğŸ¯ Cocos Engineä¸­çš„æ¸²æŸ“ä¼˜åŒ–æŠ€æœ¯

### 1. **è§†é”¥ä½“è£å‰ª (Frustum Culling)**
```149:170:cocos-engine/cocos/rendering/scene-culling.ts
export function sceneCulling (sceneData: PipelineSceneData, pipelineUBO: PipelineUBO, camera: Camera): void {
    // ...
    function enqueueRenderObject (model: Model): void {
        if (model.enabled) {
            // è§†é”¥ä½“è£å‰ª
            if (model.worldBounds && !geometry.intersect.aabbFrustum(model.worldBounds, camera.frustum)) {
                return;  // ä¸åœ¨è§†é‡å†…çš„å¯¹è±¡ç›´æ¥å‰”é™¤
            }
            renderObjects.push(getRenderObject(model, camera));
        }
    }
}
```

**ä½œç”¨**: å‰”é™¤ç›¸æœºè§†é‡å¤–çš„ç‰©ä½“ï¼Œå‡å°‘æ— æ•ˆæ¸²æŸ“

### 2. **å…‰æºè£å‰ª (Light Culling)**
```45:60:cocos-engine/cocos/rendering/scene-culling.ts
export function validPunctualLightsCulling (sceneData: PipelineSceneData, camera: Camera): void {
    // å¯¹ç‚¹å…‰æºè¿›è¡Œè§†é”¥ä½“è£å‰ª
    for (let i = 0; i < spotLights.length; i++) {
        const light = spotLights[i];
        geometry.Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);
        if (geometry.intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);  // åªä¿ç•™å½±å“å½“å‰è§†é‡çš„å…‰æº
        }
    }
}
```

**ä½œç”¨**: åªè®¡ç®—å½±å“å½“å‰åœºæ™¯çš„å…‰æºï¼Œæå‡å…‰ç…§è®¡ç®—æ•ˆç‡

### 3. **é›†ç¾¤å…‰ç…§ (Clustered Light Culling)**
é€šè¿‡å®å®šä¹‰å’Œç¼“å†²åŒºå®ç°ï¼š
```
#define CC_ENABLE_CLUSTERED_LIGHT_CULLING
b_clusterLightIndicesBuffer  // é›†ç¾¤å…‰ç…§ç´¢å¼•ç¼“å†²
b_clusterLightGridBuffer     // é›†ç¾¤å…‰ç…§ç½‘æ ¼ç¼“å†²
```

**ä½œç”¨**: å°†å±å¹•åˆ†æˆ3Dç½‘æ ¼ï¼Œæ¯ä¸ªç½‘æ ¼åªè®¡ç®—ç›¸å…³å…‰æºï¼Œå¤§å¹…æå‡å¤šå…‰æºåœºæ™¯æ€§èƒ½

### 4. **LODçº§åˆ«ç»†èŠ‚ (Level of Detail)**
```lodgroup-component.ts
export class LODGroup extends Component {
    // æ ¹æ®è·ç¦»è‡ªåŠ¨åˆ‡æ¢æ¨¡å‹ç²¾åº¦
    public get LODs(): LOD[] { return this._LODs; }
    public set objectSize(val: number) { this._objectSize = val; }
}
```

**ä½œç”¨**: æ ¹æ®è·ç¦»è‡ªåŠ¨åˆ‡æ¢æ¨¡å‹ç²¾åº¦ï¼Œè¿œå¤„ç”¨ä½æ¨¡ï¼Œè¿‘å¤„ç”¨é«˜æ¨¡

### 5. **å®ä¾‹åŒ–æ¸²æŸ“ (Instancing)**
```
#define USE_INSTANCING
a_matWorld0, a_matWorld1, a_matWorld2  // å®ä¾‹åŒ–ä¸–ç•ŒçŸ©é˜µ
a_jointAnimInfo                        // å®ä¾‹åŒ–åŠ¨ç”»ä¿¡æ¯  
```

**ä½œç”¨**: ä¸€æ¬¡ç»˜åˆ¶è°ƒç”¨æ¸²æŸ“å¤šä¸ªç›¸åŒå‡ ä½•ä½“çš„å®ä¾‹ï¼Œå¦‚è‰åœ°ã€æ ‘æœ¨ç­‰

### 6. **åŠ¨æ€çº¹ç†å›¾é›† (Dynamic Atlas)**
```33:54:cocos-engine/cocos/2d/assembler/sprite/simple.ts
import { dynamicAtlasManager } from '../../utils/dynamic-atlas/atlas-manager';

// è‡ªåŠ¨å°†å°çº¹ç†åˆå¹¶åˆ°å›¾é›†ä¸­
dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
```

**ä½œç”¨**: è¿è¡Œæ—¶è‡ªåŠ¨å°†å°çº¹ç†åˆå¹¶åˆ°å¤§å›¾é›†ï¼Œå‡å°‘çº¹ç†åˆ‡æ¢å’ŒDrawCall

### 7. **å»¶è¿Ÿæ¸²æŸ“ (Deferred Rendering)**
```64:95:cocos-engine/cocos/rendering/deferred/deferred-pipeline.ts
export class DeferredPipeline extends RenderPipeline {
    // G-Bufferé˜¶æ®µï¼šå‡ ä½•ä¿¡æ¯å†™å…¥å¤šä¸ªæ¸²æŸ“ç›®æ ‡
    // Lightingé˜¶æ®µï¼šåŸºäºG-Bufferè¿›è¡Œå…‰ç…§è®¡ç®—
}
```

**ä½œç”¨**: å°†å‡ ä½•æ¸²æŸ“ä¸å…‰ç…§è®¡ç®—åˆ†ç¦»ï¼Œåœ¨å¤šå…‰æºåœºæ™¯ä¸­æ€§èƒ½æ›´ä¼˜

### 8. **é˜´å½±ä¼˜åŒ– (Shadow Optimization)**
- **CSMçº§è”é˜´å½±æ˜ å°„**: ä¸åŒè·ç¦»ä½¿ç”¨ä¸åŒç²¾åº¦çš„é˜´å½±è´´å›¾
- **é˜´å½±è£å‰ª**: åªå¯¹å½±å“é˜´å½±çš„ç‰©ä½“è¿›è¡Œé˜´å½±æ¸²æŸ“

### 9. **æè´¨æ‰¹å¤„ç† (Material Batching)**
```781:781:cocos-engine/cocos/2d/renderer/batcher-2d.ts
* @param material @en The material of the current batch.
```

**ä½œç”¨**: ç›¸åŒæè´¨çš„ç‰©ä½“åˆå¹¶ç»˜åˆ¶ï¼Œå‡å°‘çŠ¶æ€åˆ‡æ¢

### 10. **æ·±åº¦é¢„å†™ (Z-Prepass)**
é€šè¿‡æ¸²æŸ“æµç¨‹æ§åˆ¶ï¼Œå…ˆå†™å…¥æ·±åº¦ä¿¡æ¯ï¼Œæå‰å‰”é™¤è¢«é®æŒ¡çš„åƒç´ 

## ğŸš€ å¯ä»¥è¿›ä¸€æ­¥å®ç°çš„ä¼˜åŒ–

### 1. **GPUé©±åŠ¨æ¸²æŸ“ (GPU Driven Rendering)**
- ä½¿ç”¨è®¡ç®—ç€è‰²å™¨è¿›è¡Œè£å‰ªå’Œç»˜åˆ¶å†³ç­–
- å‡å°‘CPU-GPUåŒæ­¥å¼€é”€

### 2. **å¯è§æ€§ç¼“å†²æ¸²æŸ“ (Visibility Buffer Rendering)**
- å»¶è¿Ÿç€è‰²çš„è¿›åŒ–ç‰ˆæœ¬
- åªå­˜å‚¨å¯è§æ€§ä¿¡æ¯ï¼Œå‡å°‘å†…å­˜å¸¦å®½

### 3. **ç½‘æ ¼ç€è‰²å™¨ (Mesh Shaders)**
- ç°ä»£GPUçš„å‡ ä½•å¤„ç†ç®¡çº¿
- æ›´çµæ´»çš„å‡ ä½•ç”Ÿæˆå’Œè£å‰ª

### 4. **å˜åˆ†è¾¨ç‡æ¸²æŸ“ (Variable Rate Shading)**
- ä¸åŒåŒºåŸŸä½¿ç”¨ä¸åŒçš„ç€è‰²ç‡
- è¾¹ç¼˜åŒºåŸŸé™ä½ç²¾åº¦ï¼Œä¸­å¿ƒåŒºåŸŸä¿æŒé«˜ç²¾åº¦

## ğŸ’¡ æ€»ç»“

Cocos Engineå·²ç»å®ç°äº†ç›¸å½“å…¨é¢çš„æ¸²æŸ“ä¼˜åŒ–ä½“ç³»ï¼š

**CPUç«¯ä¼˜åŒ–**: è§†é”¥ä½“è£å‰ªã€å…‰æºè£å‰ªã€LODã€æ‰¹å¤„ç†
**GPUç«¯ä¼˜åŒ–**: å®ä¾‹åŒ–æ¸²æŸ“ã€é›†ç¾¤å…‰ç…§ã€å»¶è¿Ÿæ¸²æŸ“
**å†…å­˜ä¼˜åŒ–**: åŠ¨æ€å›¾é›†ã€æè´¨æ‰¹å¤„ç†
**å¸¦å®½ä¼˜åŒ–**: G-Bufferä¼˜åŒ–ã€æ·±åº¦é¢„å†™

è¿™äº›ä¼˜åŒ–æŠ€æœ¯ç»„åˆä½¿ç”¨ï¼Œå¯ä»¥æ˜¾è‘—æå‡æ¸²æŸ“æ€§èƒ½ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤æ‚åœºæ™¯å’Œç§»åŠ¨è®¾å¤‡ä¸Šæ•ˆæœæ˜æ˜¾ï¼

```typescript
export function sceneCulling (sceneData: PipelineSceneData, pipelineUBO: PipelineUBO, camera: Camera): void {
    // ...
    function enqueueRenderObject (model: Model): void {
        if (model.enabled) {
            // è§†é”¥ä½“è£å‰ª
            if (model.worldBounds && !geometry.intersect.aabbFrustum(model.worldBounds, camera.frustum)) {
                return;  // ä¸åœ¨è§†é‡å†…çš„å¯¹è±¡ç›´æ¥å‰”é™¤
            }
            renderObjects.push(getRenderObject(model, camera));
        }
    }
}
```

```typescript
export function validPunctualLightsCulling (sceneData: PipelineSceneData, camera: Camera): void {
    // å¯¹ç‚¹å…‰æºè¿›è¡Œè§†é”¥ä½“è£å‰ª
    for (let i = 0; i < spotLights.length; i++) {
        const light = spotLights[i];
        geometry.Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);
        if (geometry.intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);  // åªä¿ç•™å½±å“å½“å‰è§†é‡çš„å…‰æº
        }
    }
}
```

```plaintext
#define CC_ENABLE_CLUSTERED_LIGHT_CULLING
b_clusterLightIndicesBuffer  // é›†ç¾¤å…‰ç…§ç´¢å¼•ç¼“å†²
b_clusterLightGridBuffer     // é›†ç¾¤å…‰ç…§ç½‘æ ¼ç¼“å†²
```

```typescript
export class LODGroup extends Component {
    // æ ¹æ®è·ç¦»è‡ªåŠ¨åˆ‡æ¢æ¨¡å‹ç²¾åº¦
    public get LODs(): LOD[] { return this._LODs; }
    public set objectSize(val: number) { this._objectSize = val; }
}
```

```plaintext
#define USE_INSTANCING
a_matWorld0, a_matWorld1, a_matWorld2  // å®ä¾‹åŒ–ä¸–ç•ŒçŸ©é˜µ
a_jointAnimInfo                        // å®ä¾‹åŒ–åŠ¨ç”»ä¿¡æ¯  
```

```typescript
import { dynamicAtlasManager } from '../../utils/dynamic-atlas/atlas-manager';

// è‡ªåŠ¨å°†å°çº¹ç†åˆå¹¶åˆ°å›¾é›†ä¸­
dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
```

```typescript
export class DeferredPipeline extends RenderPipeline {
    // G-Bufferé˜¶æ®µï¼šå‡ ä½•ä¿¡æ¯å†™å…¥å¤šä¸ªæ¸²æŸ“ç›®æ ‡
    // Lightingé˜¶æ®µï¼šåŸºäºG-Bufferè¿›è¡Œå…‰ç…§è®¡ç®—
}
```

```typescript
* @param material @en The material of the current batch.
```

---

**User**

LODçº§åˆ«ç»†èŠ‚æ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿ

---

**Cursor**

è®©æˆ‘æ·±å…¥æŸ¥çœ‹Cocos Engineä¸­LODï¼ˆLevel of Detailï¼‰çš„å…·ä½“å®ç°æœºåˆ¶ï¼š

é€šè¿‡æ·±å…¥åˆ†ææºç ï¼Œæˆ‘æ¥ä¸ºæ‚¨è¯¦ç»†è§£é‡ŠCocos Engineä¸­LODï¼ˆLevel of Detailï¼‰ç³»ç»Ÿçš„å®ç°æœºåˆ¶ï¼š

## ğŸ¯ LODç³»ç»Ÿçš„æ ¸å¿ƒæ¶æ„

### 1. **LODç±»ç»“æ„**

```40:70:cocos-engine/cocos/3d/lod/lodgroup-component.ts
export class LOD {
    // å½“å‰LODçº§åˆ«ç”Ÿæ•ˆæ—¶çš„å±å¹•å ç”¨ç™¾åˆ†æ¯” [0, 1]
    protected _screenUsagePercentage = 1.0;
    // åŒ…å«åœ¨æ­¤LODçº§åˆ«ä¸­çš„ç½‘æ ¼æ¸²æŸ“å™¨ç»„ä»¶
    @type([MeshRenderer])
    protected _renderers: MeshRenderer[] = [];
    // æ¸²æŸ“å™¨å†…éƒ¨LODæ•°æ®å—
    private _LODData: scene.LODData = new scene.LODData();
}
```

**æ¯ä¸ªLODçº§åˆ«åŒ…å«ï¼š**
- `screenUsagePercentage`ï¼šè§¦å‘å½“å‰çº§åˆ«çš„æœ€å°å±å¹•å ç”¨ç™¾åˆ†æ¯”
- `renderers`ï¼šæ­¤çº§åˆ«ä½¿ç”¨çš„æ‰€æœ‰`MeshRenderer`ç»„ä»¶
- `_LODData`ï¼šå†…éƒ¨æ¸²æŸ“æ•°æ®

### 2. **LODGroupç»„ä»¶**

```219:245:cocos-engine/cocos/3d/lod/lodgroup-component.ts
export class LODGroup extends Component {
    // æœ¬åœ°è¾¹ç•Œä¸­å¿ƒç‚¹
    protected _localBoundaryCenter: Vec3 = new Vec3(0, 0, 0);
    // å¯¹è±¡å°ºå¯¸ï¼ˆå¯è‡ªåŠ¨è®¡ç®—æˆ–ç”¨æˆ·è®¾ç½®ï¼‰
    protected _objectSize = 0;
    // LODçº§åˆ«æ•°ç»„
    protected _LODs: LOD[] = [];
    // æ¸²æŸ“åœºæ™¯ä¸­çš„LODGroupå®ä¾‹
    protected _lodGroup = new scene.LODGroup();
}
```

## ğŸ” LODåˆ‡æ¢çš„æ ¸å¿ƒç®—æ³•

### 1. **å±å¹•å ç”¨ç‡è®¡ç®—**

```174:195:cocos-engine/cocos/render-scene/scene/lod-group.ts
getScreenUsagePercentage (camera: Camera): number {
    if (!this.node) return 0;

    let distance: number | undefined;
    if (camera.projectionType === CameraProjection.PERSPECTIVE) {
        // è®¡ç®—LODä¸­å¿ƒç‚¹åˆ°ç›¸æœºçš„è·ç¦»
        distance = Vec3.len(
            this.localBoundaryCenter
                .transformMat4(this.node.worldMatrix)
                .subtract(camera.node.worldPosition)
        );
    }

    return this.distanceToScreenUsagePercentage(camera, distance, this.getWorldSpaceSize());
}
```

### 2. **è·ç¦»åˆ°å±å¹•å ç”¨ç‡è½¬æ¢**

```197:205:cocos-engine/cocos/render-scene/scene/lod-group.ts
private distanceToScreenUsagePercentage (camera: Camera, distance: number | undefined, size: number): number {
    if (camera.projectionType === CameraProjection.PERSPECTIVE) {
        assertIsTrue(typeof distance === 'number', 'distance must be present for perspective projection');
        // é€è§†æŠ•å½±ï¼šsize * æŠ•å½±çŸ©é˜µ.m05 / (distance * 2.0)
        // æ³¨æ„ï¼šmatProj.m05 = 1 / tan(fov / 2.0)
        return (size * camera.matProj.m05) / (distance * 2.0);
    } else {
        // æ­£äº¤æŠ•å½±ï¼šsize * æŠ•å½±çŸ©é˜µ.m05 * 0.5
        return size * camera.matProj.m05 * 0.5;
    }
}
```

### 3. **LODçº§åˆ«é€‰æ‹©**

```148:161:cocos-engine/cocos/render-scene/scene/lod-group.ts
getVisibleLODLevel (camera: Camera): number {
    const screenUsagePercentage = this.getScreenUsagePercentage(camera);

    let lodIndex = -1;
    for (let i = 0; i < this.lodCount; ++i) {
        const lod = this.lodDataArray[i];
        // ä»é«˜ç²¾åº¦åˆ°ä½ç²¾åº¦éå†ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„çº§åˆ«
        if (screenUsagePercentage >= lod.screenUsagePercentage) {
            lodIndex = i;
            break;
        }
    }
    return lodIndex;
}
```

## ğŸ® LODç³»ç»Ÿåœ¨æ¸²æŸ“ç®¡çº¿ä¸­çš„é›†æˆ

### 1. **åœºæ™¯æ›´æ–°é˜¶æ®µ**

```237:238:cocos-engine/cocos/render-scene/core/render-scene.ts
public update (stamp: number): void {
    this._lodStateCache.updateLodState();  // æ›´æ–°æ‰€æœ‰LODçŠ¶æ€
}
```

### 2. **åœºæ™¯è£å‰ªé˜¶æ®µ**

```188:191:cocos-engine/cocos/rendering/scene-culling.ts
function enqueueRenderObject (model: Model): void {
    if (model.enabled) {
        // LODè£å‰ªæ£€æŸ¥
        if (scene.isCulledByLod(camera, model)) {
            return;  // è¢«LODç³»ç»Ÿè£å‰ªï¼Œè·³è¿‡æ¸²æŸ“
        }
        // ... å…¶ä»–è£å‰ªæ£€æŸ¥
    }
}
```

### 3. **LODçŠ¶æ€ç¼“å­˜ç®¡ç†**

```877:885:cocos-engine/cocos/render-scene/core/render-scene.ts
isLodModelCulled (camera: Camera, model: Model): boolean {
    const modelInfo = this._modelsInLODGroup.get(model);
    if (!modelInfo) {
        return false;  // ä¸å±äºLODç»„ï¼Œä¸è¢«è£å‰ª
    }
    // æ£€æŸ¥å½“å‰ç›¸æœºæ˜¯å¦èƒ½çœ‹åˆ°æ­¤æ¨¡å‹
    return !modelInfo.has(camera);
}
```

## âš¡ LODä¼˜åŒ–ç­–ç•¥

### 1. **é»˜è®¤LODé…ç½®**

```34:34:cocos-engine/cocos/3d/lod/lodgroup-component.ts
const DEFAULT_SCREEN_OCCUPATION: number[] = [0.25, 0.125, 0.01];
```

**é»˜è®¤3ä¸ªLODçº§åˆ«ï¼š**
- **LOD0**: å±å¹•å ç”¨ç‡ â‰¥ 25% (é«˜ç²¾åº¦æ¨¡å‹)
- **LOD1**: å±å¹•å ç”¨ç‡ â‰¥ 12.5% (ä¸­ç²¾åº¦æ¨¡å‹)  
- **LOD2**: å±å¹•å ç”¨ç‡ â‰¥ 1% (ä½ç²¾åº¦æ¨¡å‹)

### 2. **å¼ºåˆ¶LODçº§åˆ«**

```547:556:cocos-engine/cocos/3d/lod/lodgroup-component.ts
public forceLOD (lodLevel: number): void {
    this._forceUsedLevels = lodLevel < 0 ? [] : [lodLevel];
    this.lodGroup.lockLODLevels(this._forceUsedLevels);
}
```

### 3. **åŠ¨æ€è¾¹ç•Œè®¡ç®—**

```433:520:cocos-engine/cocos/3d/lod/lodgroup-component.ts
public recalculateBounds (): void {
    // è‡ªåŠ¨è®¡ç®—æ‰€æœ‰LODçº§åˆ«ä¸­æ¨¡å‹çš„è¾¹ç•Œæ¡†
    // è®¾ç½®æœ¬åœ°è¾¹ç•Œä¸­å¿ƒå’Œå¯¹è±¡å°ºå¯¸
    for (let i = 0; i < this.lodCount; ++i) {
        const lod = this.getLOD(i);
        if (lod) {
            for (let j = 0; j < lod.rendererCount; ++j) {
                const renderer = lod.getRenderer(j);
                if (renderer) {
                    renderer.model?.updateWorldBound();
                    // åˆå¹¶æ‰€æœ‰è¾¹ç•Œæ¡†...
                }
            }
        }
    }
}
```

## ğŸš€ LODç³»ç»Ÿçš„æ€§èƒ½ä¼˜åŠ¿

### 1. **æ¸²æŸ“æ€§èƒ½æå‡**
- **è¿œè·ç¦»å¯¹è±¡**ï¼šä½¿ç”¨ä½å¤šè¾¹å½¢æ¨¡å‹ï¼Œå‡å°‘GPUè´Ÿæ‹…
- **è¿‘è·ç¦»å¯¹è±¡**ï¼šä½¿ç”¨é«˜ç²¾åº¦æ¨¡å‹ï¼Œä¿è¯è§†è§‰è´¨é‡
- **è‡ªåŠ¨åˆ‡æ¢**ï¼šæ ¹æ®è·ç¦»æ— ç¼åˆ‡æ¢ï¼Œç”¨æˆ·æ— æ„ŸçŸ¥

### 2. **å†…å­˜ä¼˜åŒ–**
- **æŒ‰éœ€åŠ è½½**ï¼šåªæœ‰å½“å‰å¯è§çš„LODçº§åˆ«å‚ä¸æ¸²æŸ“
- **æ¨¡å‹å…±äº«**ï¼šå¤šä¸ªLODçº§åˆ«å¯å…±äº«ç›¸åŒæè´¨

### 3. **å¸¦å®½ä¼˜åŒ–**
- **å‡å°‘é¡¶ç‚¹æ•°æ®ä¼ è¾“**ï¼šè¿œè·ç¦»å¯¹è±¡ä¼ è¾“çš„é¡¶ç‚¹æ•°æ®æ›´å°‘
- **æ‰¹å¤„ç†å‹å¥½**ï¼šåŒä¸€LODçº§åˆ«çš„å¯¹è±¡æ›´å®¹æ˜“è¿›è¡Œæ‰¹å¤„ç†

LODç³»ç»Ÿæ˜¯ç°ä»£3Då¼•æ“ä¸­éå¸¸é‡è¦çš„æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯ï¼ŒCocos Engineçš„å®ç°æ—¢è€ƒè™‘äº†æ€§èƒ½ï¼Œåˆä¿æŒäº†ä½¿ç”¨çš„ç®€ä¾¿æ€§ï¼

```typescript
export class LOD {
    // å½“å‰LODçº§åˆ«ç”Ÿæ•ˆæ—¶çš„å±å¹•å ç”¨ç™¾åˆ†æ¯” [0, 1]
    protected _screenUsagePercentage = 1.0;
    // åŒ…å«åœ¨æ­¤LODçº§åˆ«ä¸­çš„ç½‘æ ¼æ¸²æŸ“å™¨ç»„ä»¶
    @type([MeshRenderer])
    protected _renderers: MeshRenderer[] = [];
    // æ¸²æŸ“å™¨å†…éƒ¨LODæ•°æ®å—
    private _LODData: scene.LODData = new scene.LODData();
}
```

```typescript
export class LODGroup extends Component {
    // æœ¬åœ°è¾¹ç•Œä¸­å¿ƒç‚¹
    protected _localBoundaryCenter: Vec3 = new Vec3(0, 0, 0);
    // å¯¹è±¡å°ºå¯¸ï¼ˆå¯è‡ªåŠ¨è®¡ç®—æˆ–ç”¨æˆ·è®¾ç½®ï¼‰
    protected _objectSize = 0;
    // LODçº§åˆ«æ•°ç»„
    protected _LODs: LOD[] = [];
    // æ¸²æŸ“åœºæ™¯ä¸­çš„LODGroupå®ä¾‹
    protected _lodGroup = new scene.LODGroup();
}
```

```typescript
getScreenUsagePercentage (camera: Camera): number {
    if (!this.node) return 0;

    let distance: number | undefined;
    if (camera.projectionType === CameraProjection.PERSPECTIVE) {
        // è®¡ç®—LODä¸­å¿ƒç‚¹åˆ°ç›¸æœºçš„è·ç¦»
        distance = Vec3.len(
            this.localBoundaryCenter
                .transformMat4(this.node.worldMatrix)
                .subtract(camera.node.worldPosition)
        );
    }

    return this.distanceToScreenUsagePercentage(camera, distance, this.getWorldSpaceSize());
}
```

```typescript
private distanceToScreenUsagePercentage (camera: Camera, distance: number | undefined, size: number): number {
    if (camera.projectionType === CameraProjection.PERSPECTIVE) {
        assertIsTrue(typeof distance === 'number', 'distance must be present for perspective projection');
        // é€è§†æŠ•å½±ï¼šsize * æŠ•å½±çŸ©é˜µ.m05 / (distance * 2.0)
        // æ³¨æ„ï¼šmatProj.m05 = 1 / tan(fov / 2.0)
        return (size * camera.matProj.m05) / (distance * 2.0);
    } else {
        // æ­£äº¤æŠ•å½±ï¼šsize * æŠ•å½±çŸ©é˜µ.m05 * 0.5
        return size * camera.matProj.m05 * 0.5;
    }
}
```

```typescript
getVisibleLODLevel (camera: Camera): number {
    const screenUsagePercentage = this.getScreenUsagePercentage(camera);

    let lodIndex = -1;
    for (let i = 0; i < this.lodCount; ++i) {
        const lod = this.lodDataArray[i];
        // ä»é«˜ç²¾åº¦åˆ°ä½ç²¾åº¦éå†ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„çº§åˆ«
        if (screenUsagePercentage >= lod.screenUsagePercentage) {
            lodIndex = i;
            break;
        }
    }
    return lodIndex;
}
```

```typescript
public update (stamp: number): void {
    this._lodStateCache.updateLodState();  // æ›´æ–°æ‰€æœ‰LODçŠ¶æ€
}
```

```typescript
function enqueueRenderObject (model: Model): void {
    if (model.enabled) {
        // LODè£å‰ªæ£€æŸ¥
        if (scene.isCulledByLod(camera, model)) {
            return;  // è¢«LODç³»ç»Ÿè£å‰ªï¼Œè·³è¿‡æ¸²æŸ“
        }
        // ... å…¶ä»–è£å‰ªæ£€æŸ¥
    }
}
```

```typescript
isLodModelCulled (camera: Camera, model: Model): boolean {
    const modelInfo = this._modelsInLODGroup.get(model);
    if (!modelInfo) {
        return false;  // ä¸å±äºLODç»„ï¼Œä¸è¢«è£å‰ª
    }
    // æ£€æŸ¥å½“å‰ç›¸æœºæ˜¯å¦èƒ½çœ‹åˆ°æ­¤æ¨¡å‹
    return !modelInfo.has(camera);
}
```

```typescript
const DEFAULT_SCREEN_OCCUPATION: number[] = [0.25, 0.125, 0.01];
```

```typescript
public forceLOD (lodLevel: number): void {
    this._forceUsedLevels = lodLevel < 0 ? [] : [lodLevel];
    this.lodGroup.lockLODLevels(this._forceUsedLevels);
}
```

```typescript
public recalculateBounds (): void {
    // è‡ªåŠ¨è®¡ç®—æ‰€æœ‰LODçº§åˆ«ä¸­æ¨¡å‹çš„è¾¹ç•Œæ¡†
    // è®¾ç½®æœ¬åœ°è¾¹ç•Œä¸­å¿ƒå’Œå¯¹è±¡å°ºå¯¸
    for (let i = 0; i < this.lodCount; ++i) {
        const lod = this.getLOD(i);
        if (lod) {
            for (let j = 0; j < lod.rendererCount; ++j) {
                const renderer = lod.getRenderer(j);
                if (renderer) {
                    renderer.model?.updateWorldBound();
                    // åˆå¹¶æ‰€æœ‰è¾¹ç•Œæ¡†...
                }
            }
        }
    }
}
```

---

**User**

LODçš„æ•´ä½“æµç¨‹æ˜¯æ€ä¹ˆæ ·çš„å‘¢ï¼Ÿæ˜¯æ€ä¹ˆæ ·è¿ä½œçš„å‘¢ï¼Ÿå…¶ä¸­å…³é”®çš„æ–¹æ³•æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ

---

**Cursor**

è®©æˆ‘æ·±å…¥æŸ¥çœ‹LODç³»ç»Ÿçš„æ•´ä½“æµç¨‹å’Œå…³é”®æ–¹æ³•ï¼š

é€šè¿‡æ·±å…¥åˆ†ææºç ï¼Œæˆ‘æ¥ä¸ºæ‚¨è¯¦ç»†è§£é‡Š**LODç³»ç»Ÿçš„æ•´ä½“æµç¨‹å’Œå…³é”®æ–¹æ³•**ï¼š

## ğŸ¯ LODç³»ç»Ÿçš„æ•´ä½“è¿ä½œæµç¨‹

### 1. **åˆå§‹åŒ–é˜¶æ®µ**

```579:591:cocos-engine/cocos/render-scene/core/render-scene.ts
addLODGroup (lodGroup: LODGroup): void {
    lodGroup.attachToScene(this);
    this._lodGroups.push(lodGroup);
    this._lodStateCache.addLodGroup(lodGroup);
}
```

- `LODGroup`ç»„ä»¶è¢«æ·»åŠ åˆ°åœºæ™¯ä¸­
- æ¯ä¸ª`LODGroup`åŒ…å«å¤šä¸ª`LODData`ï¼Œæ¯ä¸ªä»£è¡¨ä¸€ä¸ªç»†èŠ‚çº§åˆ«
- åˆå§‹åŒ–LODçŠ¶æ€ç¼“å­˜

### 2. **æ¯å¸§æ›´æ–°æµç¨‹ï¼ˆå…³é”®å…¥å£ï¼‰**

**ä½ç½®**: `RenderScene.update()` â†’ `LodStateCache.updateLodState()`

```710:810:cocos-engine/cocos/render-scene/core/render-scene.ts
updateLodState (): void {
    // å¤„ç†æ–°æ·»åŠ çš„LODGroup
    this._newAddedLodGroupVec.forEach((addedLodGroup) => {
        // ...ä¸ºæ¯ä¸ªLODçº§åˆ«å»ºç«‹Modelæ˜ å°„
    });

    // éå†æ‰€æœ‰LODGroupï¼Œæ›´æ–°LODçŠ¶æ€
    const lodGroups = this._renderScene.lodGroups;
    for (let i = 0; i < lodGroups.length; i++) {
        const lodGroup = lodGroups[i];
        if (lodGroup.enabled) {
            // æ£€æŸ¥æ˜¯å¦æœ‰å¼ºåˆ¶ä½¿ç”¨çš„LODçº§åˆ«
            const lodLevels = lodGroup.getLockedLODLevels();
            
            if (count === 0) {  // æ­£å¸¸LODå¤„ç†
                for (const visibleCamera of this._lodStateInCamera) {
                    // å…³é”®ï¼šè®¡ç®—å¯è§LODçº§åˆ«
                    const index = lodGroup.getVisibleLODLevel(visibleCamera[0]);
                    if (index !== lodInfo.usedLevel) {
                        lodInfo.lastUsedLevel = lodInfo.usedLevel;
                        lodInfo.usedLevel = index;
                        hasUpdated = true;
                    }
                }
            }
            
            // æ›´æ–°Modelçš„å¯è§æ€§çŠ¶æ€
            if (hasUpdated) {
                // æ›´æ–°å“ªäº›Modelå¯¹å“ªäº›Cameraå¯è§
            }
        }
    }
}
```

### 3. **æ ¸å¿ƒç®—æ³•ï¼šè·ç¦»è®¡ç®—ä¸LODé€‰æ‹©**

```166:212:cocos-engine/cocos/render-scene/scene/lod-group.ts
getVisibleLODLevel (camera: Camera): number {
    const screenUsagePercentage = this.getScreenUsagePercentage(camera);

    let lodIndex = -1;
    for (let i = 0; i < this.lodCount; ++i) {
        const lod = this.lodDataArray[i];
        if (screenUsagePercentage >= lod.screenUsagePercentage) {
            lodIndex = i;
            break;
        }
    }
    return lodIndex;
}

getScreenUsagePercentage (camera: Camera): number {
    if (!this.node) return 0;

    let distance: number | undefined;
    if (camera.projectionType === CameraProjection.PERSPECTIVE) {
        // è®¡ç®—ç‰©ä½“ä¸­å¿ƒåˆ°ç›¸æœºçš„è·ç¦»
        distance = Vec3.len(
            this.localBoundaryCenter
                .transformMat4(this.node.worldMatrix)
                .subtract(camera.node.worldPosition)
        );
    }

    return this.distanceToScreenUsagePercentage(camera, distance, this.getWorldSpaceSize());
}

private distanceToScreenUsagePercentage (camera: Camera, distance: number, size: number): number {
    if (camera.projectionType === CameraProjection.PERSPECTIVE) {
        // é€è§†æŠ•å½±ï¼šå±å¹•å ç”¨ç™¾åˆ†æ¯” = (ç‰©ä½“å¤§å° * æŠ•å½±å‚æ•°) / (è·ç¦» * 2)
        return (size * camera.matProj.m05) / (distance * 2.0);
    } else {
        // æ­£äº¤æŠ•å½±
        return size * camera.matProj.m05 * 0.5;
    }
}
```

### 4. **æ¸²æŸ“è£å‰ªé˜¶æ®µåº”ç”¨**

```185:190:cocos-engine/cocos/rendering/scene-culling.ts
function enqueueRenderObject (model: Model): void {
    if (model.enabled) {
        // ğŸ“ å…³é”®ï¼šLODè£å‰ªæ£€æŸ¥
        if (scene.isCulledByLod(camera, model)) {
            return;  // å½“å‰LODçº§åˆ«ä¸‹ä¸å¯è§ï¼Œç›´æ¥å‰”é™¤
        }
        
        // ç»§ç»­å…¶ä»–è£å‰ª...
        if (model.castShadow) {
            castShadowObjects.push(getRenderObject(model, camera));
        }
        // ...
    }
}
```

```254:260:cocos-engine/cocos/render-scene/core/render-scene.ts
public isCulledByLod (camera: Camera, model: Model): boolean {
    return this._lodStateCache.isLodModelCulled(camera, model);
}
```

## ğŸ”§ å…³é”®æ–¹æ³•æ€»ç»“

### **æ ¸å¿ƒè®¡ç®—æ–¹æ³•**
1. **`getVisibleLODLevel(camera)`** - æ ¹æ®ç›¸æœºè®¡ç®—å½“å‰åº”ä½¿ç”¨çš„LODçº§åˆ«
2. **`getScreenUsagePercentage(camera)`** - è®¡ç®—ç‰©ä½“åœ¨å±å¹•ä¸Šçš„å ç”¨ç™¾åˆ†æ¯”
3. **`distanceToScreenUsagePercentage()`** - è·ç¦»åˆ°å±å¹•å ç”¨ç™¾åˆ†æ¯”çš„è½¬æ¢

### **çŠ¶æ€ç®¡ç†æ–¹æ³•**
1. **`updateLodState()`** - æ¯å¸§æ›´æ–°æ‰€æœ‰LODGroupçš„çŠ¶æ€
2. **`isCulledByLod()`** - åˆ¤æ–­Modelæ˜¯å¦è¢«LODè£å‰ª
3. **`isLodModelCulled()`** - æ£€æŸ¥æŒ‡å®šModelå¯¹ç‰¹å®šCameraæ˜¯å¦å¯è§

### **æ•°æ®ç»“æ„**
- **`LODData`** - å•ä¸ªLODçº§åˆ«çš„æ•°æ®ï¼ˆåŒ…å«screenUsagePercentageå’Œmodelsï¼‰
- **`LODGroup`** - LODç»„ç®¡ç†å™¨ï¼ˆåŒ…å«å¤šä¸ªLODDataï¼‰
- **`LODInfo`** - ç›¸æœºè§†è§’ä¸‹çš„LODçŠ¶æ€ä¿¡æ¯
- **`LodStateCache`** - LODçŠ¶æ€ç¼“å­˜ç®¡ç†å™¨

## ğŸš€ è¿ä½œåŸç†æ€»ç»“

1. **è·ç¦»è®¡ç®—** â†’ **å±å¹•å ç”¨ç™¾åˆ†æ¯”** â†’ **LODçº§åˆ«é€‰æ‹©** â†’ **Modelå¯è§æ€§æ›´æ–°** â†’ **æ¸²æŸ“è£å‰ªåº”ç”¨**

2. **æ ¸å¿ƒä¼˜åŒ–ç‚¹**ï¼š
   - åŸºäºå±å¹•å ç”¨ç™¾åˆ†æ¯”è€Œéç®€å•è·ç¦»ï¼Œæ›´ç¬¦åˆè§†è§‰æ•ˆæœ
   - æ”¯æŒé€è§†å’Œæ­£äº¤æŠ•å½±çš„ä¸åŒè®¡ç®—æ–¹å¼
   - ç¼“å­˜LODçŠ¶æ€ï¼Œé¿å…é‡å¤è®¡ç®—
   - åœ¨åœºæ™¯è£å‰ªé˜¶æ®µæ—©æœŸå‰”é™¤ï¼Œå‡å°‘åç»­å¤„ç†

è¿™ä¸ªLODç³»ç»Ÿè®¾è®¡å¾—éå¸¸ç²¾å¯†ï¼Œèƒ½å¤Ÿæœ‰æ•ˆå‡å°‘è¿œè·ç¦»ç‰©ä½“çš„æ¸²æŸ“å¼€é”€ï¼

```typescript
addLODGroup (lodGroup: LODGroup): void {
    lodGroup.attachToScene(this);
    this._lodGroups.push(lodGroup);
    this._lodStateCache.addLodGroup(lodGroup);
}
```

```typescript
updateLodState (): void {
    // å¤„ç†æ–°æ·»åŠ çš„LODGroup
    this._newAddedLodGroupVec.forEach((addedLodGroup) => {
        // ...ä¸ºæ¯ä¸ªLODçº§åˆ«å»ºç«‹Modelæ˜ å°„
    });

    // éå†æ‰€æœ‰LODGroupï¼Œæ›´æ–°LODçŠ¶æ€
    const lodGroups = this._renderScene.lodGroups;
    for (let i = 0; i < lodGroups.length; i++) {
        const lodGroup = lodGroups[i];
        if (lodGroup.enabled) {
            // æ£€æŸ¥æ˜¯å¦æœ‰å¼ºåˆ¶ä½¿ç”¨çš„LODçº§åˆ«
            const lodLevels = lodGroup.getLockedLODLevels();
            
            if (count === 0) {  // æ­£å¸¸LODå¤„ç†
                for (const visibleCamera of this._lodStateInCamera) {
                    // å…³é”®ï¼šè®¡ç®—å¯è§LODçº§åˆ«
                    const index = lodGroup.getVisibleLODLevel(visibleCamera[0]);
                    if (index !== lodInfo.usedLevel) {
                        lodInfo.lastUsedLevel = lodInfo.usedLevel;
                        lodInfo.usedLevel = index;
                        hasUpdated = true;
                    }
                }
            }
            
            // æ›´æ–°Modelçš„å¯è§æ€§çŠ¶æ€
            if (hasUpdated) {
                // æ›´æ–°å“ªäº›Modelå¯¹å“ªäº›Cameraå¯è§
            }
        }
    }
}
```

```typescript
getVisibleLODLevel (camera: Camera): number {
    const screenUsagePercentage = this.getScreenUsagePercentage(camera);

    let lodIndex = -1;
    for (let i = 0; i < this.lodCount; ++i) {
        const lod = this.lodDataArray[i];
        if (screenUsagePercentage >= lod.screenUsagePercentage) {
            lodIndex = i;
            break;
        }
    }
    return lodIndex;
}

getScreenUsagePercentage (camera: Camera): number {
    if (!this.node) return 0;

    let distance: number | undefined;
    if (camera.projectionType === CameraProjection.PERSPECTIVE) {
        // è®¡ç®—ç‰©ä½“ä¸­å¿ƒåˆ°ç›¸æœºçš„è·ç¦»
        distance = Vec3.len(
            this.localBoundaryCenter
                .transformMat4(this.node.worldMatrix)
                .subtract(camera.node.worldPosition)
        );
    }

    return this.distanceToScreenUsagePercentage(camera, distance, this.getWorldSpaceSize());
}

private distanceToScreenUsagePercentage (camera: Camera, distance: number, size: number): number {
    if (camera.projectionType === CameraProjection.PERSPECTIVE) {
        // é€è§†æŠ•å½±ï¼šå±å¹•å ç”¨ç™¾åˆ†æ¯” = (ç‰©ä½“å¤§å° * æŠ•å½±å‚æ•°) / (è·ç¦» * 2)
        return (size * camera.matProj.m05) / (distance * 2.0);
    } else {
        // æ­£äº¤æŠ•å½±
        return size * camera.matProj.m05 * 0.5;
    }
}
```

```typescript
function enqueueRenderObject (model: Model): void {
    if (model.enabled) {
        // ğŸ“ å…³é”®ï¼šLODè£å‰ªæ£€æŸ¥
        if (scene.isCulledByLod(camera, model)) {
            return;  // å½“å‰LODçº§åˆ«ä¸‹ä¸å¯è§ï¼Œç›´æ¥å‰”é™¤
        }
        
        // ç»§ç»­å…¶ä»–è£å‰ª...
        if (model.castShadow) {
            castShadowObjects.push(getRenderObject(model, camera));
        }
        // ...
    }
}
```

```typescript
public isCulledByLod (camera: Camera, model: Model): boolean {
    return this._lodStateCache.isLodModelCulled(camera, model);
}
```

