| 优化技术 | 性能提升 | 适用场景 | 实现难度 |
|----------|----------|----------|----------|
| **批处理** | 2-10倍 | UI、2D游戏 | 简单 |
| **实例化** | 10-100倍 | 大量相同对象 | 中等 |
| **LOD系统** | 2-5倍 | 3D场景 | 中等 |
| **视锥剔除** | 2-4倍 | 开放世界 | 简单 |
| **遮挡剔除** | 1.5-3倍 | 复杂场景 | 复杂 |
| **纹理压缩** | 2-4倍内存节约 | 所有项目 | 简单 |
| **延迟渲染** | 支持100+光源 | 多光源场景 | 复杂 |
| **瓦片渲染** | 支持1000+光源 | 大量光源 | 很复杂 |
| **计算着色器** | 10-50倍 | 并行计算 | 中等 |
| **GPU驱动** | 5-20倍 | 大规模场景 | 很复杂 |

## 🎯 选择指南

### 项目初期（必备优化）
1. 基础批处理
> 原理：将多个使用相同材质和纹理的小对象合并成一个大的顶点缓冲区，用一次Draw Call渲染
> 场景：UI界面、2D精灵、地形瓦片等大量小对象的渲染
2. 视锥剔除
> 原理：通过摄像机的6个平面（上下左右前后）检测物体是否在可见范围内，不可见则跳过渲染
> 场景：开放世界、大场景中有大量超出屏幕范围的物体时
3. 纹理压缩和Mipmap
> 原理：压缩纹理减少显存占用，Mipmap预生成不同分辨率版本供远距离采样使用
> 场景：移动端项目、纹理资源丰富的3D游戏
4. 基础LOD
> 原理：根据物体到摄像机的距离选择不同精度的模型版本，远处用低精度模型
> 场景：3D场景中的建筑、树木、角色等复杂模型

### 项目中期（性能提升）
5. 实例化渲染
> 原理：一次Draw Call渲染多个相同几何体的不同实例，每个实例有独立的变换矩阵
> 场景：森林中的树木、草地、粒子系统、重复建筑群
6. UBO优化
> 原理：将频繁使用的uniform数据打包到统一缓冲区，一次绑定多个着色器共享
> 场景：摄像机矩阵、光照参数等多个着色器共用的数据
7. 计算着色器
> 原理：利用GPU的并行计算能力执行非渲染任务，通过SSBO读写大量数据
> 场景：粒子物理模拟、布料模拟、后处理效果、AI寻路计算
8. 着色器优化（Uber Shader）
> 原理：一个包含所有功能分支的超级着色器，通过宏定义和条件编译生成特化版本
> 场景：材质系统复杂、需要支持多种渲染效果的项目

### 项目后期（高级优化）
9. GPU驱动渲染
> 原理：让GPU自主决定渲染哪些物体，CPU只负责上传数据，GPU通过间接绘制指令控制渲染流程
> 场景：超大规模场景（数十万物体）、开放世界游戏
10. 延迟/瓦片渲染
> 原理：先渲染几何信息到G-Buffer，再逐像素计算光照；瓦片渲染将屏幕分块独立处理光源
> 场景：大量动态光源的场景、复杂室内环境、多光源战斗场面
11. 高级剔除技术
> 原理：遮挡剔除（被挡住的不渲染）、GPU剔除（GPU计算可见性）、细节剔除（太小的不渲染）
> 场景：复杂建筑内部、密集森林、超高密度场景
12. 异步渲染
> 原理：多线程并行构建渲染命令，主线程负责逻辑，渲染线程专门处理GPU指令
> 场景：CPU成为瓶颈的复杂项目、需要高帧率的竞技游戏