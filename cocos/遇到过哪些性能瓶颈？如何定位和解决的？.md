Search files...
# æ¸¸æˆå¼€å‘ä¸­å¸¸è§çš„æ€§èƒ½ç“¶é¢ˆåŠè§£å†³æ–¹æ¡ˆ ğŸ¯âš¡

åŸºäºå®é™…é¡¹ç›®ç»éªŒï¼Œæˆ‘æ¥è¯¦ç»†åˆ†ææ¸¸æˆå¼€å‘ä¸­é‡åˆ°çš„å„ç§æ€§èƒ½ç“¶é¢ˆåŠå…¶å®šä½å’Œè§£å†³æ–¹æ³•ã€‚

## 1. Draw Call ç“¶é¢ˆï¼ˆæœ€å¸¸è§ï¼‰ ğŸ“Š

### é—®é¢˜ç°è±¡
```typescript
// å…¸å‹é—®é¢˜åœºæ™¯
const performanceIssue = {
    symptoms: {
        frameRate: "ä»60fpsæ‰åˆ°20-30fps",
        profilerData: "Draw Calls > 1000",
        platform: "ç§»åŠ¨ç«¯ç‰¹åˆ«æ˜æ˜¾"
    },
    cause: "å¤§é‡å°UIå…ƒç´ ã€ç²’å­æ•ˆæœã€ç›¸ä¼¼ç‰©ä½“åˆ†åˆ«æ¸²æŸ“"
};
```

### å®šä½æ–¹æ³•
```cpp
// Unity Profiler æ•°æ®åˆ†æ
class DrawCallProfiler {
    void AnalyzePerformance() {
        // ğŸ” å…³é”®æŒ‡æ ‡ç›‘æ§
        int drawCalls = Graphics.activeDrawCall;
        int batches = Graphics.activeBatches;
        int triangles = Graphics.activeTriangles;
        
        // ğŸ“Š ç“¶é¢ˆåˆ¤æ–­
        if (drawCalls > 500 && batches / drawCalls < 0.3f) {
            LogWarning("åˆæ‰¹æ•ˆç‡ä½ï¼Œå¤§é‡ç‹¬ç«‹Draw Call");
        }
        
        if (triangles / drawCalls < 50) {
            LogWarning("æ¯ä¸ªDraw Callä¸‰è§’å½¢æ•°é‡è¿‡å°‘ï¼Œæ•ˆç‡ä½ä¸‹");
        }
    }
    
    // ğŸ¯ çƒ­ç‚¹åˆ†æ
    void FindDrawCallHotspots() {
        // ä½¿ç”¨Frame Debuggeråˆ†ææ¯ä¸ªDraw Call
        var renderers = FindObjectsOfType<Renderer>();
        
        foreach (var renderer in renderers) {
            if (!renderer.isStaticBatched && !renderer.isDynamicBatched) {
                LogInfo($"æ— æ³•åˆæ‰¹çš„å¯¹è±¡: {renderer.name}");
                AnalyzeBatchingFailure(renderer);
            }
        }
    }
};
```

### è§£å†³æ–¹æ¡ˆ
```typescript
// Cocos Creator æ‰¹å¤„ç†ä¼˜åŒ–
class DrawCallOptimizer {
    // ğŸ¯ UIå…ƒç´ åˆæ‰¹
    optimizeUIBatching() {
        // 1. å›¾é›†åˆå¹¶
        this.createTextureAtlas();
        
        // 2. ç›¸åŒæè´¨æ’åº
        this.sortByMaterial();
        
        // 3. é™æ€UIé¢„åˆæ‰¹
        this.enableStaticBatching();
    }
    
    private createTextureAtlas() {
        // ğŸ“ å°†å°å›¾ç‰‡åˆå¹¶åˆ°å¤§å›¾é›†
        const atlas = new cc.SpriteAtlas();
        const smallTextures = ['icon1.png', 'icon2.png', 'ui_bg.png'];
        
        // åˆå¹¶åï¼š1000ä¸ªå°å›¾æ ‡ â†’ 10ä¸ªDraw Call
        atlas.packTextures(smallTextures);
    }
    
    // ğŸ“Š æ€§èƒ½æå‡å¯¹æ¯”
    private getOptimizationResults() {
        return {
            before: { drawCalls: 1200, frameTime: 25.6 },
            after: { drawCalls: 85, frameTime: 8.3 },
            improvement: "å¸§æ—¶é—´æå‡67%"
        };
    }
}
```

## 2. GPUè¿‡åº¦ç»˜åˆ¶ç“¶é¢ˆ ğŸ¨

### é—®é¢˜ç°è±¡
```cpp
// GPU Overdraw æ£€æµ‹
class OverdrawAnalyzer {
    struct OverdrawMetrics {
        float averageOverdraw;      // å¹³å‡è¿‡åº¦ç»˜åˆ¶ç‡
        float maxOverdraw;          // æœ€å¤§è¿‡åº¦ç»˜åˆ¶ç‡
        int affectedPixels;         // å—å½±å“çš„åƒç´ æ•°
    };
    
    OverdrawMetrics analyzeScene() {
        // ğŸ” ä½¿ç”¨æ·±åº¦å¤æ‚åº¦åˆ†æ
        return {
            .averageOverdraw = 3.2f,    // æ¯ä¸ªåƒç´ å¹³å‡ç»˜åˆ¶3.2æ¬¡
            .maxOverdraw = 8.0f,        // æŸäº›åŒºåŸŸç»˜åˆ¶8æ¬¡
            .affectedPixels = 800000    // 80ä¸‡åƒç´ å—å½±å“
        };
    }
};
```

### å®šä½å·¥å…·
```csharp
// Unity Frame Debugger + RenderDoc åˆ†æ
public class OverdrawProfiler {
    void DetectOverdraw() {
        // ğŸ“Š å¼€å¯Overdrawå¯è§†åŒ–
        Camera.main.SetReplacementShader(overdrawShader, "RenderType");
        
        // ğŸ” åˆ†æç»“æœ
        // ç»¿è‰²ï¼šæ­£å¸¸ï¼ˆ1-2æ¬¡ç»˜åˆ¶ï¼‰
        // é»„è‰²ï¼šè½»å¾®è¿‡åº¦ç»˜åˆ¶ï¼ˆ3-4æ¬¡ï¼‰
        // çº¢è‰²ï¼šä¸¥é‡è¿‡åº¦ç»˜åˆ¶ï¼ˆ5æ¬¡ä»¥ä¸Šï¼‰
        
        LogOverdrawHotspots();
    }
    
    void LogOverdrawHotspots() {
        // ğŸ¯ æ‰¾å‡ºè¿‡åº¦ç»˜åˆ¶çƒ­ç‚¹
        var transparentObjects = FindObjectsWithTag("Transparent");
        var uiElements = FindObjectsOfType<CanvasRenderer>();
        
        // åˆ†æé€æ˜ç‰©ä½“å±‚å æƒ…å†µ
        AnalyzeTransparencyLayers(transparentObjects);
    }
}
```

### è§£å†³æ–¹æ¡ˆ
```typescript
// è¿‡åº¦ç»˜åˆ¶ä¼˜åŒ–ç­–ç•¥
class OverdrawOptimizer {
    // ğŸ¯ é€æ˜ç‰©ä½“ä¼˜åŒ–
    optimizeTransparency() {
        // 1. å‡å°‘é€æ˜å±‚çº§
        this.reduceTransparencyLayers();
        
        // 2. ä½¿ç”¨Alpha Testæ›¿ä»£Alpha Blend
        this.useAlphaTest();
        
        // 3. ç²’å­ç³»ç»Ÿä¼˜åŒ–
        this.optimizeParticles();
    }
    
    private reduceTransparencyLayers() {
        // âŒ é—®é¢˜ï¼šå¤šå±‚é€æ˜UIå åŠ 
        const problemCase = {
            background: "åŠé€æ˜èƒŒæ™¯",
            panel: "åŠé€æ˜é¢æ¿", 
            button: "åŠé€æ˜æŒ‰é’®",
            effect: "é€æ˜ç‰¹æ•ˆ",
            overdraw: "4å±‚å åŠ  = 4å€è¿‡åº¦ç»˜åˆ¶"
        };
        
        // âœ… è§£å†³ï¼šåˆå¹¶é€æ˜å…ƒç´ 
        const solution = {
            approach: "é¢„æ¸²æŸ“åˆæˆ",
            result: "4å±‚ â†’ 1å±‚",
            improvement: "75%è¿‡åº¦ç»˜åˆ¶å‡å°‘"
        };
    }
    
    private optimizeParticles() {
        // ğŸ† ç²’å­ç³»ç»Ÿä¼˜åŒ–
        const particleOptimization = {
            // å‡å°‘ç²’å­æ•°é‡
            maxParticles: "ä»1000é™åˆ°300",
            
            // ä½¿ç”¨ç®€å•ç€è‰²å™¨
            shader: "Unlit/Transparent â†’ Custom/SimpleParticle",
            
            // é¢„åˆæ‰¹ç²’å­çº¹ç†
            texture: "åˆå¹¶åˆ°ç²’å­å›¾é›†",
            
            // è·ç¦»LOD
            culling: "è·ç¦»è¿‡è¿œæ—¶ç¦ç”¨ç²’å­"
        };
    }
}
```

## 3. å†…å­˜ç“¶é¢ˆ ğŸ’¾

### é—®é¢˜ç°è±¡
```cpp
// å†…å­˜æ³„æ¼æ£€æµ‹
class MemoryBottleneckDetector {
    struct MemoryIssue {
        size_t textureMemory;       // çº¹ç†å†…å­˜å ç”¨
        size_t meshMemory;          // ç½‘æ ¼å†…å­˜å ç”¨
        size_t audioMemory;         // éŸ³é¢‘å†…å­˜å ç”¨
        int gcFrequency;            // GCé¢‘ç‡
    };
    
    MemoryIssue detectIssues() {
        return {
            .textureMemory = 800 * 1024 * 1024,  // 800MBçº¹ç†å†…å­˜
            .meshMemory = 200 * 1024 * 1024,     // 200MBç½‘æ ¼
            .audioMemory = 150 * 1024 * 1024,    // 150MBéŸ³é¢‘
            .gcFrequency = 30  // æ¯ç§’30æ¬¡GCï¼Œä¸¥é‡å½±å“å¸§ç‡
        };
    }
};
```

### å®šä½æ–¹æ³•
```csharp
// Unity Memory Profiler æ·±åº¦åˆ†æ
public class MemoryProfiler {
    void AnalyzeMemoryUsage() {
        // ğŸ” è¯¦ç»†å†…å­˜åˆ†æ
        var snapshot = MemorySnapshot.Take();
        
        // ğŸ“Š çº¹ç†å†…å­˜åˆ†æ
        AnalyzeTextureMemory(snapshot);
        
        // ğŸ§  æ‰˜ç®¡å†…å­˜åˆ†æ
        AnalyzeManagedMemory(snapshot);
        
        // ğŸ“± åŸç”Ÿå†…å­˜åˆ†æ
        AnalyzeNativeMemory(snapshot);
    }
    
    void AnalyzeTextureMemory(MemorySnapshot snapshot) {
        var textures = snapshot.nativeObjects.OfType<Texture2D>();
        
        var largeTextures = textures
            .Where(t => t.GetRuntimeMemorySize() > 10 * 1024 * 1024)
            .OrderByDescending(t => t.GetRuntimeMemorySize());
        
        foreach (var texture in largeTextures) {
            Debug.LogWarning($"å¤§çº¹ç†: {texture.name} - {texture.GetRuntimeMemorySize() / (1024*1024)}MB");
            
            // ğŸ¯ åˆ†æé—®é¢˜
            if (!texture.isReadable && texture.mipmapCount > 1) {
                Debug.Log("å»ºè®®ï¼šå…³é—­Mipmapæˆ–é™ä½åˆ†è¾¨ç‡");
            }
        }
    }
    
    void AnalyzeManagedMemory(MemorySnapshot snapshot) {
        // ğŸ” æŸ¥æ‰¾å†…å­˜æ³„æ¼
        var managedObjects = snapshot.managedObjects;
        
        // æ£€æŸ¥å¸¸è§æ³„æ¼æº
        CheckEventHandlerLeaks(managedObjects);
        CheckCollectionLeaks(managedObjects);
        CheckClosureLeaks(managedObjects);
    }
}
```

### è§£å†³æ–¹æ¡ˆ
```typescript
// å†…å­˜ä¼˜åŒ–ç»¼åˆæ–¹æ¡ˆ
class MemoryOptimizer {
    // ğŸ¯ çº¹ç†å†…å­˜ä¼˜åŒ–
    optimizeTextureMemory() {
        const strategies = {
            // 1. å‹ç¼©æ ¼å¼ä¼˜åŒ–
            compression: {
                mobile: "ASTC 6x6 (50%å†…å­˜èŠ‚çœ)",
                pc: "BC7 (66%å†…å­˜èŠ‚çœ)",
                web: "DXT5 (75%å†…å­˜èŠ‚çœ)"
            },
            
            // 2. åˆ†è¾¨ç‡ä¼˜åŒ–
            resolution: {
                ui: "é™ä½50%åˆ†è¾¨ç‡ â†’ 75%å†…å­˜èŠ‚çœ",
                background: "é™ä½25%åˆ†è¾¨ç‡ â†’ 44%å†…å­˜èŠ‚çœ",
                effect: "é™ä½75%åˆ†è¾¨ç‡ â†’ 94%å†…å­˜èŠ‚çœ"
            },
            
            // 3. åŠ¨æ€åŠ è½½å¸è½½
            streaming: {
                approach: "æŒ‰åœºæ™¯åˆ†å—åŠ è½½",
                result: "å†…å­˜å ç”¨ç¨³å®šåœ¨512MBä»¥å†…"
            }
        };
        
        return strategies;
    }
    
    // ğŸ§  æ‰˜ç®¡å†…å­˜ä¼˜åŒ–
    optimizeManagedMemory() {
        // 1. å¯¹è±¡æ± å‡å°‘GC
        this.implementObjectPool();
        
        // 2. é¿å…è£…ç®±æ‹†ç®±
        this.avoidBoxing();
        
        // 3. å‡å°‘å­—ç¬¦ä¸²æ‹¼æ¥
        this.optimizeStringOperations();
    }
    
    private implementObjectPool() {
        // ğŸ”„ å¯¹è±¡æ± ç¤ºä¾‹
        class BulletPool {
            private pool: cc.Node[] = [];
            
            getBullet(): cc.Node {
                if (this.pool.length > 0) {
                    return this.pool.pop()!; // é‡ç”¨å¯¹è±¡
                }
                return this.createNewBullet(); // å¿…è¦æ—¶åˆ›å»º
            }
            
            returnBullet(bullet: cc.Node) {
                bullet.active = false;
                this.pool.push(bullet); // å›æ”¶åˆ°æ± ä¸­
            }
        }
        
        // ğŸ“Š æ•ˆæœï¼šGCæ¬¡æ•°ä»æ¯ç§’30æ¬¡ â†’ æ¯ç§’2æ¬¡
    }
}
```

## 4. CPUè®¡ç®—ç“¶é¢ˆ ğŸ§®

### é—®é¢˜ç°è±¡
```cpp
// CPUçƒ­ç‚¹åˆ†æ
class CPUBottleneckAnalyzer {
    struct CPUHotspot {
        std::string functionName;
        float timePercentage;
        int callCount;
        float averageTime;
    };
    
    std::vector<CPUHotspot> analyzeHotspots() {
        return {
            {"Physics.Simulate", 35.2f, 1, 5.8f},      // ç‰©ç†æ¨¡æ‹Ÿ
            {"UI.Layout", 28.4f, 450, 0.12f},          // UIå¸ƒå±€è®¡ç®—
            {"Animation.Update", 15.3f, 200, 0.15f},   // åŠ¨ç”»æ›´æ–°
            {"AI.Pathfinding", 12.1f, 50, 0.48f},      // å¯»è·¯ç®—æ³•
            {"Scripting.Update", 9.0f, 800, 0.02f}     // è„šæœ¬æ›´æ–°
        };
    }
};
```

### å®šä½å·¥å…·
```csharp
// Unity Profiler + è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§
public class CPUProfiler {
    void ProfileCPUUsage() {
        // ğŸ” ä½¿ç”¨Unity Profileråˆ†æ
        using (Profiler.BeginSample("PhysicsUpdate")) {
            Physics.Simulate(Time.fixedDeltaTime);
        }
        
        using (Profiler.BeginSample("AIUpdate")) {
            UpdateAI();
        }
        
        // ğŸ“Š è‡ªå®šä¹‰æ€§èƒ½è®¡æ•°å™¨
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        UpdateGameLogic();
        stopwatch.Stop();
        
        if (stopwatch.ElapsedMilliseconds > 2) {
            Debug.LogWarning($"æ¸¸æˆé€»è¾‘æ›´æ–°è€—æ—¶: {stopwatch.ElapsedMilliseconds}ms");
        }
    }
    
    // ğŸ¯ æ·±åº¦åˆ†æç‰¹å®šå‡½æ•°
    void DeepProfileFunction() {
        // ä½¿ç”¨ProfilerMarkerè¿›è¡Œç»†ç²’åº¦åˆ†æ
        using (var marker = new ProfilerMarker("ExpensiveFunction")) {
            using (marker.Auto()) {
                ExpensiveFunction();
            }
        }
    }
}
```

### è§£å†³æ–¹æ¡ˆ
```typescript
// CPUä¼˜åŒ–ç­–ç•¥
class CPUOptimizer {
    // ğŸ§® ç‰©ç†è®¡ç®—ä¼˜åŒ–
    optimizePhysics() {
        const optimizations = {
            // 1. é™ä½ç‰©ç†æ›´æ–°é¢‘ç‡
            fixedTimeStep: "ä»60Hzé™åˆ°30Hz",
            
            // 2. ç®€åŒ–ç¢°æ’ä½“
            colliders: "Box/Sphereæ›¿ä»£Meshç¢°æ’ä½“",
            
            // 3. åˆ†å±‚ç‰©ç†è®¡ç®—
            layers: "é‡è¦ç‰©ä½“30Hzï¼Œç¯å¢ƒç‰©ä½“10Hz",
            
            // 4. è·ç¦»è£å‰ª
            culling: "è·ç¦»ç©å®¶è¿‡è¿œæ—¶ç¦ç”¨ç‰©ç†"
        };
        
        // ğŸ“Š ä¼˜åŒ–æ•ˆæœ
        return {
            before: "ç‰©ç†è®¡ç®—35%CPUå ç”¨",
            after: "ç‰©ç†è®¡ç®—12%CPUå ç”¨",
            improvement: "CPUè´Ÿè½½å‡å°‘66%"
        };
    }
    
    // ğŸ¨ UIè®¡ç®—ä¼˜åŒ–
    optimizeUI() {
        // 1. å‡å°‘Layouté‡è®¡ç®—
        this.optimizeLayoutCalculation();
        
        // 2. è™šæ‹ŸåŒ–é•¿åˆ—è¡¨
        this.implementVirtualization();
        
        // 3. ç¼“å­˜è®¡ç®—ç»“æœ
        this.cacheCalculations();
    }
    
    private optimizeLayoutCalculation() {
        // âŒ é—®é¢˜ï¼šæ¯å¸§é‡æ–°è®¡ç®—æ‰€æœ‰UIå¸ƒå±€
        class BadUIManager {
            update() {
                // æ¯å¸§éƒ½é‡ç®—ï¼Œæµªè´¹CPU
                this.recalculateAllLayouts();
            }
        }
        
        // âœ… è§£å†³ï¼šåªåœ¨éœ€è¦æ—¶é‡æ–°è®¡ç®—
        class OptimizedUIManager {
            private layoutDirty = false;
            
            update() {
                if (this.layoutDirty) {
                    this.recalculateLayouts();
                    this.layoutDirty = false;
                }
            }
            
            markLayoutDirty() {
                this.layoutDirty = true;
            }
        }
    }
    
    // ğŸ¤– AIè®¡ç®—ä¼˜åŒ–
    optimizeAI() {
        return {
            // 1. åˆ†å¸§è®¡ç®—
            frameSplitting: "å¯»è·¯è®¡ç®—åˆ†æ•£åˆ°å¤šå¸§",
            
            // 2. LODç³»ç»Ÿ
            lod: "è·ç¦»è¿‘çš„AIé«˜é¢‘æ›´æ–°ï¼Œè¿œçš„ä½é¢‘æ›´æ–°",
            
            // 3. é¢„è®¡ç®—ç¼“å­˜
            cache: "ç¼“å­˜å¸¸ç”¨è·¯å¾„å’Œå†³ç­–ç»“æœ",
            
            // 4. åç¨‹å¼‚æ­¥
            async: "é•¿è€—æ—¶AIä»»åŠ¡ä½¿ç”¨åç¨‹"
        };
    }
}
```

## 5. ç½‘ç»œç“¶é¢ˆ ğŸŒ

### é—®é¢˜ç°è±¡
```cpp
// ç½‘ç»œæ€§èƒ½åˆ†æ
class NetworkBottleneckDetector {
    struct NetworkMetrics {
        float latency;              // å»¶è¿Ÿ
        float packetLoss;           // ä¸¢åŒ…ç‡
        int bandwidthUsage;         // å¸¦å®½ä½¿ç”¨
        int messageQueueSize;       // æ¶ˆæ¯é˜Ÿåˆ—å¤§å°
    };
    
    NetworkMetrics analyzeNetwork() {
        return {
            .latency = 150.0f,          // 150mså»¶è¿Ÿï¼ˆåé«˜ï¼‰
            .packetLoss = 3.2f,         // 3.2%ä¸¢åŒ…ç‡
            .bandwidthUsage = 2500,     // 2.5MB/så¸¦å®½å ç”¨
            .messageQueueSize = 850     // é˜Ÿåˆ—ç§¯å‹850æ¡æ¶ˆæ¯
        };
    }
};
```

### å®šä½å’Œè§£å†³
```typescript
// ç½‘ç»œä¼˜åŒ–ç»¼åˆæ–¹æ¡ˆ
class NetworkOptimizer {
    // ğŸ“Š æ•°æ®å‹ç¼©ä¼˜åŒ–
    optimizeDataCompression() {
        // 1. åè®®ç¼“å†²åŒº
        const protobuf = {
            before: "JSON: 1200å­—èŠ‚",
            after: "Protobuf: 280å­—èŠ‚",
            compression: "77%å‹ç¼©ç‡"
        };
        
        // 2. å¢é‡æ›´æ–°
        const deltaCompression = {
            approach: "åªå‘é€å˜åŒ–çš„æ•°æ®",
            example: "ä½ç½®æ›´æ–°ï¼š12å­—èŠ‚ â†’ 4å­—èŠ‚",
            result: "ç½‘ç»œæµé‡å‡å°‘70%"
        };
        
        return { protobuf, deltaCompression };
    }
    
    // ğŸ”„ æ¶ˆæ¯é˜Ÿåˆ—ä¼˜åŒ–
    optimizeMessageQueue() {
        class OptimizedNetworkManager {
            private messageQueue: NetworkMessage[] = [];
            private maxQueueSize = 100;
            
            // ğŸ¯ ä¼˜å…ˆçº§é˜Ÿåˆ—
            enqueueMessage(message: NetworkMessage) {
                if (this.messageQueue.length >= this.maxQueueSize) {
                    // ä¸¢å¼ƒä½ä¼˜å…ˆçº§æ¶ˆæ¯
                    this.dropLowPriorityMessages();
                }
                
                // æŒ‰ä¼˜å…ˆçº§æ’å…¥
                this.insertByPriority(message);
            }
            
            // âš¡ æ‰¹é‡å¤„ç†
            processMessages() {
                const batchSize = 10;
                const batch = this.messageQueue.splice(0, batchSize);
                
                // æ‰¹é‡å‘é€å‡å°‘ç½‘ç»œå¼€é”€
                this.sendBatch(batch);
            }
        }
    }
}
```

## 6. æ€§èƒ½ç›‘æ§å’Œé¢„è­¦ç³»ç»Ÿ ğŸ“Š

### å®æ—¶ç›‘æ§
```cpp
// ç»¼åˆæ€§èƒ½ç›‘æ§ç³»ç»Ÿ
class PerformanceMonitor {
    struct PerformanceData {
        float frameTime;
        int drawCalls;
        size_t memoryUsage;
        float cpuUsage;
        float gpuUsage;
        int networkLatency;
    };
    
    void MonitorPerformance() {
        auto data = GatherPerformanceData();
        
        // ğŸš¨ æ€§èƒ½é¢„è­¦
        CheckPerformanceThresholds(data);
        
        // ğŸ“Š æ•°æ®è®°å½•
        LogPerformanceData(data);
        
        // ğŸ¯ è‡ªåŠ¨ä¼˜åŒ–
        TriggerAutoOptimization(data);
    }
    
    void CheckPerformanceThresholds(const PerformanceData& data) {
        if (data.frameTime > 16.67f) {
            TriggerOptimization(OptimizationType::FrameRate);
        }
        
        if (data.drawCalls > 500) {
            TriggerOptimization(OptimizationType::DrawCalls);
        }
        
        if (data.memoryUsage > 512 * 1024 * 1024) {
            TriggerOptimization(OptimizationType::Memory);
        }
    }
};
```

## æ€»ç»“ï¼šæ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ ğŸ¯

### ğŸ“Š **ä¼˜åŒ–ä¼˜å…ˆçº§æ’åºï¼š**
1. **Draw Callä¼˜åŒ–** - æŠ•å…¥äº§å‡ºæ¯”æœ€é«˜
2. **å†…å­˜ä¼˜åŒ–** - å½±å“ç¨³å®šæ€§
3. **CPUç“¶é¢ˆ** - å½±å“æ¸¸æˆé€»è¾‘æµç•…åº¦
4. **GPUè¿‡åº¦ç»˜åˆ¶** - å½±å“æ¸²æŸ“æ•ˆç‡
5. **ç½‘ç»œä¼˜åŒ–** - å½±å“å¤šäººæ¸¸æˆä½“éªŒ

### ğŸ” **å®šä½å·¥å…·é“¾ï¼š**
- **Unity**: Profiler + Frame Debugger + Memory Profiler
- **Cocos Creator**: Chrome DevTools + Creatorè°ƒè¯•å™¨
- **é€šç”¨**: RenderDoc, PIX, Xcode Instruments

### âš¡ **ä¼˜åŒ–ç­–ç•¥ï¼š**
- **é¢„é˜²ä¸ºä¸»**: ä»æ¶æ„è®¾è®¡å¼€å§‹è€ƒè™‘æ€§èƒ½
- **æ•°æ®é©±åŠ¨**: åŸºäºå®é™…æ€§èƒ½æ•°æ®è¿›è¡Œä¼˜åŒ–
- **åˆ†å±‚ä¼˜åŒ–**: å…ˆè§£å†³å½±å“æœ€å¤§çš„ç“¶é¢ˆ
- **æŒç»­ç›‘æ§**: å»ºç«‹æ€§èƒ½å›å½’é¢„è­¦æœºåˆ¶

é€šè¿‡ç³»ç»Ÿæ€§çš„æ€§èƒ½åˆ†æå’Œä¼˜åŒ–ï¼Œé€šå¸¸å¯ä»¥è·å¾—**2-5å€çš„æ€§èƒ½æå‡**ï¼Œè®©æ¸¸æˆåœ¨å„ç§è®¾å¤‡ä¸Šéƒ½èƒ½æµç•…è¿è¡Œï¼

# CPUå’ŒGPUä¼˜åŒ–ç­–ç•¥è¯¦è§£ ğŸ’»ğŸ®

æ ¹æ®æ¸¸æˆå¼€å‘å®è·µç»éªŒï¼Œæˆ‘æ¥è¯¦ç»†åˆ†æCPUå’ŒGPUçš„ä¸åŒä¼˜åŒ–ç­–ç•¥å’ŒåŸç†ã€‚

## CPUä¼˜åŒ–ç­–ç•¥ ğŸ§®

### 1. **ç®—æ³•å’Œæ•°æ®ç»“æ„ä¼˜åŒ–**

#### **ç©ºé—´åˆ†å‰²ç®—æ³•ä¼˜åŒ–**
```cpp
// ç©ºé—´æŸ¥è¯¢ä¼˜åŒ–ï¼šO(nÂ²) â†’ O(log n)
class SpatialOptimization {
    // âŒ æš´åŠ›æŸ¥è¯¢ï¼šO(nÂ²)å¤æ‚åº¦
    std::vector<Entity> FindNearbyEntities_Slow(const Vector3& position, float radius) {
        std::vector<Entity> result;
        for (const auto& entity : allEntities) {  // éå†æ‰€æœ‰å®ä½“
            if (Distance(entity.position, position) <= radius) {
                result.push_back(entity);
            }
        }
        return result;
    }
    
    // âœ… å…«å‰æ ‘ä¼˜åŒ–ï¼šO(log n)å¤æ‚åº¦
    class Octree {
        struct Node {
            BoundingBox bounds;
            std::vector<Entity> entities;
            std::array<std::unique_ptr<Node>, 8> children;
            bool isLeaf = true;
        };
        
        std::unique_ptr<Node> root;
        
    public:
        std::vector<Entity> Query(const Vector3& position, float radius) {
            std::vector<Entity> result;
            QueryRecursive(root.get(), BoundingSphere{position, radius}, result);
            return result;
        }
        
    private:
        void QueryRecursive(Node* node, const BoundingSphere& sphere, std::vector<Entity>& result) {
            if (!Intersects(node->bounds, sphere)) return;
            
            if (node->isLeaf) {
                // å¶èŠ‚ç‚¹ï¼šæ£€æŸ¥å®ä½“
                for (const auto& entity : node->entities) {
                    if (Distance(entity.position, sphere.center) <= sphere.radius) {
                        result.push_back(entity);
                    }
                }
            } else {
                // é€’å½’æŸ¥è¯¢å­èŠ‚ç‚¹
                for (auto& child : node->children) {
                    if (child) QueryRecursive(child.get(), sphere, result);
                }
            }
        }
    };
};
```

#### **ç¼“å­˜å‹å¥½çš„æ•°æ®å¸ƒå±€**
```cpp
// å†…å­˜è®¿é—®æ¨¡å¼ä¼˜åŒ–
class CacheFriendlyOptimization {
    // âŒ AoS (Array of Structures) - ç¼“å­˜ä¸å‹å¥½
    struct Transform_AoS {
        Vector3 position;
        Vector3 rotation;
        Vector3 scale;
        Matrix4x4 worldMatrix;    // 64å­—èŠ‚ï¼Œå¯èƒ½è·¨è¶Šå¤šä¸ªç¼“å­˜è¡Œ
    };
    std::vector<Transform_AoS> transforms_aos;
    
    // âœ… SoA (Structure of Arrays) - ç¼“å­˜å‹å¥½
    struct TransformSystem_SoA {
        std::vector<Vector3> positions;     // è¿ç»­çš„ä½ç½®æ•°æ®
        std::vector<Vector3> rotations;     // è¿ç»­çš„æ—‹è½¬æ•°æ®
        std::vector<Vector3> scales;        // è¿ç»­çš„ç¼©æ”¾æ•°æ®
        std::vector<Matrix4x4> worldMatrices; // è¿ç»­çš„çŸ©é˜µæ•°æ®
    };
    
    // ğŸš€ æ€§èƒ½å¯¹æ¯”æµ‹è¯•
    void BenchmarkMemoryAccess() {
        const int ENTITY_COUNT = 100000;
        
        // AoSæµ‹è¯•ï¼šè®¿é—®æ‰€æœ‰ä½ç½®
        auto start = std::chrono::high_resolution_clock::now();
        for (const auto& transform : transforms_aos) {
            ProcessPosition(transform.position);  // ç¼“å­˜æœªå‘½ä¸­ç‡é«˜
        }
        auto aos_time = std::chrono::high_resolution_clock::now() - start;
        
        // SoAæµ‹è¯•ï¼šè®¿é—®æ‰€æœ‰ä½ç½®
        start = std::chrono::high_resolution_clock::now();
        for (const auto& position : transformSystem.positions) {
            ProcessPosition(position);  // ç¼“å­˜å‘½ä¸­ç‡é«˜
        }
        auto soa_time = std::chrono::high_resolution_clock::now() - start;
        
        // ğŸ“Š ç»“æœï¼šSoAé€šå¸¸å¿«2-4å€
        std::cout << "AoS: " << aos_time.count() << "ns\n";
        std::cout << "SoA: " << soa_time.count() << "ns\n";
        std::cout << "Speedup: " << (float)aos_time.count() / soa_time.count() << "x\n";
    }
};
```

### 2. **å¤šçº¿ç¨‹å¹¶è¡ŒåŒ–**

#### **ä»»åŠ¡å¹¶è¡ŒåŒ–**
```cpp
// æ¸¸æˆç³»ç»Ÿçš„å¹¶è¡Œå¤„ç†
class ParallelGameSystems {
    ThreadPool workerPool;
    
public:
    void UpdateSystems(float deltaTime) {
        // ğŸ”„ å¹¶è¡Œæ›´æ–°ç‹¬ç«‹ç³»ç»Ÿ
        auto physicsFuture = workerPool.enqueue([this, deltaTime] {
            physicsSystem.Update(deltaTime);
        });
        
        auto aiFuture = workerPool.enqueue([this, deltaTime] {
            aiSystem.Update(deltaTime);
        });
        
        auto audioFuture = workerPool.enqueue([this, deltaTime] {
            audioSystem.Update(deltaTime);
        });
        
        // ä¸»çº¿ç¨‹å¤„ç†æ¸²æŸ“ç›¸å…³
        renderSystem.Update(deltaTime);
        
        // ç­‰å¾…å¹¶è¡Œä»»åŠ¡å®Œæˆ
        physicsFuture.wait();
        aiFuture.wait();
        audioFuture.wait();
    }
    
    // ğŸ§® æ•°æ®å¹¶è¡Œï¼šæ‰¹é‡å¤„ç†å®ä½“
    void UpdateTransforms(std::vector<Entity>& entities) {
        const size_t numThreads = std::thread::hardware_concurrency();
        const size_t entitiesPerThread = entities.size() / numThreads;
        
        std::vector<std::future<void>> futures;
        
        for (size_t i = 0; i < numThreads; ++i) {
            size_t start = i * entitiesPerThread;
            size_t end = (i == numThreads - 1) ? entities.size() : start + entitiesPerThread;
            
            futures.push_back(workerPool.enqueue([&entities, start, end] {
                for (size_t j = start; j < end; ++j) {
                    UpdateEntityTransform(entities[j]);
                }
            }));
        }
        
        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for (auto& future : futures) {
            future.wait();
        }
    }
};
```

### 3. **å†…å­˜ç®¡ç†ä¼˜åŒ–**

#### **å¯¹è±¡æ± å’Œå†…å­˜æ± **
```cpp
// é«˜æ•ˆçš„å†…å­˜åˆ†é…ç­–ç•¥
template<typename T, size_t POOL_SIZE = 1000>
class ObjectPool {
private:
    // ğŸ¯ é¢„åˆ†é…å†…å­˜å—
    alignas(T) char storage[POOL_SIZE * sizeof(T)];
    std::stack<T*> freeObjects;
    std::atomic<size_t> allocatedCount{0};
    
public:
    ObjectPool() {
        // åˆå§‹åŒ–ç©ºé—²å¯¹è±¡æ ˆ
        for (size_t i = 0; i < POOL_SIZE; ++i) {
            freeObjects.push(reinterpret_cast<T*>(&storage[i * sizeof(T)]));
        }
    }
    
    // âš¡ å¿«é€Ÿåˆ†é…
    T* Acquire() {
        if (freeObjects.empty()) {
            return nullptr; // æ± è€—å°½
        }
        
        T* obj = freeObjects.top();
        freeObjects.pop();
        allocatedCount++;
        
        // placement new
        return new(obj) T();
    }
    
    // ğŸ”„ å¿«é€Ÿé‡Šæ”¾
    void Release(T* obj) {
        if (!obj) return;
        
        obj->~T(); // è°ƒç”¨ææ„å‡½æ•°
        freeObjects.push(obj);
        allocatedCount--;
    }
    
    // ğŸ“Š æ± çŠ¶æ€ç›‘æ§
    float GetUsageRatio() const {
        return static_cast<float>(allocatedCount) / POOL_SIZE;
    }
};

// ğŸ“Š æ€§èƒ½å¯¹æ¯”
void BenchmarkObjectPool() {
    const int ITERATIONS = 1000000;
    
    // ä¼ ç»Ÿnew/delete
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < ITERATIONS; ++i) {
        auto* obj = new GameObject();
        delete obj;
    }
    auto traditional_time = std::chrono::high_resolution_clock::now() - start;
    
    // å¯¹è±¡æ± 
    ObjectPool<GameObject> pool;
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < ITERATIONS; ++i) {
        auto* obj = pool.Acquire();
        pool.Release(obj);
    }
    auto pool_time = std::chrono::high_resolution_clock::now() - start;
    
    // ç»“æœï¼šå¯¹è±¡æ± é€šå¸¸å¿«5-10å€
    std::cout << "Traditional: " << traditional_time.count() << "ns\n";
    std::cout << "Object Pool: " << pool_time.count() << "ns\n";
}
```

### 4. **ç®—æ³•å¤æ‚åº¦ä¼˜åŒ–**

#### **ç¢°æ’æ£€æµ‹ä¼˜åŒ–**
```cpp
// ç¢°æ’æ£€æµ‹çš„å¤šå±‚ä¼˜åŒ–
class CollisionOptimizer {
    // ğŸ” å®½ç›¸æ£€æµ‹ï¼šå¿«é€Ÿæ’é™¤
    std::vector<CollisionPair> BroadPhase(const std::vector<Collider>& colliders) {
        std::vector<CollisionPair> potentialPairs;
        
        // ä½¿ç”¨AABBåŒ…å›´ç›’å¿«é€Ÿæ£€æµ‹
        for (size_t i = 0; i < colliders.size(); ++i) {
            for (size_t j = i + 1; j < colliders.size(); ++j) {
                if (AABBIntersect(colliders[i].bounds, colliders[j].bounds)) {
                    potentialPairs.push_back({i, j});
                }
            }
        }
        
        return potentialPairs;
    }
    
    // ğŸ¯ çª„ç›¸æ£€æµ‹ï¼šç²¾ç¡®è®¡ç®—
    std::vector<Collision> NarrowPhase(const std::vector<CollisionPair>& pairs,
                                      const std::vector<Collider>& colliders) {
        std::vector<Collision> collisions;
        
        // åªå¯¹é€šè¿‡å®½ç›¸çš„å¯¹è±¡è¿›è¡Œç²¾ç¡®æ£€æµ‹
        for (const auto& pair : pairs) {
            auto collision = PreciseCollisionTest(colliders[pair.first], colliders[pair.second]);
            if (collision.hasCollision) {
                collisions.push_back(collision);
            }
        }
        
        return collisions;
    }
    
    // ğŸ“Š å¤æ‚åº¦åˆ†æ
    void AnalyzeComplexity() {
        /*
         * æš´åŠ›æ£€æµ‹ï¼šO(nÂ²) - ä¸å¯æ¥å—
         * å®½ç›¸+çª„ç›¸ï¼šO(n log n) + O(k) - å…¶ä¸­k<<nÂ²
         * ç©ºé—´åˆ†å‰²ï¼šO(n) + O(k) - æœ€ä¼˜æƒ…å†µ
         */
    }
};
```

## GPUä¼˜åŒ–ç­–ç•¥ ğŸ®

### 1. **æ¸²æŸ“è°ƒç”¨ä¼˜åŒ–**

#### **æ‰¹å¤„ç†å’Œå®ä¾‹åŒ–**
```cpp
// GPUæ‰¹å¤„ç†ä¼˜åŒ–
class GPUBatchingOptimizer {
    // âŒ æ¯ä¸ªå¯¹è±¡å•ç‹¬Draw Call
    void RenderObjects_Inefficient(const std::vector<GameObject>& objects) {
        for (const auto& obj : objects) {
            SetMaterial(obj.material);
            SetTexture(obj.texture);
            SetTransform(obj.transform);
            DrawMesh(obj.mesh);  // 1000ä¸ªå¯¹è±¡ = 1000ä¸ªDraw Call
        }
    }
    
    // âœ… é™æ€æ‰¹å¤„ç†
    void RenderObjects_StaticBatching(const std::vector<GameObject>& objects) {
        // é¢„è®¡ç®—ï¼šåˆå¹¶ç›¸åŒæè´¨çš„é™æ€å¯¹è±¡
        auto batches = CreateStaticBatches(objects);
        
        for (const auto& batch : batches) {
            SetMaterial(batch.material);
            SetTexture(batch.texture);
            DrawMesh(batch.combinedMesh);  // 1000ä¸ªå¯¹è±¡ â†’ 10ä¸ªDraw Call
        }
    }
    
    // ğŸš€ GPUå®ä¾‹åŒ–æ¸²æŸ“
    void RenderObjects_Instancing(const std::vector<GameObject>& objects) {
        // æŒ‰ç½‘æ ¼åˆ†ç»„
        auto instanceGroups = GroupByMesh(objects);
        
        for (const auto& group : instanceGroups) {
            // å‡†å¤‡å®ä¾‹æ•°æ®
            std::vector<InstanceData> instanceData;
            for (const auto& obj : group.objects) {
                instanceData.push_back({
                    obj.transform.worldMatrix,
                    obj.color,
                    obj.textureOffset
                });
            }
            
            // ä¸Šä¼ å®ä¾‹æ•°æ®åˆ°GPU
            SetInstanceBuffer(instanceData);
            
            // ä¸€æ¬¡Draw Callæ¸²æŸ“æ‰€æœ‰å®ä¾‹
            DrawMeshInstanced(group.mesh, group.material, instanceData.size());
        }
    }
    
    // ğŸ“Š æ€§èƒ½å¯¹æ¯”
    struct RenderingStats {
        int drawCalls;
        float cpuTime;
        float gpuTime;
    };
    
    RenderingStats GetStats() {
        return {
            // ä¼ ç»Ÿæ¸²æŸ“ï¼š1000 Draw Callï¼ŒCPU 15msï¼ŒGPU 8ms
            // é™æ€æ‰¹å¤„ç†ï¼š50 Draw Callï¼ŒCPU 8msï¼ŒGPU 5ms  
            // å®ä¾‹åŒ–æ¸²æŸ“ï¼š10 Draw Callï¼ŒCPU 3msï¼ŒGPU 3ms
        };
    }
};
```

### 2. **çº¹ç†å’Œå†…å­˜ä¼˜åŒ–**

#### **çº¹ç†å‹ç¼©å’ŒMipmap**
```cpp
// çº¹ç†å†…å­˜ä¼˜åŒ–
class TextureOptimizer {
    // ğŸ¯ å¹³å°ç‰¹åŒ–çš„çº¹ç†æ ¼å¼
    void OptimizeTextureFormats() {
        struct PlatformFormat {
            std::string platform;
            std::string format;
            float compressionRatio;
            std::string quality;
        };
        
        std::vector<PlatformFormat> formats = {
            {"iOS", "ASTC 6x6", 0.33f, "é«˜è´¨é‡"},
            {"Android", "ETC2", 0.50f, "ä¸­ç­‰è´¨é‡"}, 
            {"PC", "BC7", 0.25f, "æœ€é«˜è´¨é‡"},
            {"WebGL", "DXT5", 0.25f, "å…¼å®¹æ€§æœ€å¥½"}
        };
        
        // è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ ¼å¼
        for (const auto& format : formats) {
            ApplyTextureFormat(format.platform, format.format);
        }
    }
    
    // ğŸ“Š Mipmapé“¾ä¼˜åŒ–
    void OptimizeMipmaps() {
        struct MipmapSettings {
            std::string textureType;
            bool enableMipmap;
            std::string reason;
        };
        
        std::vector<MipmapSettings> settings = {
            {"UIçº¹ç†", false, "UIå…ƒç´ å›ºå®šå¤§å°ï¼Œä¸éœ€è¦Mipmap"},
            {"3Dçº¹ç†", true, "è·ç¦»å˜åŒ–å¤§ï¼Œéœ€è¦Mipmapå‡å°‘èµ°æ ·"},
            {"å¤©ç©ºç›’", false, "æ€»æ˜¯è¿œè·ç¦»æ¸²æŸ“ï¼Œä½¿ç”¨å›ºå®šåˆ†è¾¨ç‡"},
            {"åœ°å½¢çº¹ç†", true, "è§†è·å˜åŒ–æå¤§ï¼ŒMipmapå¿…éœ€"}
        };
        
        ApplyMipmapSettings(settings);
    }
    
    // ğŸ”§ çº¹ç†æµé€
    class TextureStreaming {
        struct StreamingTexture {
            GLuint textureId;
            int currentMipLevel;
            int targetMipLevel;
            float importance;
            bool isLoading;
        };
        
        std::vector<StreamingTexture> streamingTextures;
        size_t memoryBudget = 512 * 1024 * 1024; // 512MB
        
    public:
        void UpdateStreaming() {
            // è®¡ç®—æ¯ä¸ªçº¹ç†çš„é‡è¦æ€§
            for (auto& texture : streamingTextures) {
                texture.importance = CalculateImportance(texture);
                texture.targetMipLevel = CalculateTargetMipLevel(texture.importance);
            }
            
            // æŒ‰é‡è¦æ€§æ’åº
            std::sort(streamingTextures.begin(), streamingTextures.end(),
                     [](const auto& a, const auto& b) { return a.importance > b.importance; });
            
            // åœ¨é¢„ç®—å†…åŠ è½½æœ€é‡è¦çš„çº¹ç†
            LoadTexturesWithinBudget();
        }
        
    private:
        float CalculateImportance(const StreamingTexture& texture) {
            // åŸºäºè·ç¦»ã€å±å¹•å ç”¨ã€å¯è§æ€§ç­‰å› ç´ 
            float distance = GetDistanceToCamera(texture);
            float screenSize = GetScreenSpaceSize(texture);
            bool isVisible = IsVisible(texture);
            
            return isVisible ? (screenSize / distance) : 0.0f;
        }
    };
};
```

### 3. **ç€è‰²å™¨ä¼˜åŒ–**

#### **ç€è‰²å™¨æ€§èƒ½è°ƒä¼˜**
```glsl
// GPUç€è‰²å™¨ä¼˜åŒ–ç¤ºä¾‹
// âŒ ä½æ•ˆçš„ç‰‡æ®µç€è‰²å™¨
shader InEfficientFragmentShader {
    uniform sampler2D mainTexture;
    uniform sampler2D normalMap;
    uniform sampler2D specularMap;
    uniform float time;
    
    varying vec2 uv;
    varying vec3 worldPos;
    varying vec3 normal;
    
    void main() {
        // ğŸ”´ é—®é¢˜1ï¼šå¤æ‚çš„æ•°å­¦è¿ç®—
        vec3 animatedUV = vec3(uv, 0.0);
        for (int i = 0; i < 10; i++) {  // é¿å…å¾ªç¯
            animatedUV.xy += sin(time * float(i)) * 0.01;
        }
        
        // ğŸ”´ é—®é¢˜2ï¼šå¤šæ¬¡çº¹ç†é‡‡æ ·
        vec4 albedo = texture2D(mainTexture, animatedUV.xy);
        vec3 normal = texture2D(normalMap, animatedUV.xy).rgb;
        float specular = texture2D(specularMap, animatedUV.xy).r;
        
        // ğŸ”´ é—®é¢˜3ï¼šåˆ†æ”¯è¯­å¥
        if (worldPos.y > 0.0) {
            albedo.rgb *= 2.0;  // GPUåˆ†æ”¯æ•ˆç‡ä½
        } else {
            albedo.rgb *= 0.5;
        }
        
        gl_FragColor = albedo;
    }
}

// âœ… ä¼˜åŒ–åçš„ç‰‡æ®µç€è‰²å™¨
shader OptimizedFragmentShader {
    uniform sampler2D combinedTexture;  // åˆå¹¶çº¹ç†é€šé“
    uniform vec2 timeFactors;           // é¢„è®¡ç®—çš„æ—¶é—´å› å­
    
    varying vec2 uv;
    varying vec3 worldPos;
    varying float heightFactor;         // é¡¶ç‚¹ç€è‰²å™¨é¢„è®¡ç®—
    
    void main() {
        // âœ… ä¼˜åŒ–1ï¼šç®€åŒ–UVåŠ¨ç”»
        vec2 animatedUV = uv + timeFactors;
        
        // âœ… ä¼˜åŒ–2ï¼šå•æ¬¡çº¹ç†é‡‡æ ·è·å–å¤šé€šé“
        vec4 combined = texture2D(combinedTexture, animatedUV);
        vec3 albedo = combined.rgb;     // R,G,B: æ¼«åå°„
        float specular = combined.a;    // A: é•œé¢åå°„
        
        // âœ… ä¼˜åŒ–3ï¼šé¿å…åˆ†æ”¯ï¼Œä½¿ç”¨lerp
        float heightMultiplier = mix(0.5, 2.0, heightFactor);
        albedo *= heightMultiplier;
        
        gl_FragColor = vec4(albedo, 1.0);
    }
}
```

#### **Uber Shaderç³»ç»Ÿ**
```cpp
// ç»Ÿä¸€ç€è‰²å™¨ç³»ç»Ÿ
class UberShaderSystem {
    // ğŸ¯ å•ä¸ªç€è‰²å™¨å¤„ç†å¤šç§æè´¨
    struct ShaderVariant {
        std::string defines;
        GLuint programId;
        bool isCompiled;
    };
    
    std::unordered_map<std::string, ShaderVariant> variants;
    
public:
    GLuint GetShader(const MaterialFeatures& features) {
        // æ ¹æ®ç‰¹æ€§ç”Ÿæˆå®å®šä¹‰
        std::string defines = GenerateDefines(features);
        
        auto it = variants.find(defines);
        if (it != variants.end()) {
            return it->second.programId;  // è¿”å›ç¼“å­˜çš„å˜ä½“
        }
        
        // ç¼–è¯‘æ–°çš„ç€è‰²å™¨å˜ä½“
        return CompileShaderVariant(defines);
    }
    
private:
    std::string GenerateDefines(const MaterialFeatures& features) {
        std::string defines;
        
        if (features.hasNormalMap) defines += "#define USE_NORMAL_MAP\n";
        if (features.hasSpecularMap) defines += "#define USE_SPECULAR_MAP\n";
        if (features.hasAnimation) defines += "#define USE_ANIMATION\n";
        if (features.receiveShadows) defines += "#define RECEIVE_SHADOWS\n";
        
        return defines;
    }
    
    // ğŸ“Š ç€è‰²å™¨å˜ä½“ç»Ÿè®¡
    void LogVariantStats() {
        std::cout << "ç€è‰²å™¨å˜ä½“æ•°é‡: " << variants.size() << "\n";
        std::cout << "å†…å­˜ä½¿ç”¨: " << CalculateShaderMemory() << " MB\n";
        
        // ä¼˜åŒ–å»ºè®®ï¼šå˜ä½“æ•°é‡è¿‡å¤šæ—¶è€ƒè™‘åˆå¹¶ç‰¹æ€§
        if (variants.size() > 100) {
            std::cout << "è­¦å‘Šï¼šç€è‰²å™¨å˜ä½“è¿‡å¤šï¼Œè€ƒè™‘ä¼˜åŒ–\n";
        }
    }
};
```

### 4. **å‡ ä½•å’Œæ¸²æŸ“ç®¡çº¿ä¼˜åŒ–**

#### **LODç³»ç»Ÿå’Œå‰”é™¤**
```cpp
// å‡ ä½•ç»†èŠ‚å±‚æ¬¡ç®¡ç†
class LODSystem {
    struct LODLevel {
        Mesh mesh;
        float distance;
        int triangleCount;
        float screenThreshold;
    };
    
    struct LODObject {
        std::vector<LODLevel> levels;
        Vector3 position;
        float boundingRadius;
    };
    
    std::vector<LODObject> lodObjects;
    
public:
    // ğŸ¯ åŠ¨æ€LODé€‰æ‹©
    void UpdateLOD(const Camera& camera) {
        for (auto& obj : lodObjects) {
            float distance = Distance(camera.position, obj.position);
            float screenSize = obj.boundingRadius / distance;
            
            // é€‰æ‹©åˆé€‚çš„LODçº§åˆ«
            int lodLevel = SelectLODLevel(obj, screenSize);
            
            // è®¾ç½®æ¸²æŸ“LOD
            SetObjectLOD(obj, lodLevel);
        }
    }
    
    // ğŸ” è§†é”¥å‰”é™¤
    std::vector<RenderObject> FrustumCulling(const Camera& camera) {
        std::vector<RenderObject> visibleObjects;
        Frustum frustum = camera.GetFrustum();
        
        for (const auto& obj : renderObjects) {
            if (frustum.Contains(obj.boundingBox)) {
                visibleObjects.push_back(obj);
            }
        }
        
        return visibleObjects;
    }
    
    // ğŸŒ«ï¸ é®æŒ¡å‰”é™¤ï¼ˆé«˜çº§ï¼‰
    std::vector<RenderObject> OcclusionCulling(const std::vector<RenderObject>& visible) {
        std::vector<RenderObject> unoccluded;
        
        // ä½¿ç”¨GPUæŸ¥è¯¢æˆ–å±‚æ¬¡åŒ–Z-Buffer
        for (const auto& obj : visible) {
            if (!IsOccluded(obj)) {
                unoccluded.push_back(obj);
            }
        }
        
        return unoccluded;
    }
    
    // ğŸ“Š å‰”é™¤ç»Ÿè®¡
    struct CullingStats {
        int totalObjects = 10000;
        int afterFrustum = 3000;      // 70%è¢«è§†é”¥å‰”é™¤
        int afterOcclusion = 800;     // 73%è¢«é®æŒ¡å‰”é™¤
        int finalRender = 800;        // æœ€ç»ˆæ¸²æŸ“8%çš„å¯¹è±¡
    };
};
```

### 5. **ç°ä»£GPUç‰¹æ€§åˆ©ç”¨**

#### **è®¡ç®—ç€è‰²å™¨å¹¶è¡Œè®¡ç®—**
```cpp
// åˆ©ç”¨GPUå¹¶è¡Œè®¡ç®—èƒ½åŠ›
class ComputeShaderOptimizer {
    // ğŸ§® ç²’å­ç³»ç»ŸGPUè®¡ç®—
    void UpdateParticlesOnGPU() {
        const char* computeShader = R"(
            #version 430
            layout(local_size_x = 64) in;
            
            layout(std430, binding = 0) buffer ParticleBuffer {
                struct Particle {
                    vec3 position;
                    vec3 velocity;
                    float life;
                    float size;
                } particles[];
            };
            
            uniform float deltaTime;
            uniform vec3 gravity;
            
            void main() {
                uint index = gl_GlobalInvocationID.x;
                if (index >= particles.length()) return;
                
                // å¹¶è¡Œæ›´æ–°æ¯ä¸ªç²’å­
                particles[index].velocity += gravity * deltaTime;
                particles[index].position += particles[index].velocity * deltaTime;
                particles[index].life -= deltaTime;
                
                // é‡ç”Ÿç²’å­
                if (particles[index].life <= 0.0) {
                    particles[index] = SpawnNewParticle();
                }
            }
        )";
        
        // ğŸš€ ä¸€æ¬¡å¤„ç†100,000ä¸ªç²’å­
        glDispatchCompute(100000 / 64, 1, 1);
    }
    
    // ğŸ¯ GPUé©±åŠ¨æ¸²æŸ“
    void GPUDrivenRendering() {
        // GPUä¸Šæ‰§è¡Œå‰”é™¤å’ŒLODé€‰æ‹©
        DispatchCullingCompute();
        
        // GPUç”Ÿæˆç»˜åˆ¶å‘½ä»¤
        DispatchDrawCommandGeneration();
        
        // é—´æ¥ç»˜åˆ¶
        glMultiDrawElementsIndirect(GL_TRIANGLES, GL_UNSIGNED_INT, 
                                   indirectBuffer, drawCount, 0);
    }
    
    // ğŸ“Š æ€§èƒ½å¯¹æ¯”
    void BenchmarkCompute() {
        // CPUæ›´æ–°100Kç²’å­ï¼š15ms
        // GPUè®¡ç®—ç€è‰²å™¨ï¼š2ms
        // æ€§èƒ½æå‡ï¼š7.5å€
    }
};
```

## å¹³å°ç‰¹åŒ–ä¼˜åŒ– ğŸ“±ğŸ’»

### ç§»åŠ¨ç«¯GPUä¼˜åŒ–
```cpp
// ç§»åŠ¨ç«¯ç‰¹æ®Šä¼˜åŒ–
class MobileGPUOptimizer {
    void OptimizeForMobile() {
        // ğŸ”¥ Tile-basedæ¸²æŸ“ä¼˜åŒ–ï¼ˆPowerVR, Adrenoï¼‰
        EnableTiledRendering();
        
        // ğŸŒ¡ï¸ çƒ­æ§åˆ¶
        ImplementThermalThrottling();
        
        // âš¡ åŠŸè€—ä¼˜åŒ–
        ReducePowerConsumption();
    }
    
private:
    void EnableTiledRendering() {
        // é¿å…framebufferè¯»å–
        glHint(GL_GENERATE_MIPMAP_HINT, GL_FASTEST);
        
        // ä½¿ç”¨discardé¿å…ä¸å¿…è¦çš„å­˜å‚¨
        if (!needDepthBuffer) {
            glDiscardFramebufferEXT(GL_FRAMEBUFFER, 1, attachments);
        }
    }
    
    void ImplementThermalThrottling() {
        float temperature = GetDeviceTemperature();
        
        if (temperature > 60.0f) {
            // é™ä½æ¸²æŸ“è´¨é‡
            ReduceRenderQuality(0.75f);
            SetTargetFrameRate(30);
        } else if (temperature > 40.0f) {
            ReduceRenderQuality(0.9f);
        }
    }
};
```

## æ€§èƒ½ç›‘æ§å’Œåˆ†æ ğŸ“Š

### å®æ—¶æ€§èƒ½ç›‘æ§
```cpp
// æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
class PerformanceMonitor {
    struct FrameStats {
        float cpuTime;
        float gpuTime;
        int drawCalls;
        int triangles;
        size_t memoryUsage;
    };
    
    std::array<FrameStats, 120> frameHistory; // 2ç§’å†å²
    
public:
    void RecordFrame() {
        FrameStats current = {
            .cpuTime = GetCPUTime(),
            .gpuTime = GetGPUTime(),
            .drawCalls = GetDrawCallCount(),
            .triangles = GetTriangleCount(),
            .memoryUsage = GetMemoryUsage()
        };
        
        frameHistory[currentFrame % 120] = current;
        
        // å®æ—¶åˆ†æ
        AnalyzePerformance(current);
    }
    
private:
    void AnalyzePerformance(const FrameStats& stats) {
        // ğŸš¨ æ€§èƒ½è­¦å‘Š
        if (stats.cpuTime > 16.67f) {
            TriggerCPUOptimization();
        }
        
        if (stats.drawCalls > 500) {
            TriggerBatchingOptimization();
        }
        
        if (stats.memoryUsage > 512 * 1024 * 1024) {
            TriggerMemoryCleanup();
        }
    }
};
```

## æ€»ç»“ï¼šä¼˜åŒ–ç­–ç•¥å¯¹æ¯” ğŸ¯

### CPU vs GPUä¼˜åŒ–é‡ç‚¹

| æ–¹é¢ | CPUä¼˜åŒ– | GPUä¼˜åŒ– |
|------|---------|---------|
| **ä¸»è¦ç“¶é¢ˆ** | ç®—æ³•å¤æ‚åº¦ã€ç¼“å­˜æœªå‘½ä¸­ | Draw Callã€çº¹ç†å¸¦å®½ |
| **ä¼˜åŒ–é‡ç‚¹** | æ•°æ®ç»“æ„ã€å¹¶è¡Œè®¡ç®— | æ‰¹å¤„ç†ã€ç€è‰²å™¨æ•ˆç‡ |
| **å·¥å…·** | CPU Profilerã€ç®—æ³•åˆ†æ | RenderDocã€GPUè°ƒè¯•å™¨ |
| **æ•ˆæœ** | å‡å°‘è®¡ç®—æ—¶é—´ | æé«˜æ¸²æŸ“ååé‡ |

### ğŸ’¡ **å…³é”®ä¼˜åŒ–åŸåˆ™ï¼š**

**CPUä¼˜åŒ–ï¼š**
- å‡å°‘ç®—æ³•å¤æ‚åº¦
- æé«˜ç¼“å­˜å‘½ä¸­ç‡
- åˆç†ä½¿ç”¨å¤šçº¿ç¨‹
- é¿å…ä¸å¿…è¦çš„è®¡ç®—

**GPUä¼˜åŒ–ï¼š**
- å‡å°‘Draw Callæ•°é‡
- ä¼˜åŒ–çº¹ç†ä½¿ç”¨
- ç®€åŒ–ç€è‰²å™¨è®¡ç®—
- å……åˆ†åˆ©ç”¨å¹¶è¡Œæ€§

é€šè¿‡CPUå’ŒGPUçš„ååŒä¼˜åŒ–ï¼Œé€šå¸¸å¯ä»¥è·å¾—**5-10å€çš„æ•´ä½“æ€§èƒ½æå‡**ï¼

Search files...
# ç§»åŠ¨ç«¯æ¸¸æˆæ€§èƒ½ä¼˜åŒ–é‡ç‚¹æŒ‡å— ğŸ“±âš¡

ç§»åŠ¨ç«¯æ¸¸æˆä¼˜åŒ–ä¸PCç«¯æœ‰ç€æ˜¾è‘—å·®å¼‚ï¼Œéœ€è¦é‡ç‚¹å…³æ³¨**åŠŸè€—ã€å‘çƒ­ã€å†…å­˜é™åˆ¶ã€GPUæ¶æ„å·®å¼‚**ç­‰ç§»åŠ¨è®¾å¤‡ç‰¹æœ‰çš„çº¦æŸã€‚

## 1. æ ¸å¿ƒä¼˜åŒ–é‡ç‚¹æ’åº ğŸ¯

### ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šå†…å­˜ç®¡ç†ï¼ˆç”Ÿæ­»æ”¸å…³ï¼‰ğŸ’¾

ç§»åŠ¨è®¾å¤‡å†…å­˜é™åˆ¶ä¸¥æ ¼ï¼Œå†…å­˜ä¸è¶³ç›´æ¥å¯¼è‡´åº”ç”¨è¢«ç³»ç»Ÿæ€æ­»ã€‚

```typescript
// ç§»åŠ¨ç«¯å†…å­˜ç®¡ç†ç­–ç•¥
class MobileMemoryManager {
    private memoryBudget = {
        // ğŸ“± ä¸åŒè®¾å¤‡çš„å†…å­˜é¢„ç®—
        lowEnd: 200 * 1024 * 1024,    // 200MBï¼ˆ2GB RAMè®¾å¤‡ï¼‰
        midRange: 400 * 1024 * 1024,  // 400MBï¼ˆ4GB RAMè®¾å¤‡ï¼‰
        highEnd: 800 * 1024 * 1024    // 800MBï¼ˆ8GB+ RAMè®¾å¤‡ï¼‰
    };
    
    // ğŸ¯ è®¾å¤‡åˆ†çº§å’Œå†…å­˜åˆ†é…
    detectDeviceAndSetBudget() {
        const totalRAM = this.getTotalDeviceRAM();
        const gpuMemory = this.getGPUMemoryInfo();
        
        if (totalRAM <= 2048) {
            // ä½ç«¯è®¾å¤‡ï¼šæé™ä¼˜åŒ–
            this.setMemoryBudget(this.memoryBudget.lowEnd);
            this.enableAggressiveOptimization();
        } else if (totalRAM <= 4096) {
            // ä¸­ç«¯è®¾å¤‡ï¼šå¹³è¡¡ä¼˜åŒ–
            this.setMemoryBudget(this.memoryBudget.midRange);
            this.enableBalancedOptimization();
        } else {
            // é«˜ç«¯è®¾å¤‡ï¼šè´¨é‡ä¼˜å…ˆ
            this.setMemoryBudget(this.memoryBudget.highEnd);
            this.enableQualityOptimization();
        }
    }
    
    // ğŸš¨ å†…å­˜ç›‘æ§å’Œé¢„è­¦
    private memoryMonitor() {
        const currentUsage = this.getCurrentMemoryUsage();
        const budget = this.currentMemoryBudget;
        
        if (currentUsage > budget * 0.9) {
            // å†…å­˜ä½¿ç”¨è¶…è¿‡90%ï¼Œç´§æ€¥é‡Šæ”¾
            this.emergencyMemoryCleanup();
        } else if (currentUsage > budget * 0.75) {
            // å†…å­˜ä½¿ç”¨è¶…è¿‡75%ï¼Œä¸»åŠ¨æ¸…ç†
            this.proactiveMemoryCleanup();
        }
    }
    
    private emergencyMemoryCleanup() {
        // ğŸ—‘ï¸ ç´§æ€¥å†…å­˜æ¸…ç†ç­–ç•¥
        this.unloadDistantSceneAssets();      // å¸è½½è¿œè·ç¦»åœºæ™¯èµ„æº
        this.clearAudioCache();               // æ¸…ç©ºéŸ³é¢‘ç¼“å­˜
        this.reduceTextureQuality(0.5);       // é™ä½çº¹ç†è´¨é‡åˆ°50%
        this.forceGarbageCollection();        // å¼ºåˆ¶åƒåœ¾å›æ”¶
        this.clearParticlePoolCache();        // æ¸…ç©ºç²’å­æ± ç¼“å­˜
    }
}
```

### ç¬¬äºŒä¼˜å…ˆçº§ï¼šå‘çƒ­æ§åˆ¶ï¼ˆç”¨æˆ·ä½“éªŒï¼‰ğŸŒ¡ï¸

ç§»åŠ¨è®¾å¤‡å‘çƒ­ç›´æ¥å½±å“ç”¨æˆ·ä½“éªŒï¼Œéœ€è¦åŠ¨æ€è°ƒæ•´æ€§èƒ½ã€‚

```cpp
// çƒ­æ§åˆ¶ç³»ç»Ÿ
class ThermalManager {
    enum class ThermalState {
        Normal,     // < 40Â°C
        Warm,       // 40-50Â°C
        Hot,        // 50-60Â°C
        Critical    // > 60Â°C
    };
    
    struct ThermalConfig {
        int targetFrameRate;
        float renderScale;
        float effectQuality;
        bool enablePostProcessing;
        int maxLights;
    };
    
    std::map<ThermalState, ThermalConfig> thermalConfigs = {
        {ThermalState::Normal, {60, 1.0f, 1.0f, true, 8}},
        {ThermalState::Warm, {45, 0.9f, 0.8f, true, 6}},
        {ThermalState::Hot, {30, 0.75f, 0.6f, false, 4}},
        {ThermalState::Critical, {20, 0.5f, 0.3f, false, 2}}
    };
    
public:
    void UpdateThermalState() {
        float temperature = GetCPUTemperature();
        ThermalState newState = ClassifyThermalState(temperature);
        
        if (newState != currentState) {
            ApplyThermalConfiguration(newState);
            LogThermalEvent(currentState, newState, temperature);
        }
        
        currentState = newState;
    }
    
private:
    void ApplyThermalConfiguration(ThermalState state) {
        auto config = thermalConfigs[state];
        
        // ğŸ¯ åŠ¨æ€è°ƒæ•´æ¸²æŸ“å‚æ•°
        SetTargetFrameRate(config.targetFrameRate);
        SetRenderScale(config.renderScale);
        SetEffectQuality(config.effectQuality);
        EnablePostProcessing(config.enablePostProcessing);
        SetMaxLightCount(config.maxLights);
        
        // ğŸ“Š é€šçŸ¥ç”¨æˆ·ï¼ˆå¯é€‰ï¼‰
        if (state >= ThermalState::Hot) {
            ShowPerformanceModeNotification("è®¾å¤‡æ¸©åº¦è¾ƒé«˜ï¼Œå·²é™ä½ç”»è´¨ä¿æŠ¤è®¾å¤‡");
        }
    }
    
    // ğŸŒ¡ï¸ iOSç³»ç»Ÿçƒ­æ§åˆ¶é›†æˆ
    void SetupIOSThermalMonitoring() {
        // ç›‘å¬ç³»ç»Ÿçƒ­çŠ¶æ€å˜åŒ–
        [[NSNotificationCenter defaultCenter] 
         addObserverForName:NSProcessInfoThermalStateDidChangeNotification
                     object:nil
                      queue:[NSOperationQueue mainQueue]
                 usingBlock:^(NSNotification *note) {
                     NSProcessInfoThermalState state = [[NSProcessInfo processInfo] thermalState];
                     HandleSystemThermalChange(state);
                 }];
    }
};
```

### ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šç”µé‡ä¼˜åŒ–ï¼ˆç»­èˆªæ—¶é—´ï¼‰ğŸ”‹

ç§»åŠ¨æ¸¸æˆéœ€è¦å¹³è¡¡æ€§èƒ½å’Œç”µé‡æ¶ˆè€—ã€‚

```typescript
// ç”µé‡ç®¡ç†ç³»ç»Ÿ
class PowerManager {
    private powerProfiles = {
        // âš¡ ä¸åŒç”µé‡æ¨¡å¼çš„é…ç½®
        powerSaving: {
            frameRate: 30,
            renderScale: 0.7,
            enableDynamicBatching: true,
            reduceParticles: 0.3,
            disableAdvancedShaders: true
        },
        balanced: {
            frameRate: 45,
            renderScale: 0.85,
            enableDynamicBatching: true,
            reduceParticles: 0.7,
            disableAdvancedShaders: false
        },
        performance: {
            frameRate: 60,
            renderScale: 1.0,
            enableDynamicBatching: false,
            reduceParticles: 1.0,
            disableAdvancedShaders: false
        }
    };
    
    // ğŸ”‹ æ ¹æ®ç”µé‡è‡ªåŠ¨è°ƒæ•´
    autoAdjustPowerMode() {
        const batteryLevel = this.getBatteryLevel();
        const isCharging = this.isDeviceCharging();
        
        if (isCharging) {
            // å……ç”µæ—¶ä½¿ç”¨æ€§èƒ½æ¨¡å¼
            this.setPowerMode('performance');
        } else if (batteryLevel < 0.2) {
            // ä½ç”µé‡æ—¶å¼ºåˆ¶çœç”µæ¨¡å¼
            this.setPowerMode('powerSaving');
        } else if (batteryLevel < 0.5) {
            // ä¸­ç­‰ç”µé‡æ—¶ä½¿ç”¨å¹³è¡¡æ¨¡å¼
            this.setPowerMode('balanced');
        } else {
            // ç”µé‡å……è¶³æ—¶ä½¿ç”¨æ€§èƒ½æ¨¡å¼
            this.setPowerMode('performance');
        }
    }
    
    // âš¡ GPUåŠŸè€—ä¼˜åŒ–
    private optimizeGPUPower() {
        // 1. é™ä½GPUé¢‘ç‡
        this.setGPUClockSpeed('medium');
        
        // 2. å‡å°‘è¿‡åº¦ç»˜åˆ¶
        this.enableOcclusionCulling();
        
        // 3. ç®€åŒ–ç€è‰²å™¨
        this.useSimplifiedShaders();
        
        // 4. é™ä½åˆ†è¾¨ç‡
        this.setDynamicResolution(0.8);
    }
}
```

## 2. ç§»åŠ¨ç«¯GPUæ¶æ„ç‰¹åŒ–ä¼˜åŒ– ğŸ®

### Tile-Based æ¸²æŸ“ä¼˜åŒ–ï¼ˆARM Mali, PowerVRï¼‰

```cpp
// é’ˆå¯¹ç§»åŠ¨GPUçš„ç‰¹æ®Šä¼˜åŒ–
class MobileGPUOptimizer {
    // ğŸ—ï¸ Tile-Basedæ¸²æŸ“ä¼˜åŒ–
    void OptimizeForTiledGPU() {
        // 1. é¿å…ä¸å¿…è¦çš„framebufferè¯»å–
        DisableFramebufferReads();
        
        // 2. ä½¿ç”¨discardä¼˜åŒ–
        UseDiscardForUnusedAttachments();
        
        // 3. å‡å°‘rendertargetåˆ‡æ¢
        MinimizeRenderTargetSwitches();
        
        // 4. ä¼˜åŒ–æ·±åº¦æµ‹è¯•
        OptimizeDepthTesting();
    }
    
private:
    void DisableFramebufferReads() {
        // âŒ é¿å…ï¼šè¯»å–framebufferä¼šç ´åtile-basedä¼˜åŒ–
        // glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
        
        // âœ… æ¨èï¼šä½¿ç”¨shaderé—´æ¥è·å–ç»“æœ
        UseShaderBasedDataExtraction();
    }
    
    void UseDiscardForUnusedAttachments() {
        // OpenGL ESä¼˜åŒ–
        GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};
        
        // æ˜¾å¼ä¸¢å¼ƒä¸éœ€è¦çš„attachmentï¼ŒèŠ‚çœå¸¦å®½
        glDiscardFramebufferEXT(GL_FRAMEBUFFER, 2, attachments);
    }
    
    // ğŸ“Š ç§»åŠ¨GPUæ€§èƒ½ç‰¹ç‚¹
    void AnalyzeMobileGPUCharacteristics() {
        struct MobileGPUProfile {
            std::string architecture;
            int computeUnits;
            int memoryBandwidth;    // GB/s
            std::stringä¼˜åŒ–é‡ç‚¹;
        };
        
        std::vector<MobileGPUProfile> profiles = {
            {"ARM Mali-G78", 20, 25, "å¸¦å®½ä¼˜åŒ–ï¼Œé¿å…å¤æ‚fragment shader"},
            {"Qualcomm Adreno 660", 512, 44, "ALUä¼˜åŒ–ï¼Œå……åˆ†åˆ©ç”¨è®¡ç®—èƒ½åŠ›"},
            {"Apple A15 GPU", 16, 68, "å¹³è¡¡ä¼˜åŒ–ï¼ŒMetalæ€§èƒ½è°ƒä¼˜"},
            {"PowerVR Series", 128, 20, "Tile-basedä¼˜åŒ–ï¼Œå‡å°‘overdraw"}
        };
    }
};
```

### ç§»åŠ¨ç«¯ç€è‰²å™¨ä¼˜åŒ–

```glsl
// ç§»åŠ¨ç«¯å‹å¥½çš„ç€è‰²å™¨è®¾è®¡
// âŒ æ¡Œé¢ç«¯å¤æ‚ç€è‰²å™¨
shader ComplexDesktopShader {
    // é«˜ç²¾åº¦è®¡ç®—
    precision highp float;
    
    uniform sampler2D diffuseMap;
    uniform sampler2D normalMap;
    uniform sampler2D specularMap;
    uniform sampler2D roughnessMap;
    uniform sampler2D aoMap;
    
    void main() {
        // å¤šæ¬¡çº¹ç†é‡‡æ ·
        vec4 diffuse = texture2D(diffuseMap, uv);
        vec3 normal = texture2D(normalMap, uv).rgb;
        float specular = texture2D(specularMap, uv).r;
        float roughness = texture2D(roughnessMap, uv).r;
        float ao = texture2D(aoMap, uv).r;
        
        // å¤æ‚å…‰ç…§è®¡ç®—
        vec3 lighting = CalculatePBRLighting(diffuse, normal, specular, roughness, ao);
        
        gl_FragColor = vec4(lighting, 1.0);
    }
}

// âœ… ç§»åŠ¨ç«¯ä¼˜åŒ–ç€è‰²å™¨
shader OptimizedMobileShader {
    // ä¸­ç­‰ç²¾åº¦è¶³å¤Ÿ
    precision mediump float;
    
    // åˆå¹¶çº¹ç†é€šé“
    uniform sampler2D packedTexture; // R:diffuse, G:specular, B:roughness, A:ao
    
    void main() {
        // å•æ¬¡çº¹ç†é‡‡æ ·
        vec4 packed = texture2D(packedTexture, uv);
        
        // ç®€åŒ–å…‰ç…§æ¨¡å‹
        vec3 lighting = CalculateSimplifiedLighting(packed);
        
        gl_FragColor = vec4(lighting, 1.0);
    }
    
    // ç®€åŒ–çš„å…‰ç…§è®¡ç®—
    vec3 CalculateSimplifiedLighting(vec4 packed) {
        vec3 diffuse = packed.rgb;
        float specular = packed.a;
        
        // ä½¿ç”¨é¢„è®¡ç®—çš„å…‰ç…§æŸ¥æ‰¾è¡¨
        float ndotl = max(0.0, dot(normal, lightDir));
        vec3 lighting = diffuse * ndotl + specular * pow(ndotl, 8.0);
        
        return lighting;
    }
}
```

## 3. ç§»åŠ¨ç«¯ç‰¹æœ‰ä¼˜åŒ–ç­–ç•¥ ğŸ“±

### ç½‘ç»œä¼˜åŒ–ï¼ˆç§»åŠ¨ç½‘ç»œç‰¹ç‚¹ï¼‰

```typescript
// ç§»åŠ¨ç½‘ç»œä¼˜åŒ–
class MobileNetworkOptimizer {
    // ğŸ“¶ ç½‘ç»œçŠ¶æ€é€‚é…
    adaptToNetworkCondition() {
        const networkType = this.getNetworkType();
        const signalStrength = this.getSignalStrength();
        
        switch (networkType) {
            case 'wifi':
                this.setNetworkProfile('high_bandwidth');
                break;
            case '4g':
                this.setNetworkProfile('medium_bandwidth');
                break;
            case '3g':
                this.setNetworkProfile('low_bandwidth');
                break;
            case '2g':
                this.setNetworkProfile('minimal_bandwidth');
                break;
        }
        
        // æ ¹æ®ä¿¡å·å¼ºåº¦è°ƒæ•´
        if (signalStrength < 0.3) {
            this.enableAggressiveCompression();
            this.reduceUpdateFrequency();
        }
    }
    
    // ğŸ“Š ç§»åŠ¨ç«¯æ•°æ®å‹ç¼©
    private enableMobileCompression() {
        const compressionStrategies = {
            // 1. å¢é‡æ›´æ–°
            deltaCompression: {
                approach: "åªå‘é€å˜åŒ–çš„æ•°æ®",
                saving: "70-90%å¸¦å®½èŠ‚çœ"
            },
            
            // 2. äºŒè¿›åˆ¶åè®®
            binaryProtocol: {
                approach: "ä½¿ç”¨ProtoBufæ›¿ä»£JSON",
                saving: "60-80%å¤§å°å‡å°‘"
            },
            
            // 3. æ‰¹é‡ä¼ è¾“
            batching: {
                approach: "åˆå¹¶å¤šä¸ªå°è¯·æ±‚",
                saving: "å‡å°‘ç½‘ç»œå¾€è¿”æ¬¡æ•°"
            }
        };
        
        return compressionStrategies;
    }
}
```

### è§¦æ§è¾“å…¥ä¼˜åŒ–

```cpp
// ç§»åŠ¨ç«¯è¾“å…¥ç³»ç»Ÿä¼˜åŒ–
class MobileTouchOptimizer {
    // ğŸ–±ï¸ é«˜ç²¾åº¦è§¦æ§å¤„ç†
    void OptimizeTouchInput() {
        // 1. å‡å°‘è¾“å…¥å»¶è¿Ÿ
        SetTouchSampleRate(120); // 120Hzè§¦æ§é‡‡æ ·
        
        // 2. é¢„æµ‹æ€§è¾“å…¥
        EnableTouchPrediction();
        
        // 3. å¤šç‚¹è§¦æ§ä¼˜åŒ–
        OptimizeMultiTouch();
    }
    
    // ğŸ® æ‰‹åŠ¿è¯†åˆ«ä¼˜åŒ–
    void OptimizeGestureRecognition() {
        // ä½¿ç”¨è½»é‡çº§æ‰‹åŠ¿è¯†åˆ«ç®—æ³•
        class LightweightGestureRecognizer {
            // å‡å°‘è®¡ç®—å¤æ‚åº¦çš„ç®€åŒ–ç®—æ³•
            GestureType RecognizeGesture(const std::vector<TouchPoint>& points) {
                if (points.size() < 2) return GestureType::None;
                
                // ç®€åŒ–çš„ç›´çº¿è·ç¦»è®¡ç®—
                float distance = Distance(points.front(), points.back());
                float duration = points.back().timestamp - points.front().timestamp;
                
                if (distance > 100 && duration < 0.5f) {
                    return GestureType::Swipe;
                } else if (distance < 10 && duration > 0.5f) {
                    return GestureType::LongPress;
                }
                
                return GestureType::Tap;
            }
        };
    }
};
```

## 4. è®¾å¤‡åˆ†çº§å’Œè‡ªé€‚åº”ç³»ç»Ÿ ğŸ“Š

### è®¾å¤‡æ€§èƒ½æ£€æµ‹å’Œåˆ†çº§

```typescript
// è®¾å¤‡æ€§èƒ½è¯„ä¼°ç³»ç»Ÿ
class DeviceProfiler {
    // ğŸ” è®¾å¤‡æ€§èƒ½æ£€æµ‹
    async profileDevice(): Promise<DeviceProfile> {
        const profile = {
            // ç¡¬ä»¶ä¿¡æ¯
            cpu: await this.benchmarkCPU(),
            gpu: await this.benchmarkGPU(),
            memory: this.getMemoryInfo(),
            storage: this.getStorageInfo(),
            
            // è¿è¡Œæ—¶æ€§èƒ½
            thermalCapacity: await this.testThermalPerformance(),
            batteryEfficiency: await this.testBatteryDrain(),
            
            // è®¾å¤‡åˆ†çº§
            tier: this.calculateDeviceTier()
        };
        
        return profile;
    }
    
    private async benchmarkGPU(): Promise<GPUProfile> {
        // ğŸ® GPUæ€§èƒ½æµ‹è¯•
        const testScene = this.createGPUBenchmarkScene();
        const startTime = performance.now();
        
        // æ¸²æŸ“æ ‡å‡†æµ‹è¯•åœºæ™¯
        for (let i = 0; i < 100; i++) {
            await this.renderFrame(testScene);
        }
        
        const avgFrameTime = (performance.now() - startTime) / 100;
        
        return {
            averageFrameTime: avgFrameTime,
            fillRate: this.calculateFillRate(),
            textureMemoryBandwidth: this.measureTextureBandwidth(),
            tier: this.classifyGPUTier(avgFrameTime)
        };
    }
    
    // ğŸ“± è®¾å¤‡åˆ†çº§æ ‡å‡†
    private calculateDeviceTier(): DeviceTier {
        const score = this.calculatePerformanceScore();
        
        if (score >= 80) return DeviceTier.HighEnd;
        if (score >= 60) return DeviceTier.MidRange;
        if (score >= 40) return DeviceTier.LowMid;
        return DeviceTier.LowEnd;
    }
    
    // ğŸ¯ æ ¹æ®è®¾å¤‡åˆ†çº§åº”ç”¨ä¸åŒé…ç½®
    applyDeviceOptimizations(tier: DeviceTier) {
        const configs = {
            [DeviceTier.HighEnd]: {
                renderScale: 1.0,
                textureQuality: 'ultra',
                effectQuality: 'high',
                targetFPS: 60,
                enablePostProcessing: true
            },
            [DeviceTier.MidRange]: {
                renderScale: 0.9,
                textureQuality: 'high',
                effectQuality: 'medium',
                targetFPS: 45,
                enablePostProcessing: true
            },
            [DeviceTier.LowMid]: {
                renderScale: 0.75,
                textureQuality: 'medium',
                effectQuality: 'low',
                targetFPS: 30,
                enablePostProcessing: false
            },
            [DeviceTier.LowEnd]: {
                renderScale: 0.6,
                textureQuality: 'low',
                effectQuality: 'minimal',
                targetFPS: 24,
                enablePostProcessing: false
            }
        };
        
        this.applyConfiguration(configs[tier]);
    }
}
```

## 5. ç§»åŠ¨ç«¯è°ƒè¯•å’Œç›‘æ§ ğŸ”§

### å®æ—¶æ€§èƒ½ç›‘æ§

```cpp
// ç§»åŠ¨ç«¯æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
class MobilePerformanceMonitor {
    struct MobileMetrics {
        float frameTime;
        float cpuUsage;
        float gpuUsage;
        size_t memoryUsage;
        float temperature;
        float batteryDrain;
        int networkLatency;
        float touchLatency;
    };
    
    void StartMonitoring() {
        // ğŸ”„ è½»é‡çº§ç›‘æ§å¾ªç¯
        monitoringThread = std::thread([this] {
            while (isMonitoring) {
                auto metrics = GatherMobileMetrics();
                AnalyzeMetrics(metrics);
                
                // ç§»åŠ¨ç«¯ç›‘æ§é¢‘ç‡è¾ƒä½ï¼Œé¿å…å½±å“æ€§èƒ½
                std::this_thread::sleep_for(std::chrono::milliseconds(200));
            }
        });
    }
    
    void AnalyzeMetrics(const MobileMetrics& metrics) {
        // ğŸš¨ ç§»åŠ¨ç«¯ç‰¹æœ‰çš„æ€§èƒ½è­¦å‘Š
        
        if (metrics.temperature > 50.0f) {
            TriggerThermalOptimization();
        }
        
        if (metrics.batteryDrain > 15.0f) { // æ¯å°æ—¶è¶…è¿‡15%
            TriggerPowerOptimization();
        }
        
        if (metrics.memoryUsage > GetMemoryBudget() * 0.8f) {
            TriggerMemoryCleanup();
        }
        
        if (metrics.touchLatency > 50.0f) { // è¶…è¿‡50ms
            OptimizeTouchResponseTime();
        }
    }
    
    // ğŸ“Š ç”Ÿæˆç§»åŠ¨ç«¯æ€§èƒ½æŠ¥å‘Š
    void GenerateMobileReport() {
        MobilePerformanceReport report = {
            .deviceInfo = GetDeviceInfo(),
            .thermalHistory = GetThermalHistory(),
            .batteryUsagePattern = GetBatteryUsagePattern(),
            .networkPerformance = GetNetworkPerformance(),
            .userInteractionLatency = GetUILatencyStats(),
            .optimizationRecommendations = GenerateOptimizationAdvice()
        };
        
        SaveReport(report);
    }
};
```

## 6. ç§»åŠ¨ç«¯ä¼˜åŒ–æœ€ä½³å®è·µ ğŸ¯

### ä¼˜åŒ–æ£€æŸ¥æ¸…å•

```typescript
// ç§»åŠ¨ç«¯ä¼˜åŒ–æ£€æŸ¥æ¸…å•
const MobileOptimizationChecklist = {
    // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼ˆå¿…éœ€ï¼‰
    memory: [
        "âœ… çº¹ç†å‹ç¼©ï¼ˆASTC/ETC2ï¼‰",
        "âœ… éŸ³é¢‘å‹ç¼©ï¼ˆOGG/AACï¼‰", 
        "âœ… ç½‘æ ¼ä¼˜åŒ–ï¼ˆå‡å°‘é¡¶ç‚¹æ•°ï¼‰",
        "âœ… å¯¹è±¡æ± ä½¿ç”¨",
        "âœ… åŠæ—¶èµ„æºé‡Šæ”¾",
        "âœ… å†…å­˜é¢„ç®—ç®¡ç†"
    ],
    
    // ğŸŒ¡ï¸ å‘çƒ­æ§åˆ¶ï¼ˆé‡è¦ï¼‰
    thermal: [
        "âœ… CPUä½¿ç”¨ç‡ç›‘æ§",
        "âœ… åŠ¨æ€å¸§ç‡è°ƒæ•´",
        "âœ… æ¸²æŸ“è´¨é‡é™çº§",
        "âœ… åå°å¤„ç†æš‚åœ",
        "âœ… ç³»ç»Ÿçƒ­çŠ¶æ€ç›‘å¬"
    ],
    
    // ğŸ”‹ ç”µé‡ä¼˜åŒ–ï¼ˆé‡è¦ï¼‰
    power: [
        "âœ… GPUé¢‘ç‡æ§åˆ¶",
        "âœ… å±å¹•äº®åº¦é€‚é…",
        "âœ… ç½‘ç»œè¯·æ±‚åˆå¹¶",
        "âœ… ä¼ æ„Ÿå™¨ä½¿ç”¨ä¼˜åŒ–",
        "âœ… åå°ä»»åŠ¡ç®¡ç†"
    ],
    
    // ğŸ® ç”¨æˆ·ä½“éªŒï¼ˆåŸºç¡€ï¼‰
    ux: [
        "âœ… è§¦æ§å»¶è¿Ÿä¼˜åŒ–",
        "âœ… åŠ è½½æ—¶é—´ä¼˜åŒ–",
        "âœ… æµç•…åº¦ä¿è¯",
        "âœ… å´©æºƒç‡æ§åˆ¶",
        "âœ… å…¼å®¹æ€§æµ‹è¯•"
    ]
};
```

## æ€»ç»“ï¼šç§»åŠ¨ç«¯ä¼˜åŒ–æ ¸å¿ƒåŸåˆ™ ğŸ“±

### âœ… **ç§»åŠ¨ç«¯ä¼˜åŒ–ä¸‰å¤§æ”¯æŸ±ï¼š**

1. **å†…å­˜ä¸ºç‹** - å†…å­˜é™åˆ¶æ˜¯ç§»åŠ¨ç«¯çš„ç”Ÿæ­»çº¿
2. **çƒ­æ§ä¼˜å…ˆ** - å‘çƒ­ç›´æ¥å½±å“ç”¨æˆ·ä½“éªŒ
3. **ç”µé‡æ„è¯†** - ç»­èˆªèƒ½åŠ›å†³å®šç”¨æˆ·ç•™å­˜

### ğŸ¯ **ä¼˜åŒ–ä¼˜å…ˆçº§ï¼š**
1. **å†…å­˜ä¼˜åŒ–** â†’ é¿å…OOMå´©æºƒ
2. **å‘çƒ­æ§åˆ¶** â†’ ä¿è¯æŒç»­æ€§èƒ½
3. **ç”µé‡ä¼˜åŒ–** â†’ æå‡ç”¨æˆ·æ»¡æ„åº¦
4. **è§¦æ§ä¼˜åŒ–** â†’ æ”¹å–„äº¤äº’ä½“éªŒ
5. **ç½‘ç»œä¼˜åŒ–** â†’ é€‚é…ç§»åŠ¨ç½‘ç»œ

### ğŸ“Š **æˆåŠŸæŒ‡æ ‡ï¼š**
- å†…å­˜ä½¿ç”¨ < è®¾å¤‡æ€»RAMçš„25%
- å‘çƒ­æ§åˆ¶ < 45Â°Cæ­£å¸¸ä½¿ç”¨
- ç”µé‡æ¶ˆè€— < 10%/å°æ—¶
- è§¦æ§å»¶è¿Ÿ < 50ms
- å¯åŠ¨æ—¶é—´ < 3ç§’

é€šè¿‡ç³»ç»Ÿæ€§çš„ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼Œå¯ä»¥è®©æ¸¸æˆåœ¨å„ç§ç§»åŠ¨è®¾å¤‡ä¸Šéƒ½è·å¾—**æµç•…ã€ç¨³å®šã€çœç”µ**çš„ä½“éªŒï¼