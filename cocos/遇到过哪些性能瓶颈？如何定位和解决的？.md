Search files...
# 游戏开发中常见的性能瓶颈及解决方案 🎯⚡

基于实际项目经验，我来详细分析游戏开发中遇到的各种性能瓶颈及其定位和解决方法。

## 1. Draw Call 瓶颈（最常见） 📊

### 问题现象
```typescript
// 典型问题场景
const performanceIssue = {
    symptoms: {
        frameRate: "从60fps掉到20-30fps",
        profilerData: "Draw Calls > 1000",
        platform: "移动端特别明显"
    },
    cause: "大量小UI元素、粒子效果、相似物体分别渲染"
};
```

### 定位方法
```cpp
// Unity Profiler 数据分析
class DrawCallProfiler {
    void AnalyzePerformance() {
        // 🔍 关键指标监控
        int drawCalls = Graphics.activeDrawCall;
        int batches = Graphics.activeBatches;
        int triangles = Graphics.activeTriangles;
        
        // 📊 瓶颈判断
        if (drawCalls > 500 && batches / drawCalls < 0.3f) {
            LogWarning("合批效率低，大量独立Draw Call");
        }
        
        if (triangles / drawCalls < 50) {
            LogWarning("每个Draw Call三角形数量过少，效率低下");
        }
    }
    
    // 🎯 热点分析
    void FindDrawCallHotspots() {
        // 使用Frame Debugger分析每个Draw Call
        var renderers = FindObjectsOfType<Renderer>();
        
        foreach (var renderer in renderers) {
            if (!renderer.isStaticBatched && !renderer.isDynamicBatched) {
                LogInfo($"无法合批的对象: {renderer.name}");
                AnalyzeBatchingFailure(renderer);
            }
        }
    }
};
```

### 解决方案
```typescript
// Cocos Creator 批处理优化
class DrawCallOptimizer {
    // 🎯 UI元素合批
    optimizeUIBatching() {
        // 1. 图集合并
        this.createTextureAtlas();
        
        // 2. 相同材质排序
        this.sortByMaterial();
        
        // 3. 静态UI预合批
        this.enableStaticBatching();
    }
    
    private createTextureAtlas() {
        // 📁 将小图片合并到大图集
        const atlas = new cc.SpriteAtlas();
        const smallTextures = ['icon1.png', 'icon2.png', 'ui_bg.png'];
        
        // 合并后：1000个小图标 → 10个Draw Call
        atlas.packTextures(smallTextures);
    }
    
    // 📊 性能提升对比
    private getOptimizationResults() {
        return {
            before: { drawCalls: 1200, frameTime: 25.6 },
            after: { drawCalls: 85, frameTime: 8.3 },
            improvement: "帧时间提升67%"
        };
    }
}
```

## 2. GPU过度绘制瓶颈 🎨

### 问题现象
```cpp
// GPU Overdraw 检测
class OverdrawAnalyzer {
    struct OverdrawMetrics {
        float averageOverdraw;      // 平均过度绘制率
        float maxOverdraw;          // 最大过度绘制率
        int affectedPixels;         // 受影响的像素数
    };
    
    OverdrawMetrics analyzeScene() {
        // 🔍 使用深度复杂度分析
        return {
            .averageOverdraw = 3.2f,    // 每个像素平均绘制3.2次
            .maxOverdraw = 8.0f,        // 某些区域绘制8次
            .affectedPixels = 800000    // 80万像素受影响
        };
    }
};
```

### 定位工具
```csharp
// Unity Frame Debugger + RenderDoc 分析
public class OverdrawProfiler {
    void DetectOverdraw() {
        // 📊 开启Overdraw可视化
        Camera.main.SetReplacementShader(overdrawShader, "RenderType");
        
        // 🔍 分析结果
        // 绿色：正常（1-2次绘制）
        // 黄色：轻微过度绘制（3-4次）
        // 红色：严重过度绘制（5次以上）
        
        LogOverdrawHotspots();
    }
    
    void LogOverdrawHotspots() {
        // 🎯 找出过度绘制热点
        var transparentObjects = FindObjectsWithTag("Transparent");
        var uiElements = FindObjectsOfType<CanvasRenderer>();
        
        // 分析透明物体层叠情况
        AnalyzeTransparencyLayers(transparentObjects);
    }
}
```

### 解决方案
```typescript
// 过度绘制优化策略
class OverdrawOptimizer {
    // 🎯 透明物体优化
    optimizeTransparency() {
        // 1. 减少透明层级
        this.reduceTransparencyLayers();
        
        // 2. 使用Alpha Test替代Alpha Blend
        this.useAlphaTest();
        
        // 3. 粒子系统优化
        this.optimizeParticles();
    }
    
    private reduceTransparencyLayers() {
        // ❌ 问题：多层透明UI叠加
        const problemCase = {
            background: "半透明背景",
            panel: "半透明面板", 
            button: "半透明按钮",
            effect: "透明特效",
            overdraw: "4层叠加 = 4倍过度绘制"
        };
        
        // ✅ 解决：合并透明元素
        const solution = {
            approach: "预渲染合成",
            result: "4层 → 1层",
            improvement: "75%过度绘制减少"
        };
    }
    
    private optimizeParticles() {
        // 🎆 粒子系统优化
        const particleOptimization = {
            // 减少粒子数量
            maxParticles: "从1000降到300",
            
            // 使用简单着色器
            shader: "Unlit/Transparent → Custom/SimpleParticle",
            
            // 预合批粒子纹理
            texture: "合并到粒子图集",
            
            // 距离LOD
            culling: "距离过远时禁用粒子"
        };
    }
}
```

## 3. 内存瓶颈 💾

### 问题现象
```cpp
// 内存泄漏检测
class MemoryBottleneckDetector {
    struct MemoryIssue {
        size_t textureMemory;       // 纹理内存占用
        size_t meshMemory;          // 网格内存占用
        size_t audioMemory;         // 音频内存占用
        int gcFrequency;            // GC频率
    };
    
    MemoryIssue detectIssues() {
        return {
            .textureMemory = 800 * 1024 * 1024,  // 800MB纹理内存
            .meshMemory = 200 * 1024 * 1024,     // 200MB网格
            .audioMemory = 150 * 1024 * 1024,    // 150MB音频
            .gcFrequency = 30  // 每秒30次GC，严重影响帧率
        };
    }
};
```

### 定位方法
```csharp
// Unity Memory Profiler 深度分析
public class MemoryProfiler {
    void AnalyzeMemoryUsage() {
        // 🔍 详细内存分析
        var snapshot = MemorySnapshot.Take();
        
        // 📊 纹理内存分析
        AnalyzeTextureMemory(snapshot);
        
        // 🧠 托管内存分析
        AnalyzeManagedMemory(snapshot);
        
        // 📱 原生内存分析
        AnalyzeNativeMemory(snapshot);
    }
    
    void AnalyzeTextureMemory(MemorySnapshot snapshot) {
        var textures = snapshot.nativeObjects.OfType<Texture2D>();
        
        var largeTextures = textures
            .Where(t => t.GetRuntimeMemorySize() > 10 * 1024 * 1024)
            .OrderByDescending(t => t.GetRuntimeMemorySize());
        
        foreach (var texture in largeTextures) {
            Debug.LogWarning($"大纹理: {texture.name} - {texture.GetRuntimeMemorySize() / (1024*1024)}MB");
            
            // 🎯 分析问题
            if (!texture.isReadable && texture.mipmapCount > 1) {
                Debug.Log("建议：关闭Mipmap或降低分辨率");
            }
        }
    }
    
    void AnalyzeManagedMemory(MemorySnapshot snapshot) {
        // 🔍 查找内存泄漏
        var managedObjects = snapshot.managedObjects;
        
        // 检查常见泄漏源
        CheckEventHandlerLeaks(managedObjects);
        CheckCollectionLeaks(managedObjects);
        CheckClosureLeaks(managedObjects);
    }
}
```

### 解决方案
```typescript
// 内存优化综合方案
class MemoryOptimizer {
    // 🎯 纹理内存优化
    optimizeTextureMemory() {
        const strategies = {
            // 1. 压缩格式优化
            compression: {
                mobile: "ASTC 6x6 (50%内存节省)",
                pc: "BC7 (66%内存节省)",
                web: "DXT5 (75%内存节省)"
            },
            
            // 2. 分辨率优化
            resolution: {
                ui: "降低50%分辨率 → 75%内存节省",
                background: "降低25%分辨率 → 44%内存节省",
                effect: "降低75%分辨率 → 94%内存节省"
            },
            
            // 3. 动态加载卸载
            streaming: {
                approach: "按场景分块加载",
                result: "内存占用稳定在512MB以内"
            }
        };
        
        return strategies;
    }
    
    // 🧠 托管内存优化
    optimizeManagedMemory() {
        // 1. 对象池减少GC
        this.implementObjectPool();
        
        // 2. 避免装箱拆箱
        this.avoidBoxing();
        
        // 3. 减少字符串拼接
        this.optimizeStringOperations();
    }
    
    private implementObjectPool() {
        // 🔄 对象池示例
        class BulletPool {
            private pool: cc.Node[] = [];
            
            getBullet(): cc.Node {
                if (this.pool.length > 0) {
                    return this.pool.pop()!; // 重用对象
                }
                return this.createNewBullet(); // 必要时创建
            }
            
            returnBullet(bullet: cc.Node) {
                bullet.active = false;
                this.pool.push(bullet); // 回收到池中
            }
        }
        
        // 📊 效果：GC次数从每秒30次 → 每秒2次
    }
}
```

## 4. CPU计算瓶颈 🧮

### 问题现象
```cpp
// CPU热点分析
class CPUBottleneckAnalyzer {
    struct CPUHotspot {
        std::string functionName;
        float timePercentage;
        int callCount;
        float averageTime;
    };
    
    std::vector<CPUHotspot> analyzeHotspots() {
        return {
            {"Physics.Simulate", 35.2f, 1, 5.8f},      // 物理模拟
            {"UI.Layout", 28.4f, 450, 0.12f},          // UI布局计算
            {"Animation.Update", 15.3f, 200, 0.15f},   // 动画更新
            {"AI.Pathfinding", 12.1f, 50, 0.48f},      // 寻路算法
            {"Scripting.Update", 9.0f, 800, 0.02f}     // 脚本更新
        };
    }
};
```

### 定位工具
```csharp
// Unity Profiler + 自定义性能监控
public class CPUProfiler {
    void ProfileCPUUsage() {
        // 🔍 使用Unity Profiler分析
        using (Profiler.BeginSample("PhysicsUpdate")) {
            Physics.Simulate(Time.fixedDeltaTime);
        }
        
        using (Profiler.BeginSample("AIUpdate")) {
            UpdateAI();
        }
        
        // 📊 自定义性能计数器
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        UpdateGameLogic();
        stopwatch.Stop();
        
        if (stopwatch.ElapsedMilliseconds > 2) {
            Debug.LogWarning($"游戏逻辑更新耗时: {stopwatch.ElapsedMilliseconds}ms");
        }
    }
    
    // 🎯 深度分析特定函数
    void DeepProfileFunction() {
        // 使用ProfilerMarker进行细粒度分析
        using (var marker = new ProfilerMarker("ExpensiveFunction")) {
            using (marker.Auto()) {
                ExpensiveFunction();
            }
        }
    }
}
```

### 解决方案
```typescript
// CPU优化策略
class CPUOptimizer {
    // 🧮 物理计算优化
    optimizePhysics() {
        const optimizations = {
            // 1. 降低物理更新频率
            fixedTimeStep: "从60Hz降到30Hz",
            
            // 2. 简化碰撞体
            colliders: "Box/Sphere替代Mesh碰撞体",
            
            // 3. 分层物理计算
            layers: "重要物体30Hz，环境物体10Hz",
            
            // 4. 距离裁剪
            culling: "距离玩家过远时禁用物理"
        };
        
        // 📊 优化效果
        return {
            before: "物理计算35%CPU占用",
            after: "物理计算12%CPU占用",
            improvement: "CPU负载减少66%"
        };
    }
    
    // 🎨 UI计算优化
    optimizeUI() {
        // 1. 减少Layout重计算
        this.optimizeLayoutCalculation();
        
        // 2. 虚拟化长列表
        this.implementVirtualization();
        
        // 3. 缓存计算结果
        this.cacheCalculations();
    }
    
    private optimizeLayoutCalculation() {
        // ❌ 问题：每帧重新计算所有UI布局
        class BadUIManager {
            update() {
                // 每帧都重算，浪费CPU
                this.recalculateAllLayouts();
            }
        }
        
        // ✅ 解决：只在需要时重新计算
        class OptimizedUIManager {
            private layoutDirty = false;
            
            update() {
                if (this.layoutDirty) {
                    this.recalculateLayouts();
                    this.layoutDirty = false;
                }
            }
            
            markLayoutDirty() {
                this.layoutDirty = true;
            }
        }
    }
    
    // 🤖 AI计算优化
    optimizeAI() {
        return {
            // 1. 分帧计算
            frameSplitting: "寻路计算分散到多帧",
            
            // 2. LOD系统
            lod: "距离近的AI高频更新，远的低频更新",
            
            // 3. 预计算缓存
            cache: "缓存常用路径和决策结果",
            
            // 4. 协程异步
            async: "长耗时AI任务使用协程"
        };
    }
}
```

## 5. 网络瓶颈 🌐

### 问题现象
```cpp
// 网络性能分析
class NetworkBottleneckDetector {
    struct NetworkMetrics {
        float latency;              // 延迟
        float packetLoss;           // 丢包率
        int bandwidthUsage;         // 带宽使用
        int messageQueueSize;       // 消息队列大小
    };
    
    NetworkMetrics analyzeNetwork() {
        return {
            .latency = 150.0f,          // 150ms延迟（偏高）
            .packetLoss = 3.2f,         // 3.2%丢包率
            .bandwidthUsage = 2500,     // 2.5MB/s带宽占用
            .messageQueueSize = 850     // 队列积压850条消息
        };
    }
};
```

### 定位和解决
```typescript
// 网络优化综合方案
class NetworkOptimizer {
    // 📊 数据压缩优化
    optimizeDataCompression() {
        // 1. 协议缓冲区
        const protobuf = {
            before: "JSON: 1200字节",
            after: "Protobuf: 280字节",
            compression: "77%压缩率"
        };
        
        // 2. 增量更新
        const deltaCompression = {
            approach: "只发送变化的数据",
            example: "位置更新：12字节 → 4字节",
            result: "网络流量减少70%"
        };
        
        return { protobuf, deltaCompression };
    }
    
    // 🔄 消息队列优化
    optimizeMessageQueue() {
        class OptimizedNetworkManager {
            private messageQueue: NetworkMessage[] = [];
            private maxQueueSize = 100;
            
            // 🎯 优先级队列
            enqueueMessage(message: NetworkMessage) {
                if (this.messageQueue.length >= this.maxQueueSize) {
                    // 丢弃低优先级消息
                    this.dropLowPriorityMessages();
                }
                
                // 按优先级插入
                this.insertByPriority(message);
            }
            
            // ⚡ 批量处理
            processMessages() {
                const batchSize = 10;
                const batch = this.messageQueue.splice(0, batchSize);
                
                // 批量发送减少网络开销
                this.sendBatch(batch);
            }
        }
    }
}
```

## 6. 性能监控和预警系统 📊

### 实时监控
```cpp
// 综合性能监控系统
class PerformanceMonitor {
    struct PerformanceData {
        float frameTime;
        int drawCalls;
        size_t memoryUsage;
        float cpuUsage;
        float gpuUsage;
        int networkLatency;
    };
    
    void MonitorPerformance() {
        auto data = GatherPerformanceData();
        
        // 🚨 性能预警
        CheckPerformanceThresholds(data);
        
        // 📊 数据记录
        LogPerformanceData(data);
        
        // 🎯 自动优化
        TriggerAutoOptimization(data);
    }
    
    void CheckPerformanceThresholds(const PerformanceData& data) {
        if (data.frameTime > 16.67f) {
            TriggerOptimization(OptimizationType::FrameRate);
        }
        
        if (data.drawCalls > 500) {
            TriggerOptimization(OptimizationType::DrawCalls);
        }
        
        if (data.memoryUsage > 512 * 1024 * 1024) {
            TriggerOptimization(OptimizationType::Memory);
        }
    }
};
```

## 总结：性能优化最佳实践 🎯

### 📊 **优化优先级排序：**
1. **Draw Call优化** - 投入产出比最高
2. **内存优化** - 影响稳定性
3. **CPU瓶颈** - 影响游戏逻辑流畅度
4. **GPU过度绘制** - 影响渲染效率
5. **网络优化** - 影响多人游戏体验

### 🔍 **定位工具链：**
- **Unity**: Profiler + Frame Debugger + Memory Profiler
- **Cocos Creator**: Chrome DevTools + Creator调试器
- **通用**: RenderDoc, PIX, Xcode Instruments

### ⚡ **优化策略：**
- **预防为主**: 从架构设计开始考虑性能
- **数据驱动**: 基于实际性能数据进行优化
- **分层优化**: 先解决影响最大的瓶颈
- **持续监控**: 建立性能回归预警机制

通过系统性的性能分析和优化，通常可以获得**2-5倍的性能提升**，让游戏在各种设备上都能流畅运行！

# CPU和GPU优化策略详解 💻🎮

根据游戏开发实践经验，我来详细分析CPU和GPU的不同优化策略和原理。

## CPU优化策略 🧮

### 1. **算法和数据结构优化**

#### **空间分割算法优化**
```cpp
// 空间查询优化：O(n²) → O(log n)
class SpatialOptimization {
    // ❌ 暴力查询：O(n²)复杂度
    std::vector<Entity> FindNearbyEntities_Slow(const Vector3& position, float radius) {
        std::vector<Entity> result;
        for (const auto& entity : allEntities) {  // 遍历所有实体
            if (Distance(entity.position, position) <= radius) {
                result.push_back(entity);
            }
        }
        return result;
    }
    
    // ✅ 八叉树优化：O(log n)复杂度
    class Octree {
        struct Node {
            BoundingBox bounds;
            std::vector<Entity> entities;
            std::array<std::unique_ptr<Node>, 8> children;
            bool isLeaf = true;
        };
        
        std::unique_ptr<Node> root;
        
    public:
        std::vector<Entity> Query(const Vector3& position, float radius) {
            std::vector<Entity> result;
            QueryRecursive(root.get(), BoundingSphere{position, radius}, result);
            return result;
        }
        
    private:
        void QueryRecursive(Node* node, const BoundingSphere& sphere, std::vector<Entity>& result) {
            if (!Intersects(node->bounds, sphere)) return;
            
            if (node->isLeaf) {
                // 叶节点：检查实体
                for (const auto& entity : node->entities) {
                    if (Distance(entity.position, sphere.center) <= sphere.radius) {
                        result.push_back(entity);
                    }
                }
            } else {
                // 递归查询子节点
                for (auto& child : node->children) {
                    if (child) QueryRecursive(child.get(), sphere, result);
                }
            }
        }
    };
};
```

#### **缓存友好的数据布局**
```cpp
// 内存访问模式优化
class CacheFriendlyOptimization {
    // ❌ AoS (Array of Structures) - 缓存不友好
    struct Transform_AoS {
        Vector3 position;
        Vector3 rotation;
        Vector3 scale;
        Matrix4x4 worldMatrix;    // 64字节，可能跨越多个缓存行
    };
    std::vector<Transform_AoS> transforms_aos;
    
    // ✅ SoA (Structure of Arrays) - 缓存友好
    struct TransformSystem_SoA {
        std::vector<Vector3> positions;     // 连续的位置数据
        std::vector<Vector3> rotations;     // 连续的旋转数据
        std::vector<Vector3> scales;        // 连续的缩放数据
        std::vector<Matrix4x4> worldMatrices; // 连续的矩阵数据
    };
    
    // 🚀 性能对比测试
    void BenchmarkMemoryAccess() {
        const int ENTITY_COUNT = 100000;
        
        // AoS测试：访问所有位置
        auto start = std::chrono::high_resolution_clock::now();
        for (const auto& transform : transforms_aos) {
            ProcessPosition(transform.position);  // 缓存未命中率高
        }
        auto aos_time = std::chrono::high_resolution_clock::now() - start;
        
        // SoA测试：访问所有位置
        start = std::chrono::high_resolution_clock::now();
        for (const auto& position : transformSystem.positions) {
            ProcessPosition(position);  // 缓存命中率高
        }
        auto soa_time = std::chrono::high_resolution_clock::now() - start;
        
        // 📊 结果：SoA通常快2-4倍
        std::cout << "AoS: " << aos_time.count() << "ns\n";
        std::cout << "SoA: " << soa_time.count() << "ns\n";
        std::cout << "Speedup: " << (float)aos_time.count() / soa_time.count() << "x\n";
    }
};
```

### 2. **多线程并行化**

#### **任务并行化**
```cpp
// 游戏系统的并行处理
class ParallelGameSystems {
    ThreadPool workerPool;
    
public:
    void UpdateSystems(float deltaTime) {
        // 🔄 并行更新独立系统
        auto physicsFuture = workerPool.enqueue([this, deltaTime] {
            physicsSystem.Update(deltaTime);
        });
        
        auto aiFuture = workerPool.enqueue([this, deltaTime] {
            aiSystem.Update(deltaTime);
        });
        
        auto audioFuture = workerPool.enqueue([this, deltaTime] {
            audioSystem.Update(deltaTime);
        });
        
        // 主线程处理渲染相关
        renderSystem.Update(deltaTime);
        
        // 等待并行任务完成
        physicsFuture.wait();
        aiFuture.wait();
        audioFuture.wait();
    }
    
    // 🧮 数据并行：批量处理实体
    void UpdateTransforms(std::vector<Entity>& entities) {
        const size_t numThreads = std::thread::hardware_concurrency();
        const size_t entitiesPerThread = entities.size() / numThreads;
        
        std::vector<std::future<void>> futures;
        
        for (size_t i = 0; i < numThreads; ++i) {
            size_t start = i * entitiesPerThread;
            size_t end = (i == numThreads - 1) ? entities.size() : start + entitiesPerThread;
            
            futures.push_back(workerPool.enqueue([&entities, start, end] {
                for (size_t j = start; j < end; ++j) {
                    UpdateEntityTransform(entities[j]);
                }
            }));
        }
        
        // 等待所有线程完成
        for (auto& future : futures) {
            future.wait();
        }
    }
};
```

### 3. **内存管理优化**

#### **对象池和内存池**
```cpp
// 高效的内存分配策略
template<typename T, size_t POOL_SIZE = 1000>
class ObjectPool {
private:
    // 🎯 预分配内存块
    alignas(T) char storage[POOL_SIZE * sizeof(T)];
    std::stack<T*> freeObjects;
    std::atomic<size_t> allocatedCount{0};
    
public:
    ObjectPool() {
        // 初始化空闲对象栈
        for (size_t i = 0; i < POOL_SIZE; ++i) {
            freeObjects.push(reinterpret_cast<T*>(&storage[i * sizeof(T)]));
        }
    }
    
    // ⚡ 快速分配
    T* Acquire() {
        if (freeObjects.empty()) {
            return nullptr; // 池耗尽
        }
        
        T* obj = freeObjects.top();
        freeObjects.pop();
        allocatedCount++;
        
        // placement new
        return new(obj) T();
    }
    
    // 🔄 快速释放
    void Release(T* obj) {
        if (!obj) return;
        
        obj->~T(); // 调用析构函数
        freeObjects.push(obj);
        allocatedCount--;
    }
    
    // 📊 池状态监控
    float GetUsageRatio() const {
        return static_cast<float>(allocatedCount) / POOL_SIZE;
    }
};

// 📊 性能对比
void BenchmarkObjectPool() {
    const int ITERATIONS = 1000000;
    
    // 传统new/delete
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < ITERATIONS; ++i) {
        auto* obj = new GameObject();
        delete obj;
    }
    auto traditional_time = std::chrono::high_resolution_clock::now() - start;
    
    // 对象池
    ObjectPool<GameObject> pool;
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < ITERATIONS; ++i) {
        auto* obj = pool.Acquire();
        pool.Release(obj);
    }
    auto pool_time = std::chrono::high_resolution_clock::now() - start;
    
    // 结果：对象池通常快5-10倍
    std::cout << "Traditional: " << traditional_time.count() << "ns\n";
    std::cout << "Object Pool: " << pool_time.count() << "ns\n";
}
```

### 4. **算法复杂度优化**

#### **碰撞检测优化**
```cpp
// 碰撞检测的多层优化
class CollisionOptimizer {
    // 🔍 宽相检测：快速排除
    std::vector<CollisionPair> BroadPhase(const std::vector<Collider>& colliders) {
        std::vector<CollisionPair> potentialPairs;
        
        // 使用AABB包围盒快速检测
        for (size_t i = 0; i < colliders.size(); ++i) {
            for (size_t j = i + 1; j < colliders.size(); ++j) {
                if (AABBIntersect(colliders[i].bounds, colliders[j].bounds)) {
                    potentialPairs.push_back({i, j});
                }
            }
        }
        
        return potentialPairs;
    }
    
    // 🎯 窄相检测：精确计算
    std::vector<Collision> NarrowPhase(const std::vector<CollisionPair>& pairs,
                                      const std::vector<Collider>& colliders) {
        std::vector<Collision> collisions;
        
        // 只对通过宽相的对象进行精确检测
        for (const auto& pair : pairs) {
            auto collision = PreciseCollisionTest(colliders[pair.first], colliders[pair.second]);
            if (collision.hasCollision) {
                collisions.push_back(collision);
            }
        }
        
        return collisions;
    }
    
    // 📊 复杂度分析
    void AnalyzeComplexity() {
        /*
         * 暴力检测：O(n²) - 不可接受
         * 宽相+窄相：O(n log n) + O(k) - 其中k<<n²
         * 空间分割：O(n) + O(k) - 最优情况
         */
    }
};
```

## GPU优化策略 🎮

### 1. **渲染调用优化**

#### **批处理和实例化**
```cpp
// GPU批处理优化
class GPUBatchingOptimizer {
    // ❌ 每个对象单独Draw Call
    void RenderObjects_Inefficient(const std::vector<GameObject>& objects) {
        for (const auto& obj : objects) {
            SetMaterial(obj.material);
            SetTexture(obj.texture);
            SetTransform(obj.transform);
            DrawMesh(obj.mesh);  // 1000个对象 = 1000个Draw Call
        }
    }
    
    // ✅ 静态批处理
    void RenderObjects_StaticBatching(const std::vector<GameObject>& objects) {
        // 预计算：合并相同材质的静态对象
        auto batches = CreateStaticBatches(objects);
        
        for (const auto& batch : batches) {
            SetMaterial(batch.material);
            SetTexture(batch.texture);
            DrawMesh(batch.combinedMesh);  // 1000个对象 → 10个Draw Call
        }
    }
    
    // 🚀 GPU实例化渲染
    void RenderObjects_Instancing(const std::vector<GameObject>& objects) {
        // 按网格分组
        auto instanceGroups = GroupByMesh(objects);
        
        for (const auto& group : instanceGroups) {
            // 准备实例数据
            std::vector<InstanceData> instanceData;
            for (const auto& obj : group.objects) {
                instanceData.push_back({
                    obj.transform.worldMatrix,
                    obj.color,
                    obj.textureOffset
                });
            }
            
            // 上传实例数据到GPU
            SetInstanceBuffer(instanceData);
            
            // 一次Draw Call渲染所有实例
            DrawMeshInstanced(group.mesh, group.material, instanceData.size());
        }
    }
    
    // 📊 性能对比
    struct RenderingStats {
        int drawCalls;
        float cpuTime;
        float gpuTime;
    };
    
    RenderingStats GetStats() {
        return {
            // 传统渲染：1000 Draw Call，CPU 15ms，GPU 8ms
            // 静态批处理：50 Draw Call，CPU 8ms，GPU 5ms  
            // 实例化渲染：10 Draw Call，CPU 3ms，GPU 3ms
        };
    }
};
```

### 2. **纹理和内存优化**

#### **纹理压缩和Mipmap**
```cpp
// 纹理内存优化
class TextureOptimizer {
    // 🎯 平台特化的纹理格式
    void OptimizeTextureFormats() {
        struct PlatformFormat {
            std::string platform;
            std::string format;
            float compressionRatio;
            std::string quality;
        };
        
        std::vector<PlatformFormat> formats = {
            {"iOS", "ASTC 6x6", 0.33f, "高质量"},
            {"Android", "ETC2", 0.50f, "中等质量"}, 
            {"PC", "BC7", 0.25f, "最高质量"},
            {"WebGL", "DXT5", 0.25f, "兼容性最好"}
        };
        
        // 自动选择最优格式
        for (const auto& format : formats) {
            ApplyTextureFormat(format.platform, format.format);
        }
    }
    
    // 📊 Mipmap链优化
    void OptimizeMipmaps() {
        struct MipmapSettings {
            std::string textureType;
            bool enableMipmap;
            std::string reason;
        };
        
        std::vector<MipmapSettings> settings = {
            {"UI纹理", false, "UI元素固定大小，不需要Mipmap"},
            {"3D纹理", true, "距离变化大，需要Mipmap减少走样"},
            {"天空盒", false, "总是远距离渲染，使用固定分辨率"},
            {"地形纹理", true, "视距变化极大，Mipmap必需"}
        };
        
        ApplyMipmapSettings(settings);
    }
    
    // 🔧 纹理流送
    class TextureStreaming {
        struct StreamingTexture {
            GLuint textureId;
            int currentMipLevel;
            int targetMipLevel;
            float importance;
            bool isLoading;
        };
        
        std::vector<StreamingTexture> streamingTextures;
        size_t memoryBudget = 512 * 1024 * 1024; // 512MB
        
    public:
        void UpdateStreaming() {
            // 计算每个纹理的重要性
            for (auto& texture : streamingTextures) {
                texture.importance = CalculateImportance(texture);
                texture.targetMipLevel = CalculateTargetMipLevel(texture.importance);
            }
            
            // 按重要性排序
            std::sort(streamingTextures.begin(), streamingTextures.end(),
                     [](const auto& a, const auto& b) { return a.importance > b.importance; });
            
            // 在预算内加载最重要的纹理
            LoadTexturesWithinBudget();
        }
        
    private:
        float CalculateImportance(const StreamingTexture& texture) {
            // 基于距离、屏幕占用、可见性等因素
            float distance = GetDistanceToCamera(texture);
            float screenSize = GetScreenSpaceSize(texture);
            bool isVisible = IsVisible(texture);
            
            return isVisible ? (screenSize / distance) : 0.0f;
        }
    };
};
```

### 3. **着色器优化**

#### **着色器性能调优**
```glsl
// GPU着色器优化示例
// ❌ 低效的片段着色器
shader InEfficientFragmentShader {
    uniform sampler2D mainTexture;
    uniform sampler2D normalMap;
    uniform sampler2D specularMap;
    uniform float time;
    
    varying vec2 uv;
    varying vec3 worldPos;
    varying vec3 normal;
    
    void main() {
        // 🔴 问题1：复杂的数学运算
        vec3 animatedUV = vec3(uv, 0.0);
        for (int i = 0; i < 10; i++) {  // 避免循环
            animatedUV.xy += sin(time * float(i)) * 0.01;
        }
        
        // 🔴 问题2：多次纹理采样
        vec4 albedo = texture2D(mainTexture, animatedUV.xy);
        vec3 normal = texture2D(normalMap, animatedUV.xy).rgb;
        float specular = texture2D(specularMap, animatedUV.xy).r;
        
        // 🔴 问题3：分支语句
        if (worldPos.y > 0.0) {
            albedo.rgb *= 2.0;  // GPU分支效率低
        } else {
            albedo.rgb *= 0.5;
        }
        
        gl_FragColor = albedo;
    }
}

// ✅ 优化后的片段着色器
shader OptimizedFragmentShader {
    uniform sampler2D combinedTexture;  // 合并纹理通道
    uniform vec2 timeFactors;           // 预计算的时间因子
    
    varying vec2 uv;
    varying vec3 worldPos;
    varying float heightFactor;         // 顶点着色器预计算
    
    void main() {
        // ✅ 优化1：简化UV动画
        vec2 animatedUV = uv + timeFactors;
        
        // ✅ 优化2：单次纹理采样获取多通道
        vec4 combined = texture2D(combinedTexture, animatedUV);
        vec3 albedo = combined.rgb;     // R,G,B: 漫反射
        float specular = combined.a;    // A: 镜面反射
        
        // ✅ 优化3：避免分支，使用lerp
        float heightMultiplier = mix(0.5, 2.0, heightFactor);
        albedo *= heightMultiplier;
        
        gl_FragColor = vec4(albedo, 1.0);
    }
}
```

#### **Uber Shader系统**
```cpp
// 统一着色器系统
class UberShaderSystem {
    // 🎯 单个着色器处理多种材质
    struct ShaderVariant {
        std::string defines;
        GLuint programId;
        bool isCompiled;
    };
    
    std::unordered_map<std::string, ShaderVariant> variants;
    
public:
    GLuint GetShader(const MaterialFeatures& features) {
        // 根据特性生成宏定义
        std::string defines = GenerateDefines(features);
        
        auto it = variants.find(defines);
        if (it != variants.end()) {
            return it->second.programId;  // 返回缓存的变体
        }
        
        // 编译新的着色器变体
        return CompileShaderVariant(defines);
    }
    
private:
    std::string GenerateDefines(const MaterialFeatures& features) {
        std::string defines;
        
        if (features.hasNormalMap) defines += "#define USE_NORMAL_MAP\n";
        if (features.hasSpecularMap) defines += "#define USE_SPECULAR_MAP\n";
        if (features.hasAnimation) defines += "#define USE_ANIMATION\n";
        if (features.receiveShadows) defines += "#define RECEIVE_SHADOWS\n";
        
        return defines;
    }
    
    // 📊 着色器变体统计
    void LogVariantStats() {
        std::cout << "着色器变体数量: " << variants.size() << "\n";
        std::cout << "内存使用: " << CalculateShaderMemory() << " MB\n";
        
        // 优化建议：变体数量过多时考虑合并特性
        if (variants.size() > 100) {
            std::cout << "警告：着色器变体过多，考虑优化\n";
        }
    }
};
```

### 4. **几何和渲染管线优化**

#### **LOD系统和剔除**
```cpp
// 几何细节层次管理
class LODSystem {
    struct LODLevel {
        Mesh mesh;
        float distance;
        int triangleCount;
        float screenThreshold;
    };
    
    struct LODObject {
        std::vector<LODLevel> levels;
        Vector3 position;
        float boundingRadius;
    };
    
    std::vector<LODObject> lodObjects;
    
public:
    // 🎯 动态LOD选择
    void UpdateLOD(const Camera& camera) {
        for (auto& obj : lodObjects) {
            float distance = Distance(camera.position, obj.position);
            float screenSize = obj.boundingRadius / distance;
            
            // 选择合适的LOD级别
            int lodLevel = SelectLODLevel(obj, screenSize);
            
            // 设置渲染LOD
            SetObjectLOD(obj, lodLevel);
        }
    }
    
    // 🔍 视锥剔除
    std::vector<RenderObject> FrustumCulling(const Camera& camera) {
        std::vector<RenderObject> visibleObjects;
        Frustum frustum = camera.GetFrustum();
        
        for (const auto& obj : renderObjects) {
            if (frustum.Contains(obj.boundingBox)) {
                visibleObjects.push_back(obj);
            }
        }
        
        return visibleObjects;
    }
    
    // 🌫️ 遮挡剔除（高级）
    std::vector<RenderObject> OcclusionCulling(const std::vector<RenderObject>& visible) {
        std::vector<RenderObject> unoccluded;
        
        // 使用GPU查询或层次化Z-Buffer
        for (const auto& obj : visible) {
            if (!IsOccluded(obj)) {
                unoccluded.push_back(obj);
            }
        }
        
        return unoccluded;
    }
    
    // 📊 剔除统计
    struct CullingStats {
        int totalObjects = 10000;
        int afterFrustum = 3000;      // 70%被视锥剔除
        int afterOcclusion = 800;     // 73%被遮挡剔除
        int finalRender = 800;        // 最终渲染8%的对象
    };
};
```

### 5. **现代GPU特性利用**

#### **计算着色器并行计算**
```cpp
// 利用GPU并行计算能力
class ComputeShaderOptimizer {
    // 🧮 粒子系统GPU计算
    void UpdateParticlesOnGPU() {
        const char* computeShader = R"(
            #version 430
            layout(local_size_x = 64) in;
            
            layout(std430, binding = 0) buffer ParticleBuffer {
                struct Particle {
                    vec3 position;
                    vec3 velocity;
                    float life;
                    float size;
                } particles[];
            };
            
            uniform float deltaTime;
            uniform vec3 gravity;
            
            void main() {
                uint index = gl_GlobalInvocationID.x;
                if (index >= particles.length()) return;
                
                // 并行更新每个粒子
                particles[index].velocity += gravity * deltaTime;
                particles[index].position += particles[index].velocity * deltaTime;
                particles[index].life -= deltaTime;
                
                // 重生粒子
                if (particles[index].life <= 0.0) {
                    particles[index] = SpawnNewParticle();
                }
            }
        )";
        
        // 🚀 一次处理100,000个粒子
        glDispatchCompute(100000 / 64, 1, 1);
    }
    
    // 🎯 GPU驱动渲染
    void GPUDrivenRendering() {
        // GPU上执行剔除和LOD选择
        DispatchCullingCompute();
        
        // GPU生成绘制命令
        DispatchDrawCommandGeneration();
        
        // 间接绘制
        glMultiDrawElementsIndirect(GL_TRIANGLES, GL_UNSIGNED_INT, 
                                   indirectBuffer, drawCount, 0);
    }
    
    // 📊 性能对比
    void BenchmarkCompute() {
        // CPU更新100K粒子：15ms
        // GPU计算着色器：2ms
        // 性能提升：7.5倍
    }
};
```

## 平台特化优化 📱💻

### 移动端GPU优化
```cpp
// 移动端特殊优化
class MobileGPUOptimizer {
    void OptimizeForMobile() {
        // 🔥 Tile-based渲染优化（PowerVR, Adreno）
        EnableTiledRendering();
        
        // 🌡️ 热控制
        ImplementThermalThrottling();
        
        // ⚡ 功耗优化
        ReducePowerConsumption();
    }
    
private:
    void EnableTiledRendering() {
        // 避免framebuffer读取
        glHint(GL_GENERATE_MIPMAP_HINT, GL_FASTEST);
        
        // 使用discard避免不必要的存储
        if (!needDepthBuffer) {
            glDiscardFramebufferEXT(GL_FRAMEBUFFER, 1, attachments);
        }
    }
    
    void ImplementThermalThrottling() {
        float temperature = GetDeviceTemperature();
        
        if (temperature > 60.0f) {
            // 降低渲染质量
            ReduceRenderQuality(0.75f);
            SetTargetFrameRate(30);
        } else if (temperature > 40.0f) {
            ReduceRenderQuality(0.9f);
        }
    }
};
```

## 性能监控和分析 📊

### 实时性能监控
```cpp
// 性能监控系统
class PerformanceMonitor {
    struct FrameStats {
        float cpuTime;
        float gpuTime;
        int drawCalls;
        int triangles;
        size_t memoryUsage;
    };
    
    std::array<FrameStats, 120> frameHistory; // 2秒历史
    
public:
    void RecordFrame() {
        FrameStats current = {
            .cpuTime = GetCPUTime(),
            .gpuTime = GetGPUTime(),
            .drawCalls = GetDrawCallCount(),
            .triangles = GetTriangleCount(),
            .memoryUsage = GetMemoryUsage()
        };
        
        frameHistory[currentFrame % 120] = current;
        
        // 实时分析
        AnalyzePerformance(current);
    }
    
private:
    void AnalyzePerformance(const FrameStats& stats) {
        // 🚨 性能警告
        if (stats.cpuTime > 16.67f) {
            TriggerCPUOptimization();
        }
        
        if (stats.drawCalls > 500) {
            TriggerBatchingOptimization();
        }
        
        if (stats.memoryUsage > 512 * 1024 * 1024) {
            TriggerMemoryCleanup();
        }
    }
};
```

## 总结：优化策略对比 🎯

### CPU vs GPU优化重点

| 方面 | CPU优化 | GPU优化 |
|------|---------|---------|
| **主要瓶颈** | 算法复杂度、缓存未命中 | Draw Call、纹理带宽 |
| **优化重点** | 数据结构、并行计算 | 批处理、着色器效率 |
| **工具** | CPU Profiler、算法分析 | RenderDoc、GPU调试器 |
| **效果** | 减少计算时间 | 提高渲染吞吐量 |

### 💡 **关键优化原则：**

**CPU优化：**
- 减少算法复杂度
- 提高缓存命中率
- 合理使用多线程
- 避免不必要的计算

**GPU优化：**
- 减少Draw Call数量
- 优化纹理使用
- 简化着色器计算
- 充分利用并行性

通过CPU和GPU的协同优化，通常可以获得**5-10倍的整体性能提升**！

Search files...
# 移动端游戏性能优化重点指南 📱⚡

移动端游戏优化与PC端有着显著差异，需要重点关注**功耗、发热、内存限制、GPU架构差异**等移动设备特有的约束。

## 1. 核心优化重点排序 🎯

### 第一优先级：内存管理（生死攸关）💾

移动设备内存限制严格，内存不足直接导致应用被系统杀死。

```typescript
// 移动端内存管理策略
class MobileMemoryManager {
    private memoryBudget = {
        // 📱 不同设备的内存预算
        lowEnd: 200 * 1024 * 1024,    // 200MB（2GB RAM设备）
        midRange: 400 * 1024 * 1024,  // 400MB（4GB RAM设备）
        highEnd: 800 * 1024 * 1024    // 800MB（8GB+ RAM设备）
    };
    
    // 🎯 设备分级和内存分配
    detectDeviceAndSetBudget() {
        const totalRAM = this.getTotalDeviceRAM();
        const gpuMemory = this.getGPUMemoryInfo();
        
        if (totalRAM <= 2048) {
            // 低端设备：极限优化
            this.setMemoryBudget(this.memoryBudget.lowEnd);
            this.enableAggressiveOptimization();
        } else if (totalRAM <= 4096) {
            // 中端设备：平衡优化
            this.setMemoryBudget(this.memoryBudget.midRange);
            this.enableBalancedOptimization();
        } else {
            // 高端设备：质量优先
            this.setMemoryBudget(this.memoryBudget.highEnd);
            this.enableQualityOptimization();
        }
    }
    
    // 🚨 内存监控和预警
    private memoryMonitor() {
        const currentUsage = this.getCurrentMemoryUsage();
        const budget = this.currentMemoryBudget;
        
        if (currentUsage > budget * 0.9) {
            // 内存使用超过90%，紧急释放
            this.emergencyMemoryCleanup();
        } else if (currentUsage > budget * 0.75) {
            // 内存使用超过75%，主动清理
            this.proactiveMemoryCleanup();
        }
    }
    
    private emergencyMemoryCleanup() {
        // 🗑️ 紧急内存清理策略
        this.unloadDistantSceneAssets();      // 卸载远距离场景资源
        this.clearAudioCache();               // 清空音频缓存
        this.reduceTextureQuality(0.5);       // 降低纹理质量到50%
        this.forceGarbageCollection();        // 强制垃圾回收
        this.clearParticlePoolCache();        // 清空粒子池缓存
    }
}
```

### 第二优先级：发热控制（用户体验）🌡️

移动设备发热直接影响用户体验，需要动态调整性能。

```cpp
// 热控制系统
class ThermalManager {
    enum class ThermalState {
        Normal,     // < 40°C
        Warm,       // 40-50°C
        Hot,        // 50-60°C
        Critical    // > 60°C
    };
    
    struct ThermalConfig {
        int targetFrameRate;
        float renderScale;
        float effectQuality;
        bool enablePostProcessing;
        int maxLights;
    };
    
    std::map<ThermalState, ThermalConfig> thermalConfigs = {
        {ThermalState::Normal, {60, 1.0f, 1.0f, true, 8}},
        {ThermalState::Warm, {45, 0.9f, 0.8f, true, 6}},
        {ThermalState::Hot, {30, 0.75f, 0.6f, false, 4}},
        {ThermalState::Critical, {20, 0.5f, 0.3f, false, 2}}
    };
    
public:
    void UpdateThermalState() {
        float temperature = GetCPUTemperature();
        ThermalState newState = ClassifyThermalState(temperature);
        
        if (newState != currentState) {
            ApplyThermalConfiguration(newState);
            LogThermalEvent(currentState, newState, temperature);
        }
        
        currentState = newState;
    }
    
private:
    void ApplyThermalConfiguration(ThermalState state) {
        auto config = thermalConfigs[state];
        
        // 🎯 动态调整渲染参数
        SetTargetFrameRate(config.targetFrameRate);
        SetRenderScale(config.renderScale);
        SetEffectQuality(config.effectQuality);
        EnablePostProcessing(config.enablePostProcessing);
        SetMaxLightCount(config.maxLights);
        
        // 📊 通知用户（可选）
        if (state >= ThermalState::Hot) {
            ShowPerformanceModeNotification("设备温度较高，已降低画质保护设备");
        }
    }
    
    // 🌡️ iOS系统热控制集成
    void SetupIOSThermalMonitoring() {
        // 监听系统热状态变化
        [[NSNotificationCenter defaultCenter] 
         addObserverForName:NSProcessInfoThermalStateDidChangeNotification
                     object:nil
                      queue:[NSOperationQueue mainQueue]
                 usingBlock:^(NSNotification *note) {
                     NSProcessInfoThermalState state = [[NSProcessInfo processInfo] thermalState];
                     HandleSystemThermalChange(state);
                 }];
    }
};
```

### 第三优先级：电量优化（续航时间）🔋

移动游戏需要平衡性能和电量消耗。

```typescript
// 电量管理系统
class PowerManager {
    private powerProfiles = {
        // ⚡ 不同电量模式的配置
        powerSaving: {
            frameRate: 30,
            renderScale: 0.7,
            enableDynamicBatching: true,
            reduceParticles: 0.3,
            disableAdvancedShaders: true
        },
        balanced: {
            frameRate: 45,
            renderScale: 0.85,
            enableDynamicBatching: true,
            reduceParticles: 0.7,
            disableAdvancedShaders: false
        },
        performance: {
            frameRate: 60,
            renderScale: 1.0,
            enableDynamicBatching: false,
            reduceParticles: 1.0,
            disableAdvancedShaders: false
        }
    };
    
    // 🔋 根据电量自动调整
    autoAdjustPowerMode() {
        const batteryLevel = this.getBatteryLevel();
        const isCharging = this.isDeviceCharging();
        
        if (isCharging) {
            // 充电时使用性能模式
            this.setPowerMode('performance');
        } else if (batteryLevel < 0.2) {
            // 低电量时强制省电模式
            this.setPowerMode('powerSaving');
        } else if (batteryLevel < 0.5) {
            // 中等电量时使用平衡模式
            this.setPowerMode('balanced');
        } else {
            // 电量充足时使用性能模式
            this.setPowerMode('performance');
        }
    }
    
    // ⚡ GPU功耗优化
    private optimizeGPUPower() {
        // 1. 降低GPU频率
        this.setGPUClockSpeed('medium');
        
        // 2. 减少过度绘制
        this.enableOcclusionCulling();
        
        // 3. 简化着色器
        this.useSimplifiedShaders();
        
        // 4. 降低分辨率
        this.setDynamicResolution(0.8);
    }
}
```

## 2. 移动端GPU架构特化优化 🎮

### Tile-Based 渲染优化（ARM Mali, PowerVR）

```cpp
// 针对移动GPU的特殊优化
class MobileGPUOptimizer {
    // 🏗️ Tile-Based渲染优化
    void OptimizeForTiledGPU() {
        // 1. 避免不必要的framebuffer读取
        DisableFramebufferReads();
        
        // 2. 使用discard优化
        UseDiscardForUnusedAttachments();
        
        // 3. 减少rendertarget切换
        MinimizeRenderTargetSwitches();
        
        // 4. 优化深度测试
        OptimizeDepthTesting();
    }
    
private:
    void DisableFramebufferReads() {
        // ❌ 避免：读取framebuffer会破坏tile-based优化
        // glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
        
        // ✅ 推荐：使用shader间接获取结果
        UseShaderBasedDataExtraction();
    }
    
    void UseDiscardForUnusedAttachments() {
        // OpenGL ES优化
        GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};
        
        // 显式丢弃不需要的attachment，节省带宽
        glDiscardFramebufferEXT(GL_FRAMEBUFFER, 2, attachments);
    }
    
    // 📊 移动GPU性能特点
    void AnalyzeMobileGPUCharacteristics() {
        struct MobileGPUProfile {
            std::string architecture;
            int computeUnits;
            int memoryBandwidth;    // GB/s
            std::string优化重点;
        };
        
        std::vector<MobileGPUProfile> profiles = {
            {"ARM Mali-G78", 20, 25, "带宽优化，避免复杂fragment shader"},
            {"Qualcomm Adreno 660", 512, 44, "ALU优化，充分利用计算能力"},
            {"Apple A15 GPU", 16, 68, "平衡优化，Metal性能调优"},
            {"PowerVR Series", 128, 20, "Tile-based优化，减少overdraw"}
        };
    }
};
```

### 移动端着色器优化

```glsl
// 移动端友好的着色器设计
// ❌ 桌面端复杂着色器
shader ComplexDesktopShader {
    // 高精度计算
    precision highp float;
    
    uniform sampler2D diffuseMap;
    uniform sampler2D normalMap;
    uniform sampler2D specularMap;
    uniform sampler2D roughnessMap;
    uniform sampler2D aoMap;
    
    void main() {
        // 多次纹理采样
        vec4 diffuse = texture2D(diffuseMap, uv);
        vec3 normal = texture2D(normalMap, uv).rgb;
        float specular = texture2D(specularMap, uv).r;
        float roughness = texture2D(roughnessMap, uv).r;
        float ao = texture2D(aoMap, uv).r;
        
        // 复杂光照计算
        vec3 lighting = CalculatePBRLighting(diffuse, normal, specular, roughness, ao);
        
        gl_FragColor = vec4(lighting, 1.0);
    }
}

// ✅ 移动端优化着色器
shader OptimizedMobileShader {
    // 中等精度足够
    precision mediump float;
    
    // 合并纹理通道
    uniform sampler2D packedTexture; // R:diffuse, G:specular, B:roughness, A:ao
    
    void main() {
        // 单次纹理采样
        vec4 packed = texture2D(packedTexture, uv);
        
        // 简化光照模型
        vec3 lighting = CalculateSimplifiedLighting(packed);
        
        gl_FragColor = vec4(lighting, 1.0);
    }
    
    // 简化的光照计算
    vec3 CalculateSimplifiedLighting(vec4 packed) {
        vec3 diffuse = packed.rgb;
        float specular = packed.a;
        
        // 使用预计算的光照查找表
        float ndotl = max(0.0, dot(normal, lightDir));
        vec3 lighting = diffuse * ndotl + specular * pow(ndotl, 8.0);
        
        return lighting;
    }
}
```

## 3. 移动端特有优化策略 📱

### 网络优化（移动网络特点）

```typescript
// 移动网络优化
class MobileNetworkOptimizer {
    // 📶 网络状态适配
    adaptToNetworkCondition() {
        const networkType = this.getNetworkType();
        const signalStrength = this.getSignalStrength();
        
        switch (networkType) {
            case 'wifi':
                this.setNetworkProfile('high_bandwidth');
                break;
            case '4g':
                this.setNetworkProfile('medium_bandwidth');
                break;
            case '3g':
                this.setNetworkProfile('low_bandwidth');
                break;
            case '2g':
                this.setNetworkProfile('minimal_bandwidth');
                break;
        }
        
        // 根据信号强度调整
        if (signalStrength < 0.3) {
            this.enableAggressiveCompression();
            this.reduceUpdateFrequency();
        }
    }
    
    // 📊 移动端数据压缩
    private enableMobileCompression() {
        const compressionStrategies = {
            // 1. 增量更新
            deltaCompression: {
                approach: "只发送变化的数据",
                saving: "70-90%带宽节省"
            },
            
            // 2. 二进制协议
            binaryProtocol: {
                approach: "使用ProtoBuf替代JSON",
                saving: "60-80%大小减少"
            },
            
            // 3. 批量传输
            batching: {
                approach: "合并多个小请求",
                saving: "减少网络往返次数"
            }
        };
        
        return compressionStrategies;
    }
}
```

### 触控输入优化

```cpp
// 移动端输入系统优化
class MobileTouchOptimizer {
    // 🖱️ 高精度触控处理
    void OptimizeTouchInput() {
        // 1. 减少输入延迟
        SetTouchSampleRate(120); // 120Hz触控采样
        
        // 2. 预测性输入
        EnableTouchPrediction();
        
        // 3. 多点触控优化
        OptimizeMultiTouch();
    }
    
    // 🎮 手势识别优化
    void OptimizeGestureRecognition() {
        // 使用轻量级手势识别算法
        class LightweightGestureRecognizer {
            // 减少计算复杂度的简化算法
            GestureType RecognizeGesture(const std::vector<TouchPoint>& points) {
                if (points.size() < 2) return GestureType::None;
                
                // 简化的直线距离计算
                float distance = Distance(points.front(), points.back());
                float duration = points.back().timestamp - points.front().timestamp;
                
                if (distance > 100 && duration < 0.5f) {
                    return GestureType::Swipe;
                } else if (distance < 10 && duration > 0.5f) {
                    return GestureType::LongPress;
                }
                
                return GestureType::Tap;
            }
        };
    }
};
```

## 4. 设备分级和自适应系统 📊

### 设备性能检测和分级

```typescript
// 设备性能评估系统
class DeviceProfiler {
    // 🔍 设备性能检测
    async profileDevice(): Promise<DeviceProfile> {
        const profile = {
            // 硬件信息
            cpu: await this.benchmarkCPU(),
            gpu: await this.benchmarkGPU(),
            memory: this.getMemoryInfo(),
            storage: this.getStorageInfo(),
            
            // 运行时性能
            thermalCapacity: await this.testThermalPerformance(),
            batteryEfficiency: await this.testBatteryDrain(),
            
            // 设备分级
            tier: this.calculateDeviceTier()
        };
        
        return profile;
    }
    
    private async benchmarkGPU(): Promise<GPUProfile> {
        // 🎮 GPU性能测试
        const testScene = this.createGPUBenchmarkScene();
        const startTime = performance.now();
        
        // 渲染标准测试场景
        for (let i = 0; i < 100; i++) {
            await this.renderFrame(testScene);
        }
        
        const avgFrameTime = (performance.now() - startTime) / 100;
        
        return {
            averageFrameTime: avgFrameTime,
            fillRate: this.calculateFillRate(),
            textureMemoryBandwidth: this.measureTextureBandwidth(),
            tier: this.classifyGPUTier(avgFrameTime)
        };
    }
    
    // 📱 设备分级标准
    private calculateDeviceTier(): DeviceTier {
        const score = this.calculatePerformanceScore();
        
        if (score >= 80) return DeviceTier.HighEnd;
        if (score >= 60) return DeviceTier.MidRange;
        if (score >= 40) return DeviceTier.LowMid;
        return DeviceTier.LowEnd;
    }
    
    // 🎯 根据设备分级应用不同配置
    applyDeviceOptimizations(tier: DeviceTier) {
        const configs = {
            [DeviceTier.HighEnd]: {
                renderScale: 1.0,
                textureQuality: 'ultra',
                effectQuality: 'high',
                targetFPS: 60,
                enablePostProcessing: true
            },
            [DeviceTier.MidRange]: {
                renderScale: 0.9,
                textureQuality: 'high',
                effectQuality: 'medium',
                targetFPS: 45,
                enablePostProcessing: true
            },
            [DeviceTier.LowMid]: {
                renderScale: 0.75,
                textureQuality: 'medium',
                effectQuality: 'low',
                targetFPS: 30,
                enablePostProcessing: false
            },
            [DeviceTier.LowEnd]: {
                renderScale: 0.6,
                textureQuality: 'low',
                effectQuality: 'minimal',
                targetFPS: 24,
                enablePostProcessing: false
            }
        };
        
        this.applyConfiguration(configs[tier]);
    }
}
```

## 5. 移动端调试和监控 🔧

### 实时性能监控

```cpp
// 移动端性能监控系统
class MobilePerformanceMonitor {
    struct MobileMetrics {
        float frameTime;
        float cpuUsage;
        float gpuUsage;
        size_t memoryUsage;
        float temperature;
        float batteryDrain;
        int networkLatency;
        float touchLatency;
    };
    
    void StartMonitoring() {
        // 🔄 轻量级监控循环
        monitoringThread = std::thread([this] {
            while (isMonitoring) {
                auto metrics = GatherMobileMetrics();
                AnalyzeMetrics(metrics);
                
                // 移动端监控频率较低，避免影响性能
                std::this_thread::sleep_for(std::chrono::milliseconds(200));
            }
        });
    }
    
    void AnalyzeMetrics(const MobileMetrics& metrics) {
        // 🚨 移动端特有的性能警告
        
        if (metrics.temperature > 50.0f) {
            TriggerThermalOptimization();
        }
        
        if (metrics.batteryDrain > 15.0f) { // 每小时超过15%
            TriggerPowerOptimization();
        }
        
        if (metrics.memoryUsage > GetMemoryBudget() * 0.8f) {
            TriggerMemoryCleanup();
        }
        
        if (metrics.touchLatency > 50.0f) { // 超过50ms
            OptimizeTouchResponseTime();
        }
    }
    
    // 📊 生成移动端性能报告
    void GenerateMobileReport() {
        MobilePerformanceReport report = {
            .deviceInfo = GetDeviceInfo(),
            .thermalHistory = GetThermalHistory(),
            .batteryUsagePattern = GetBatteryUsagePattern(),
            .networkPerformance = GetNetworkPerformance(),
            .userInteractionLatency = GetUILatencyStats(),
            .optimizationRecommendations = GenerateOptimizationAdvice()
        };
        
        SaveReport(report);
    }
};
```

## 6. 移动端优化最佳实践 🎯

### 优化检查清单

```typescript
// 移动端优化检查清单
const MobileOptimizationChecklist = {
    // 🔥 内存优化（必需）
    memory: [
        "✅ 纹理压缩（ASTC/ETC2）",
        "✅ 音频压缩（OGG/AAC）", 
        "✅ 网格优化（减少顶点数）",
        "✅ 对象池使用",
        "✅ 及时资源释放",
        "✅ 内存预算管理"
    ],
    
    // 🌡️ 发热控制（重要）
    thermal: [
        "✅ CPU使用率监控",
        "✅ 动态帧率调整",
        "✅ 渲染质量降级",
        "✅ 后台处理暂停",
        "✅ 系统热状态监听"
    ],
    
    // 🔋 电量优化（重要）
    power: [
        "✅ GPU频率控制",
        "✅ 屏幕亮度适配",
        "✅ 网络请求合并",
        "✅ 传感器使用优化",
        "✅ 后台任务管理"
    ],
    
    // 🎮 用户体验（基础）
    ux: [
        "✅ 触控延迟优化",
        "✅ 加载时间优化",
        "✅ 流畅度保证",
        "✅ 崩溃率控制",
        "✅ 兼容性测试"
    ]
};
```

## 总结：移动端优化核心原则 📱

### ✅ **移动端优化三大支柱：**

1. **内存为王** - 内存限制是移动端的生死线
2. **热控优先** - 发热直接影响用户体验
3. **电量意识** - 续航能力决定用户留存

### 🎯 **优化优先级：**
1. **内存优化** → 避免OOM崩溃
2. **发热控制** → 保证持续性能
3. **电量优化** → 提升用户满意度
4. **触控优化** → 改善交互体验
5. **网络优化** → 适配移动网络

### 📊 **成功指标：**
- 内存使用 < 设备总RAM的25%
- 发热控制 < 45°C正常使用
- 电量消耗 < 10%/小时
- 触控延迟 < 50ms
- 启动时间 < 3秒

通过系统性的移动端优化，可以让游戏在各种移动设备上都获得**流畅、稳定、省电**的体验！