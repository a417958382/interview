# SLG游戏算法指南

## 概述

策略大型游戏（SLG）是一类复杂的游戏类型，涉及多个算法领域。本指南介绍了在SLG游戏开发中常用的核心算法实现。

## 核心算法分类

### 🗺️ 路径寻找算法

#### A*路径寻找算法
- **用途**: 在复杂地形中寻找最优路径
- **时间复杂度**: O(b^d)，实际表现通常很好
- **空间复杂度**: O(b^d)
- **优化技巧**:
  - 使用预计算的路径图
  - 实现分层路径寻找
  - 添加移动成本权重

#### 地形处理
- **平原**: 基础移动成本为1
- **森林**: 步兵移动成本增加，弓箭手优势
- **山地**: 高移动成本，骑兵受限
- **水域**: 非工人单位无法通行
- **道路**: 降低移动成本，优化交通

### 🤖 AI决策算法

#### 有限状态机 (FSM)
- **用途**: 管理单位和AI的状态转换
- **复杂度**: O(1)时间复杂度
- **优势**: 简单、可靠、易于调试
- **应用场景**: 单位行为控制、游戏状态管理

#### 行为树 (Behavior Tree)
- **用途**: 组织复杂的AI行为逻辑
- **复杂度**: O(树深度)
- **优势**: 模块化、可重用、易于扩展
- **节点类型**:
  - **序列节点**: 顺序执行子节点
  - **选择器节点**: 执行第一个成功的子节点
  - **动作节点**: 执行具体行为
  - **条件节点**: 检查状态条件

### 💰 资源管理算法

#### 资源分配优化
- **算法**: 贪心算法结合优先级排序
- **复杂度**: O(n log n)
- **应用**: 多目标资源分配、优先级处理
- **关键特性**:
  - 支持最小分配保证
  - 按优先级优化分配
  - 剩余资源再分配

#### 背包问题优化
- **算法**: 动态规划
- **复杂度**: O(nW)，n为物品数量，W为容量
- **应用**: 资源打包、库存优化
- **优化策略**:
  - 贪心预处理
  - 空间优化
  - 并行计算

### ⚔️ 战斗系统算法

#### 伤害计算公式
- **基础伤害**: `攻击力 * (1 + 等级加成)`
- **防御减免**: `防御力 * (1 + 等级加成)`
- **类型相克**: 基于单位类型的伤害倍率
- **地形加成**: 攻击方和防御方地形修正
- **特殊效果**: 暴击、侧翼攻击、天气影响

#### 战斗结果预测
- **算法**: 基于统计的概率计算
- **复杂度**: O(单位数量²)
- **应用**: 战术决策支持
- **预测因子**: 兵种组成、地形优势、等级差异

### 🏛️ 经济系统算法

#### 供需平衡价格模型
- **公式**: `价格 = 基础价格 * (需求/供给)^弹性系数`
- **弹性系数**: 通常在0.3-0.8之间
- **动态调整**: 根据市场供需实时调整

#### 贸易路线优化
- **算法**: 比较优势分析
- **复杂度**: O(商品数量)
- **利润计算**: `(售价 - 进价 - 运输成本) * 数量`
- **优化目标**: 最大化总利润

#### 建筑生产优化
- **算法**: 投资回报率(ROI)分析
- **复杂度**: O(建筑数量)
- **ROI计算**: `总收益 / 总成本`
- **决策因素**: 生产效率、资源消耗、建造成本

## 算法实现示例

### 路径寻找使用示例

```typescript
// 创建游戏地图
const gameMap = new GameMap(20, 20);

// 设置地形
gameMap.setTerrain(5, 5, TerrainType.MOUNTAIN);
gameMap.setTerrain(10, 10, TerrainType.FOREST);

// 寻找路径
const path = AStarPathfinder.findPath(
  gameMap,
  0, 0,      // 起点
  15, 15,    // 终点
  UnitType.INFANTRY  // 单位类型
);

if (path) {
  console.log(`找到路径，长度: ${path.length}`);
} else {
  console.log('无法到达目标');
}
```

### AI状态机使用示例

```typescript
// 创建状态机
const fsm = new FiniteStateMachine('patrol');

// 添加状态
fsm.addState('patrol', {
  enter: () => console.log('开始巡逻'),
  update: (deltaTime) => {
    // 巡逻逻辑
  }
});

fsm.addState('combat', {
  enter: () => console.log('进入战斗'),
  update: (deltaTime) => {
    // 战斗逻辑
  }
});

// 添加转换条件
fsm.addTransition('patrol', 'combat', () => {
  return enemyDetected(); // 检测到敌人
});

// 更新状态机
fsm.update(deltaTime);
```

### 资源优化使用示例

```typescript
// 定义资源需求
const requirements = [
  { resource: 'food', amount: 100, priority: 10, minAllocation: 20 },
  { resource: 'wood', amount: 80, priority: 8, minAllocation: 15 },
  { resource: 'iron', amount: 50, priority: 9, minAllocation: 10 }
];

// 优化分配
const allocation = ResourceOptimizer.optimizeResourceAllocation(
  { food: 200, wood: 150, iron: 100 },
  requirements
);

console.log('优化后的分配:', allocation);
```

## 性能优化建议

### 1. 空间分区优化
- 使用四叉树或八叉树管理单位
- 减少碰撞检测计算量
- 支持大规模场景渲染

### 2. 对象池管理
- 重用频繁创建销毁的对象
- 减少垃圾回收压力
- 提高内存使用效率

### 3. 多线程处理
- AI计算分离到工作线程
- 路径寻找异步处理
- 物理模拟并行计算

### 4. 缓存策略
- 缓存计算结果
- 使用LRU缓存算法
- 预计算常用路径

### 5. LOD系统
- 根据距离调整渲染细节
- 分层AI决策复杂度
- 动态资源分配

## 技术发展趋势

### 程序化生成
- **地形生成**: 使用柏林噪声生成自然地形
- **关卡设计**: 基于规则的程序化内容生成
- **故事生成**: 动态事件和情节生成

### 机器学习AI
- **强化学习**: 训练智能AI对手
- **神经网络**: 复杂决策模式识别
- **行为预测**: 玩家行为模式分析

### 云游戏技术
- **分布式计算**: 云端AI处理
- **实时同步**: 低延迟状态同步
- **负载均衡**: 动态服务器分配

## 测试覆盖

### 路径寻找测试
- ✅ 基本路径寻找
- ✅ 地形阻挡处理
- ✅ 边界情况测试
- ✅ 性能压力测试

### AI系统测试
- ✅ 状态机转换
- ✅ 行为树执行
- ✅ 决策正确性
- ✅ 边界条件处理

### 战斗系统测试
- ✅ 伤害计算准确性
- ✅ 类型相克效果
- ✅ 特殊效果触发
- ✅ 大规模战斗性能

### 经济系统测试
- ✅ 价格平衡算法
- ✅ 贸易利润计算
- ✅ 生产优化
- ✅ 市场动态调整

## 总结

SLG游戏算法设计需要平衡复杂度和性能。核心原则包括：

1. **模块化设计**: 每个算法独立实现，便于维护和扩展
2. **性能优先**: 使用高效算法处理大规模数据
3. **可扩展性**: 支持动态内容和玩法扩展
4. **平衡性**: 确保算法结果符合游戏平衡需求
5. **用户体验**: 算法决策要符合玩家预期

通过合理运用这些算法，可以创造出丰富、平衡、有深度的SLG游戏体验。
