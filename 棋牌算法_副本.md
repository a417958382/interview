## ğŸ¯ æ£‹ç‰Œåšå½©æ¸¸æˆä¸­çš„ç»å…¸ç®—æ³•ä¸æ•°æ®ç»“æ„

### 1. å®Œå…¨ä¿¡æ¯åšå¼ˆç®—æ³• â™Ÿï¸

#### **Minimaxç®—æ³•ï¼ˆæå°æå¤§ç®—æ³•ï¼‰**

**ä½¿ç”¨åœºæ™¯**ï¼š
- **è±¡æ£‹/å›½é™…è±¡æ£‹**ï¼šè®¡ç®—æœ€ä½³èµ°å­
- **è·³æ£‹**ï¼šå±€é¢è¯„ä¼°
- **äº”å­æ£‹**ï¼šèƒœè´Ÿåˆ¤æ–­
- **äº•å­—æ£‹**ï¼šå®Œç¾æ¸¸æˆ

**æ ¸å¿ƒæ€è·¯**ï¼š
```typescript
// å‡è®¾MAXç©å®¶æƒ³è¦æœ€å¤§åŒ–åˆ†æ•°ï¼ŒMINç©å®¶æƒ³è¦æœ€å°åŒ–åˆ†æ•°
interface GameState {
    board: number[][];
    currentPlayer: 'MAX' | 'MIN';
    depth: number;
}

class MinimaxAlgorithm {
    private maxDepth = 6;                    // æœç´¢æ·±åº¦é™åˆ¶
    private evaluationCache: Map<string, number>; // å“ˆå¸Œè¡¨ç¼“å­˜
    
    minimax(state: GameState, depth: number, isMaximizing: boolean): number {
        // é€’å½’ç»ˆæ­¢æ¡ä»¶
        if (depth === 0 || this.isGameOver(state)) {
            return this.evaluate(state);
        }
        
        const stateKey = this.encodeState(state);
        if (this.evaluationCache.has(stateKey)) {
            return this.evaluationCache.get(stateKey)!;
        }
        
        let bestValue: number;
        
        if (isMaximizing) {
            bestValue = -Infinity;
            const moves = this.generateMoves(state);
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const value = this.minimax(newState, depth - 1, false);
                bestValue = Math.max(bestValue, value);
            }
        } else {
            bestValue = Infinity;
            const moves = this.generateMoves(state);
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const value = this.minimax(newState, depth - 1, true);
                bestValue = Math.min(bestValue, value);
            }
        }
        
        this.evaluationCache.set(stateKey, bestValue);
        return bestValue;
    }
    
    // å±€é¢è¯„ä¼°å‡½æ•°ï¼ˆè±¡æ£‹ä¾‹å­ï¼‰
    evaluate(state: GameState): number {
        let score = 0;
        
        // 1. æ£‹å­ä»·å€¼ç»Ÿè®¡
        const pieceValues = { è½¦: 10, é©¬: 5, ç‚®: 5, å…µ: 1, å°†: 1000 };
        
        // 2. ä½ç½®ä»·å€¼ï¼ˆæ§åˆ¶ä¸­å¿ƒæ›´æœ‰ä»·å€¼ï¼‰
        const positionBonus = this.calculatePositionBonus(state.board);
        
        // 3. å®‰å…¨æ€§è¯„ä¼°ï¼ˆå°†å†›ã€è¢«å°†å†›ç­‰ï¼‰
        const safetyScore = this.calculateSafety(state.board);
        
        return score + positionBonus + safetyScore;
    }
}

console.log("Minimaxæ ¸å¿ƒæ•°æ®ç»“æ„:");
console.log("ğŸŒ³ é€’å½’è°ƒç”¨æ ˆ: æ·±åº¦ä¼˜å…ˆæœç´¢");
console.log("ğŸ—‚ï¸ å“ˆå¸Œè¡¨: çŠ¶æ€è¯„ä¼°å€¼ç¼“å­˜");
console.log("ğŸ“Š äºŒç»´æ•°ç»„: æ£‹ç›˜çŠ¶æ€è¡¨ç¤º");
console.log("â±ï¸ æ—¶é—´å¤æ‚åº¦: O(b^d) b=åˆ†æ”¯å› å­, d=æ·±åº¦");
```

#### **Alpha-Betaå‰ªæä¼˜åŒ–**

**ä½¿ç”¨åœºæ™¯**ï¼šä¼˜åŒ–Minimaxç®—æ³•ï¼Œå¤§å¹…å‡å°‘æœç´¢èŠ‚ç‚¹

**æ ¸å¿ƒæ€è·¯**ï¼š
```typescript
class AlphaBetaPruning {
    alphaBeta(state: GameState, depth: number, alpha: number, beta: number, isMaximizing: boolean): number {
        if (depth === 0 || this.isGameOver(state)) {
            return this.evaluate(state);
        }
        
        if (isMaximizing) {
            let maxEval = -Infinity;
            const moves = this.generateMoves(state);
            
            // ç§»åŠ¨æ’åºä¼˜åŒ–ï¼šä¼˜å…ˆæœç´¢å¯èƒ½æ›´å¥½çš„ç§»åŠ¨
            moves.sort((a, b) => this.moveOrderingHeuristic(b) - this.moveOrderingHeuristic(a));
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const eval = this.alphaBeta(newState, depth - 1, alpha, beta, false);
                
                maxEval = Math.max(maxEval, eval);
                alpha = Math.max(alpha, eval);
                
                // Betaå‰ªæï¼šå¦‚æœÎ± â‰¥ Î²ï¼Œåç»­åˆ†æ”¯ä¸éœ€è¦æœç´¢
                if (beta <= alpha) {
                    console.log(`å‰ªæå‘ç”Ÿï¼šÎ±=${alpha}, Î²=${beta}`);
                    break; // å‰ªæï¼
                }
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            const moves = this.generateMoves(state);
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const eval = this.alphaBeta(newState, depth - 1, alpha, beta, true);
                
                minEval = Math.min(minEval, eval);
                beta = Math.min(beta, eval);
                
                // Alphaå‰ªæ
                if (beta <= alpha) {
                    break; // å‰ªæï¼
                }
            }
            return minEval;
        }
    }
    
    // ç§»åŠ¨æ’åºå¯å‘ï¼šå†å²è¡¨è®°å½•å¥½çš„ç§»åŠ¨
    private historyTable: Map<string, number> = new Map();
    
    moveOrderingHeuristic(move: Move): number {
        // 1. å†å²å¯å‘ï¼šä¹‹å‰å¯¼è‡´Betaå‰ªæçš„ç§»åŠ¨ä¼˜å…ˆ
        const historyScore = this.historyTable.get(move.toString()) || 0;
        
        // 2. æ•è·å¯å‘ï¼šåƒå­ç§»åŠ¨ä¼˜å…ˆ
        const captureScore = move.isCapture ? 1000 : 0;
        
        // 3. ä¸­å¿ƒæ§åˆ¶ï¼šæ§åˆ¶ä¸­å¿ƒçš„ç§»åŠ¨ä¼˜å…ˆ
        const centerScore = this.calculateCenterControl(move);
        
        return historyScore + captureScore + centerScore;
    }
}

console.log("Alpha-Betaå‰ªææ•ˆæœ:");
console.log("âœ‚ï¸ ç†æƒ³æƒ…å†µ: æœç´¢èŠ‚ç‚¹å‡å°‘åˆ° O(b^(d/2))");
console.log("ğŸ“ˆ å¹³å‡æƒ…å†µ: å‡å°‘50-90%çš„èŠ‚ç‚¹");
console.log("ğŸ¯ å…³é”®: ç§»åŠ¨æ’åºè´¨é‡å½±å“å‰ªææ•ˆæœ");
```

### 2. ç½®æ¢è¡¨ï¼ˆTransposition Tableï¼‰ğŸ—‚ï¸

**ä½¿ç”¨åœºæ™¯**ï¼š
- **è±¡æ£‹å¼•æ“**ï¼šé¿å…é‡å¤è®¡ç®—ç›¸åŒå±€é¢
- **å›´æ£‹AI**ï¼šç¼“å­˜å·²è®¡ç®—çš„ä½ç½®è¯„ä¼°
- **è·³æ£‹ç¨‹åº**ï¼šæé«˜æœç´¢æ•ˆç‡

**æ ¸å¿ƒæ€è·¯**ï¼š
```typescript
interface TranspositionEntry {
    zobristHash: bigint;         // Zobristå“ˆå¸Œå€¼
    depth: number;               // æœç´¢æ·±åº¦
    nodeType: 'EXACT' | 'LOWER_BOUND' | 'UPPER_BOUND';
    bestMove: Move | null;       // æœ€ä½³ç§»åŠ¨
    evaluation: number;          // è¯„ä¼°å€¼
    age: number;                // ç”Ÿæˆæ—¶é—´ï¼ˆç”¨äºæ›¿æ¢ç­–ç•¥ï¼‰
}

class TranspositionTable {
    private table: (TranspositionEntry | null)[];  // å“ˆå¸Œè¡¨ä¸»ä½“
    private size: number;                           // è¡¨å¤§å°
    private zobristKeys: bigint[][][];              // Zobristéšæœºæ•°è¡¨
    
    constructor(sizeInMB: number = 64) {
        this.size = (sizeInMB * 1024 * 1024) / 32; // æ¯ä¸ªæ¡ç›®çº¦32å­—èŠ‚
        this.table = new Array(this.size).fill(null);
        this.initializeZobristKeys();
    }
    
    // åˆå§‹åŒ–Zobristå“ˆå¸Œæ‰€éœ€çš„éšæœºæ•°
    initializeZobristKeys(): void {
        // ä¸ºæ¯ä¸ªä½ç½®ã€æ¯ç§æ£‹å­ç”Ÿæˆå”¯ä¸€çš„64ä½éšæœºæ•°
        this.zobristKeys = [];
        
        for (let row = 0; row < 10; row++) {
            this.zobristKeys[row] = [];
            for (let col = 0; col < 9; col++) {
                this.zobristKeys[row][col] = [];
                for (let piece = 0; piece < 14; piece++) { // 14ç§ä¸åŒæ£‹å­
                    this.zobristKeys[row][col][piece] = this.randomBigInt();
                }
            }
        }
    }
    
    // è®¡ç®—å½“å‰å±€é¢çš„Zobristå“ˆå¸Œå€¼
    calculateZobristHash(board: number[][]): bigint {
        let hash = 0n;
        
        for (let row = 0; row < board.length; row++) {
            for (let col = 0; col < board[row].length; col++) {
                const piece = board[row][col];
                if (piece !== 0) { // æœ‰æ£‹å­
                    hash ^= this.zobristKeys[row][col][piece];
                }
            }
        }
        
        return hash;
    }
    
    // å¢é‡æ›´æ–°å“ˆå¸Œå€¼ï¼ˆç§»åŠ¨æ£‹å­æ—¶ï¼‰
    updateZobristHash(currentHash: bigint, move: Move): bigint {
        let newHash = currentHash;
        
        // ç§»é™¤åŸä½ç½®çš„æ£‹å­
        newHash ^= this.zobristKeys[move.from.row][move.from.col][move.piece];
        
        // å¦‚æœåƒå­ï¼Œç§»é™¤è¢«åƒçš„æ£‹å­
        if (move.capturedPiece) {
            newHash ^= this.zobristKeys[move.to.row][move.to.col][move.capturedPiece];
        }
        
        // æ·»åŠ æ–°ä½ç½®çš„æ£‹å­
        newHash ^= this.zobristKeys[move.to.row][move.to.col][move.piece];
        
        return newHash;
    }
    
    // æŸ¥æ‰¾ç½®æ¢è¡¨
    probe(hash: bigint, depth: number): TranspositionEntry | null {
        const index = Number(hash % BigInt(this.size));
        const entry = this.table[index];
        
        if (entry && entry.zobristHash === hash && entry.depth >= depth) {
            return entry;
        }
        
        return null;
    }
    
    // å­˜å‚¨åˆ°ç½®æ¢è¡¨
    store(hash: bigint, depth: number, nodeType: string, evaluation: number, bestMove: Move | null): void {
        const index = Number(hash % BigInt(this.size));
        const currentEntry = this.table[index];
        
        // æ›¿æ¢ç­–ç•¥ï¼šæ€»æ˜¯æ›¿æ¢ï¼ˆç®€å•ç­–ç•¥ï¼‰
        // æ›´å¤æ‚çš„ç­–ç•¥ï¼šæ·±åº¦ä¼˜å…ˆã€å¹´é¾„ä¼˜å…ˆç­‰
        if (!currentEntry || currentEntry.depth <= depth) {
            this.table[index] = {
                zobristHash: hash,
                depth: depth,
                nodeType: nodeType as any,
                evaluation: evaluation,
                bestMove: bestMove,
                age: Date.now()
            };
        }
    }
    
    private randomBigInt(): bigint {
        // ç”Ÿæˆ64ä½éšæœºæ•°
        const high = BigInt(Math.floor(Math.random() * 0x100000000));
        const low = BigInt(Math.floor(Math.random() * 0x100000000));
        return (high << 32n) | low;
    }
}

console.log("ç½®æ¢è¡¨æ ¸å¿ƒæ•°æ®ç»“æ„:");
console.log("ğŸ—‚ï¸ å“ˆå¸Œè¡¨: å¿«é€ŸæŸ¥æ‰¾O(1)");
console.log("ğŸ² Zobristå“ˆå¸Œ: å±€é¢å”¯ä¸€æ ‡è¯†");
console.log("ğŸ”„ å¢é‡æ›´æ–°: é¿å…é‡å¤è®¡ç®—å“ˆå¸Œ");
console.log("ğŸ’¾ æ›¿æ¢ç­–ç•¥: å†…å­˜ç®¡ç†å…³é”®");
```

### 3. è¿­ä»£åŠ æ·±æœç´¢ ğŸ”„

**ä½¿ç”¨åœºæ™¯**ï¼š
- **å®æ—¶å¯¹å¼ˆ**ï¼šé™å®šæ€è€ƒæ—¶é—´
- **åœ¨çº¿æ¸¸æˆ**ï¼šé¿å…è¶…æ—¶
- **ç§»åŠ¨è®¾å¤‡**ï¼šè®¡ç®—èµ„æºæœ‰é™

**æ ¸å¿ƒæ€è·¯**ï¼š
```typescript
class IterativeDeepeningSearch {
    private timeLimit: number;               // æ—¶é—´é™åˆ¶(æ¯«ç§’)
    private startTime: number;               // æœç´¢å¼€å§‹æ—¶é—´
    private bestMoveHistory: Move[];         // å†å²æœ€ä½³ç§»åŠ¨
    private killerMoves: Move[][];           // æ€æ‰‹å¯å‘è¡¨
    
    constructor(timeLimitMs: number = 5000) {
        this.timeLimit = timeLimitMs;
        this.killerMoves = Array(20).fill(null).map(() => []);
    }
    
    search(state: GameState): Move {
        this.startTime = Date.now();
        let bestMove: Move | null = null;
        let bestValue = -Infinity;
        
        // ä»æ·±åº¦1å¼€å§‹ï¼Œé€æ¸å¢åŠ æœç´¢æ·±åº¦
        for (let depth = 1; depth <= 20; depth++) {
            
            // æ£€æŸ¥æ—¶é—´æ˜¯å¦ç”¨å®Œ
            if (this.isTimeUp()) {
                console.log(`æ—¶é—´ç”¨å®Œï¼Œåœæ­¢åœ¨æ·±åº¦ ${depth - 1}`);
                break;
            }
            
            console.log(`å¼€å§‹æœç´¢æ·±åº¦ ${depth}`);
            
            try {
                const result = this.alphaBetaWithTimeControl(state, depth, -Infinity, Infinity, true);
                
                if (result.move) {
                    bestMove = result.move;
                    bestValue = result.value;
                    console.log(`æ·±åº¦ ${depth}: æœ€ä½³ç§»åŠ¨ ${bestMove.toString()}, è¯„ä¼°å€¼ ${bestValue}`);
                }
                
                // å¦‚æœæ‰¾åˆ°å¿…èƒœ/å¿…è´¥ä½ç½®ï¼Œå¯ä»¥æå‰åœæ­¢
                if (Math.abs(bestValue) > 10000) {
                    console.log(`æ‰¾åˆ°ç¡®å®šç»“æœï¼Œæå‰åœæ­¢æœç´¢`);
                    break;
                }
                
            } catch (timeoutError) {
                console.log(`æ·±åº¦ ${depth} æœç´¢è¢«æ—¶é—´ä¸­æ–­`);
                break;
            }
        }
        
        return bestMove!;
    }
    
    alphaBetaWithTimeControl(state: GameState, depth: number, alpha: number, beta: number, isMaximizing: boolean): {value: number, move: Move | null} {
        // æ—¶é—´æ£€æŸ¥
        if (this.isTimeUp()) {
            throw new Error('Time limit exceeded');
        }
        
        if (depth === 0 || this.isGameOver(state)) {
            return { value: this.evaluate(state), move: null };
        }
        
        const moves = this.generateMoves(state);
        
        // ç§»åŠ¨æ’åºï¼šä½¿ç”¨å†å²è¡¨å’Œæ€æ‰‹å¯å‘
        this.orderMoves(moves, depth);
        
        let bestMove: Move | null = null;
        
        if (isMaximizing) {
            let maxEval = -Infinity;
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const result = this.alphaBetaWithTimeControl(newState, depth - 1, alpha, beta, false);
                
                if (result.value > maxEval) {
                    maxEval = result.value;
                    bestMove = move;
                }
                
                alpha = Math.max(alpha, result.value);
                
                if (beta <= alpha) {
                    // è®°å½•æ€æ‰‹ç§»åŠ¨
                    this.updateKillerMoves(move, depth);
                    break;
                }
            }
            
            return { value: maxEval, move: bestMove };
        } else {
            let minEval = Infinity;
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const result = this.alphaBetaWithTimeControl(newState, depth - 1, alpha, beta, true);
                
                if (result.value < minEval) {
                    minEval = result.value;
                    bestMove = move;
                }
                
                beta = Math.min(beta, result.value);
                
                if (beta <= alpha) {
                    this.updateKillerMoves(move, depth);
                    break;
                }
            }
            
            return { value: minEval, move: bestMove };
        }
    }
    
    // ç§»åŠ¨æ’åºï¼šæé«˜å‰ªææ•ˆç‡
    orderMoves(moves: Move[], depth: number): void {
        moves.sort((a, b) => {
            // 1. å†å²æœ€ä½³ç§»åŠ¨ä¼˜å…ˆ
            if (this.bestMoveHistory.includes(a)) return -1;
            if (this.bestMoveHistory.includes(b)) return 1;
            
            // 2. æ€æ‰‹ç§»åŠ¨ä¼˜å…ˆ
            if (this.killerMoves[depth].includes(a)) return -1;
            if (this.killerMoves[depth].includes(b)) return 1;
            
            // 3. æ•è·ç§»åŠ¨ä¼˜å…ˆï¼ŒæŒ‰ä»·å€¼æ’åº
            if (a.isCapture && !b.isCapture) return -1;
            if (!a.isCapture && b.isCapture) return 1;
            if (a.isCapture && b.isCapture) {
                return (b.capturedPieceValue || 0) - (a.capturedPieceValue || 0);
            }
            
            return 0;
        });
    }
    
    // æ›´æ–°æ€æ‰‹ç§»åŠ¨è¡¨
    updateKillerMoves(move: Move, depth: number): void {
        const killers = this.killerMoves[depth];
        
        // å¦‚æœä¸åœ¨æ€æ‰‹è¡¨ä¸­ï¼Œæ·»åŠ åˆ°å‰é¢
        if (!killers.includes(move)) {
            killers.unshift(move);
            
            // ä¿æŒè¡¨å¤§å°ï¼ˆé€šå¸¸2ä¸ªæ€æ‰‹ç§»åŠ¨ï¼‰
            if (killers.length > 2) {
                killers.pop();
            }
        }
    }
    
    isTimeUp(): boolean {
        return Date.now() - this.startTime > this.timeLimit;
    }
}

console.log("è¿­ä»£åŠ æ·±æœç´¢ç‰¹ç‚¹:");
console.log("â±ï¸ ä»»ä½•æ—¶å€™å¯åœæ­¢: æ—¶é—´æ§åˆ¶å‹å¥½");
console.log("ğŸ“ˆ æ¸è¿›å¼æ”¹è¿›: æµ…å±‚ä¸ºæ·±å±‚æä¾›å¯å‘");
console.log("ğŸ¯ ç§»åŠ¨æ’åº: å†å²è¡¨+æ€æ‰‹å¯å‘æé«˜æ•ˆç‡");
console.log("ğŸ’¾ å†…å­˜å‹å¥½: ä¸éœ€è¦å­˜å‚¨æ•´ä¸ªæœç´¢æ ‘");
```

### 4. æ¦‚ç‡ä¸æœŸæœ›å€¼è®¡ç®— ğŸ²

#### **å¾·å·æ‰‘å…‹ç‰ŒåŠ›è®¡ç®—**

**ä½¿ç”¨åœºæ™¯**ï¼š
- **å¾·å·æ‰‘å…‹**ï¼šè®¡ç®—èƒœç‡å’ŒæœŸæœ›æ”¶ç›Š
- **æ¢­å“ˆæ¸¸æˆ**ï¼šç‰Œå‹æ¦‚ç‡åˆ†æ
- **21ç‚¹**ï¼šå‰©ä½™ç‰Œå¼ æ¦‚ç‡

**æ ¸å¿ƒæ€è·¯**ï¼š
```typescript
interface Card {
    suit: 'hearts' | 'diamonds' | 'clubs' | 'spades';
    rank: number; // 1-13 (A,2,3...J,Q,K)
}

interface HandStrength {
    handType: string;
    strength: number;     // ç›¸å¯¹å¼ºåº¦å€¼
    probability: number;  // å½¢æˆæ¦‚ç‡
}

class PokerCalculator {
    private deck: Card[];                    // å®Œæ•´ç‰Œç»„
    private handRankings: Map<string, number>; // ç‰Œå‹æ’å
    private combinationCache: Map<string, number>; // ç»„åˆæ•°ç¼“å­˜
    
    constructor() {
        this.initializeDeck();
        this.initializeHandRankings();
        this.combinationCache = new Map();
    }
    
    // è®¡ç®—èƒœç‡ï¼ˆè’™ç‰¹å¡ç½—æ–¹æ³•ï¼‰
    calculateWinProbability(myCards: Card[], communityCards: Card[], opponents: number, simulations: number = 10000): number {
        let wins = 0;
        const usedCards = [...myCards, ...communityCards];
        
        for (let sim = 0; sim < simulations; sim++) {
            // éšæœºå‘å‰©ä½™çš„ç‰Œ
            const availableCards = this.getAvailableCards(usedCards);
            const shuffled = this.shuffle(availableCards);
            
            // å®Œæˆæˆ‘çš„æ‰‹ç‰Œ
            const myFinalCards = [...myCards, ...communityCards];
            const remainingCommunity = 5 - communityCards.length;
            
            for (let i = 0; i < remainingCommunity; i++) {
                myFinalCards.push(shuffled[i]);
            }
            
            const myBestHand = this.getBestHand(myFinalCards);
            let iWin = true;
            
            // æ¨¡æ‹Ÿå¯¹æ‰‹çš„ç‰Œ
            let cardIndex = remainingCommunity;
            for (let opp = 0; opp < opponents; opp++) {
                const oppCards = [shuffled[cardIndex], shuffled[cardIndex + 1]];
                const oppFinalCards = [...oppCards, ...communityCards];
                
                // æ·»åŠ å‰©ä½™å…¬å…±ç‰Œ
                for (let i = 0; i < remainingCommunity; i++) {
                    oppFinalCards.push(shuffled[i]);
                }
                
                const oppBestHand = this.getBestHand(oppFinalCards);
                
                if (this.compareHands(oppBestHand, myBestHand) > 0) {
                    iWin = false;
                    break;
                }
                
                cardIndex += 2;
            }
            
            if (iWin) wins++;
        }
        
        return wins / simulations;
    }
    
    // è®¡ç®—ç‰Œå‹æ¦‚ç‡ï¼ˆç²¾ç¡®è®¡ç®—ï¼‰
    calculateHandProbabilities(cards: Card[]): Map<string, number> {
        const probabilities = new Map<string, number>();
        
        if (cards.length === 2) {
            // èµ·æ‰‹ç‰Œï¼Œè®¡ç®—åˆ°æ²³ç‰Œçš„å„ç§ç‰Œå‹æ¦‚ç‡
            const totalCombinations = this.combination(50, 5); // C(50,5)
            
            // è®¡ç®—å„ç§ç‰Œå‹çš„ç»„åˆæ•°
            const straightFlushCombos = this.countStraightFlushCombinations(cards);
            const fourKindCombos = this.countFourOfAKindCombinations(cards);
            const fullHouseCombos = this.countFullHouseCombinations(cards);
            // ... å…¶ä»–ç‰Œå‹
            
            probabilities.set('StraightFlush', straightFlushCombos / totalCombinations);
            probabilities.set('FourOfAKind', fourKindCombos / totalCombinations);
            probabilities.set('FullHouse', fullHouseCombos / totalCombinations);
        }
        
        return probabilities;
    }
    
    // è®¡ç®—æœŸæœ›æ”¶ç›Š
    calculateExpectedValue(myCards: Card[], communityCards: Card[], potSize: number, betSize: number, opponents: number): number {
        const winProbability = this.calculateWinProbability(myCards, communityCards, opponents);
        const loseProbability = 1 - winProbability;
        
        // è·Ÿæ³¨çš„æœŸæœ›æ”¶ç›Š
        const callEV = winProbability * potSize - loseProbability * betSize;
        
        // å¼ƒç‰Œçš„æœŸæœ›æ”¶ç›Šï¼ˆæ€»æ˜¯0ï¼‰
        const foldEV = 0;
        
        console.log(`èƒœç‡: ${(winProbability * 100).toFixed(2)}%`);
        console.log(`è·Ÿæ³¨æœŸæœ›æ”¶ç›Š: ${callEV.toFixed(2)}`);
        console.log(`å»ºè®®æ“ä½œ: ${callEV > foldEV ? 'è·Ÿæ³¨' : 'å¼ƒç‰Œ'}`);
        
        return Math.max(callEV, foldEV);
    }
    
    // ç»„åˆæ•°è®¡ç®—ï¼ˆå¸¦ç¼“å­˜ï¼‰
    combination(n: number, r: number): number {
        const key = `${n},${r}`;
        if (this.combinationCache.has(key)) {
            return this.combinationCache.get(key)!;
        }
        
        if (r > n || r < 0) return 0;
        if (r === 0 || r === n) return 1;
        
        let result = 1;
        for (let i = 0; i < Math.min(r, n - r); i++) {
            result = result * (n - i) / (i + 1);
        }
        
        this.combinationCache.set(key, result);
        return result;
    }
    
    // è·å–æœ€ä½³5å¼ ç‰Œç»„åˆ
    getBestHand(cards: Card[]): HandStrength {
        if (cards.length < 5) throw new Error('Need at least 5 cards');
        
        const allCombinations = this.generateCombinations(cards, 5);
        let bestHand: HandStrength | null = null;
        
        for (const combination of allCombinations) {
            const handStrength = this.evaluateHand(combination);
            
            if (!bestHand || handStrength.strength > bestHand.strength) {
                bestHand = handStrength;
            }
        }
        
        return bestHand!;
    }
    
    // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„5å¼ ç‰Œç»„åˆ
    generateCombinations(cards: Card[], size: number): Card[][] {
        if (size === 1) return cards.map(card => [card]);
        
        const combinations: Card[][] = [];
        
        for (let i = 0; i <= cards.length - size; i++) {
            const head = cards[i];
            const tailCombinations = this.generateCombinations(cards.slice(i + 1), size - 1);
            
            for (const tail of tailCombinations) {
                combinations.push([head, ...tail]);
            }
        }
        
        return combinations;
    }
    
    private shuffle(array: Card[]): Card[] {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }
}

console.log("æ‰‘å…‹è®¡ç®—æ ¸å¿ƒæ•°æ®ç»“æ„:");
console.log("ğŸƒ æ•°ç»„: å­˜å‚¨ç‰Œç»„å’Œæ‰‹ç‰Œ");
console.log("ğŸ—‚ï¸ å“ˆå¸Œè¡¨: ç¼“å­˜ç»„åˆæ•°è®¡ç®—ç»“æœ");
console.log("ğŸ² æ¦‚ç‡è®¡ç®—: æ’åˆ—ç»„åˆæ•°å­¦");
console.log("ğŸ”„ è’™ç‰¹å¡ç½—: å¤§é‡éšæœºæ¨¡æ‹Ÿ");
```

### 5. å›æº¯ç®—æ³•ï¼ˆæ•°ç‹¬/å¡«å­—æ¸¸æˆï¼‰ğŸ§©

**ä½¿ç”¨åœºæ™¯**ï¼š
- **æ•°ç‹¬æ¸¸æˆ**ï¼šæ±‚è§£å’Œç”Ÿæˆ
- **å¡«å­—æ¸¸æˆ**ï¼šå•è¯æ”¾ç½®
- **æ‹¼å›¾æ¸¸æˆ**ï¼šç¢ç‰‡åŒ¹é…
- **Nçš‡åé—®é¢˜**ï¼šæ£‹ç›˜æ”¾ç½®

**æ ¸å¿ƒæ€è·¯**ï¼š
```typescript
class SudokuSolver {
    private grid: number[][];                // 9x9æ•°ç‹¬ç½‘æ ¼
    private possibleValues: Set<number>[][]; // æ¯ä¸ªæ ¼å­çš„å¯èƒ½å€¼
    private rowUsed: boolean[][];            // è¡Œä½¿ç”¨æƒ…å†µ
    private colUsed: boolean[][];            // åˆ—ä½¿ç”¨æƒ…å†µ
    private boxUsed: boolean[][];            // 3x3æ–¹æ ¼ä½¿ç”¨æƒ…å†µ
    
    constructor(initialGrid: number[][]) {
        this.grid = initialGrid.map(row => [...row]);
        this.initializeConstraints();
    }
    
    // åˆå§‹åŒ–çº¦æŸæ¡ä»¶
    initializeConstraints(): void {
        this.rowUsed = Array(9).fill(null).map(() => Array(10).fill(false));
        this.colUsed = Array(9).fill(null).map(() => Array(10).fill(false));
        this.boxUsed = Array(9).fill(null).map(() => Array(10).fill(false));
        this.possibleValues = Array(9).fill(null).map(() => 
            Array(9).fill(null).map(() => new Set<number>())
        );
        
        // æ ‡è®°å·²å¡«å…¥çš„æ•°å­—
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const num = this.grid[row][col];
                if (num !== 0) {
                    this.markUsed(row, col, num);
                } else {
                    // è®¡ç®—å¯èƒ½çš„å€¼
                    this.updatePossibleValues(row, col);
                }
            }
        }
    }
    
    // å›æº¯æ±‚è§£
    solve(): boolean {
        // æ‰¾åˆ°æ‹¥æœ‰æœ€å°‘å¯èƒ½å€¼çš„ç©ºæ ¼ï¼ˆæœ€çº¦æŸä¼˜å…ˆå¯å‘ï¼‰
        const cell = this.findMostConstrainedCell();
        
        if (!cell) {
            return true; // æ‰€æœ‰æ ¼å­éƒ½å¡«æ»¡äº†
        }
        
        const { row, col } = cell;
        const possibleNums = Array.from(this.possibleValues[row][col]);
        
        // å°è¯•æ¯ä¸ªå¯èƒ½çš„æ•°å­—
        for (const num of possibleNums) {
            if (this.isValid(row, col, num)) {
                // åšé€‰æ‹©
                this.placeNumber(row, col, num);
                
                // é€’å½’è§£å†³
                if (this.solve()) {
                    return true;
                }
                
                // æ’¤é”€é€‰æ‹©ï¼ˆå›æº¯ï¼‰
                this.removeNumber(row, col, num);
            }
        }
        
        return false; // æ— è§£
    }
    
    // æ‰¾åˆ°æœ€å—çº¦æŸçš„ç©ºæ ¼ï¼ˆå¯å‘å¼ä¼˜åŒ–ï¼‰
    findMostConstrainedCell(): {row: number, col: number} | null {
        let minOptions = 10;
        let bestCell: {row: number, col: number} | null = null;
        
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (this.grid[row][col] === 0) {
                    const optionCount = this.possibleValues[row][col].size;
                    
                    if (optionCount < minOptions) {
                        minOptions = optionCount;
                        bestCell = { row, col };
                        
                        // å¦‚æœåªæœ‰ä¸€ä¸ªé€‰æ‹©ï¼Œç«‹å³è¿”å›
                        if (minOptions === 1) {
                            return bestCell;
                        }
                    }
                }
            }
        }
        
        return bestCell;
    }
    
    // æ”¾ç½®æ•°å­—
    placeNumber(row: number, col: number, num: number): void {
        this.grid[row][col] = num;
        this.markUsed(row, col, num);
        
        // æ›´æ–°ç›¸å…³æ ¼å­çš„å¯èƒ½å€¼
        this.propagateConstraints(row, col, num, 'remove');
    }
    
    // ç§»é™¤æ•°å­—ï¼ˆå›æº¯æ—¶ï¼‰
    removeNumber(row: number, col: number, num: number): void {
        this.grid[row][col] = 0;
        this.markUnused(row, col, num);
        
        // æ¢å¤ç›¸å…³æ ¼å­çš„å¯èƒ½å€¼
        this.propagateConstraints(row, col, num, 'add');
    }
    
    // çº¦æŸä¼ æ’­ï¼šæ›´æ–°ç›¸å…³æ ¼å­çš„å¯èƒ½å€¼
    propagateConstraints(row: number, col: number, num: number, operation: 'add' | 'remove'): void {
        // æ›´æ–°åŒè¡Œçš„æ ¼å­
        for (let c = 0; c < 9; c++) {
            if (c !== col && this.grid[row][c] === 0) {
                if (operation === 'remove') {
                    this.possibleValues[row][c].delete(num);
                } else {
                    if (this.isValid(row, c, num)) {
                        this.possibleValues[row][c].add(num);
                    }
                }
            }
        }
        
        // æ›´æ–°åŒåˆ—çš„æ ¼å­
        for (let r = 0; r < 9; r++) {
            if (r !== row && this.grid[r][col] === 0) {
                if (operation === 'remove') {
                    this.possibleValues[r][col].delete(num);
                } else {
                    if (this.isValid(r, col, num)) {
                        this.possibleValues[r][col].add(num);
                    }
                }
            }
        }
        
        // æ›´æ–°åŒæ–¹æ ¼çš„æ ¼å­
        const boxRow = Math.floor(row / 3) * 3;
        const boxCol = Math.floor(col / 3) * 3;
        
        for (let r = boxRow; r < boxRow + 3; r++) {
            for (let c = boxCol; c < boxCol + 3; c++) {
                if ((r !== row || c !== col) && this.grid[r][c] === 0) {
                    if (operation === 'remove') {
                        this.possibleValues[r][c].delete(num);
                    } else {
                        if (this.isValid(r, c, num)) {
                            this.possibleValues[r][c].add(num);
                        }
                    }
                }
            }
        }
    }
    
    // éªŒè¯æ•°å­—æ”¾ç½®æ˜¯å¦æœ‰æ•ˆ
    isValid(row: number, col: number, num: number): boolean {
        const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
        
        return !this.rowUsed[row][num] && 
               !this.colUsed[col][num] && 
               !this.boxUsed[boxIndex][num];
    }
    
    // æ ‡è®°æ•°å­—ä¸ºå·²ä½¿ç”¨
    markUsed(row: number, col: number, num: number): void {
        const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
        this.rowUsed[row][num] = true;
        this.colUsed[col][num] = true;
        this.boxUsed[boxIndex][num] = true;
    }
    
    // æ ‡è®°æ•°å­—ä¸ºæœªä½¿ç”¨
    markUnused(row: number, col: number, num: number): void {
        const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
        this.rowUsed[row][num] = false;
        this.colUsed[col][num] = false;
        this.boxUsed[boxIndex][num] = false;
    }
    
    // æ›´æ–°å•ä¸ªæ ¼å­çš„å¯èƒ½å€¼
    updatePossibleValues(row: number, col: number): void {
        const possible = new Set<number>();
        
        for (let num = 1; num <= 9; num++) {
            if (this.isValid(row, col, num)) {
                possible.add(num);
            }
        }
        
        this.possibleValues[row][col] = possible;
    }
}

console.log("å›æº¯ç®—æ³•æ ¸å¿ƒæ•°æ®ç»“æ„:");
console.log("ğŸ§© äºŒç»´æ•°ç»„: æ¸¸æˆçŠ¶æ€è¡¨ç¤º");
console.log("âœ… å¸ƒå°”æ•°ç»„: çº¦æŸæ¡ä»¶æ£€æŸ¥");
console.log("ğŸ¯ é›†åˆ(Set): å¯èƒ½å€¼ç»´æŠ¤");
console.log("ğŸ”„ é€’å½’æ ˆ: éšå¼çŠ¶æ€ä¿å­˜");
console.log("âš¡ çº¦æŸä¼ æ’­: å‰ªæä¼˜åŒ–");
```

### 6. åŠ¨æ€è§„åˆ’ï¼ˆåšå½©æ¦‚ç‡è®¡ç®—ï¼‰ğŸ“Š

**ä½¿ç”¨åœºæ™¯**ï¼š
- **ç´¯è¿›å¼å½©ç¥¨**ï¼šä¸­å¥–æ¦‚ç‡è®¡ç®—
- **ä½“è‚²åšå½©**ï¼šä¸²å…³æŠ•æ³¨ä¼˜åŒ–
- **ä¿é™©æ¸¸æˆ**ï¼šé£é™©è¯„ä¼°
- **æŠ•èµ„ç»„åˆæ¸¸æˆ**ï¼šæœ€ä¼˜åˆ†é…

**æ ¸å¿ƒæ€è·¯**ï¼š
```typescript
interface BettingOption {
    id: string;
    winProbability: number;
    winPayout: number;      // è·èƒœæ—¶çš„èµ”ä»˜å€æ•°
    cost: number;           // æŠ•æ³¨æˆæœ¬
}

class DynamicBettingOptimizer {
    private memo: Map<string, number>;       // è®°å¿†åŒ–ç¼“å­˜
    private options: BettingOption[];        // æŠ•æ³¨é€‰é¡¹
    
    constructor(options: BettingOption[]) {
        this.options = options;
        this.memo = new Map();
    }
    
    // åœ¨ç»™å®šé¢„ç®—ä¸‹æœ€å¤§åŒ–æœŸæœ›æ”¶ç›Š
    maximizeExpectedReturn(budget: number, optionsUsed: boolean[] = []): number {
        const key = `${budget},${optionsUsed.join(',')}`;
        
        if (this.memo.has(key)) {
            return this.memo.get(key)!;
        }
        
        if (budget <= 0) {
            return 0;
        }
        
        let maxReturn = 0;
        
        // å°è¯•æ¯ä¸ªå¯ç”¨çš„æŠ•æ³¨é€‰é¡¹
        for (let i = 0; i < this.options.length; i++) {
            if (optionsUsed[i]) continue; // å·²ä½¿ç”¨è¿‡çš„é€‰é¡¹
            
            const option = this.options[i];
            
            if (option.cost <= budget) {
                // é€‰æ‹©è¿™ä¸ªé€‰é¡¹çš„æœŸæœ›æ”¶ç›Š
                const expectedReturn = option.winProbability * option.winPayout * option.cost;
                const remainingBudget = budget - option.cost;
                
                // é€’å½’è®¡ç®—å‰©ä½™é¢„ç®—çš„æœ€ä¼˜æ”¶ç›Š
                const newUsed = [...optionsUsed];
                newUsed[i] = true;
                const futureReturn = this.maximizeExpectedReturn(remainingBudget, newUsed);
                
                const totalReturn = expectedReturn + futureReturn;
                maxReturn = Math.max(maxReturn, totalReturn);
            }
        }
        
        // ä¹Ÿè€ƒè™‘ä¸æŠ•æ³¨ä»»ä½•é€‰é¡¹çš„æƒ…å†µ
        maxReturn = Math.max(maxReturn, 0);
        
        this.memo.set(key, maxReturn);
        return maxReturn;
    }
    
    // è®¡ç®—æœ€ä¼˜æŠ•æ³¨ç»„åˆ
    getOptimalBettingStrategy(budget: number): BettingOption[] {
        const strategy: BettingOption[] = [];
        let remainingBudget = budget;
        const usedOptions = new Array(this.options.length).fill(false);
        
        while (remainingBudget > 0) {
            let bestOption: BettingOption | null = null;
            let bestIndex = -1;
            let bestAdditionalReturn = 0;
            
            // æ‰¾åˆ°èƒ½å¸¦æ¥æœ€å¤§é¢å¤–æ”¶ç›Šçš„é€‰é¡¹
            for (let i = 0; i < this.options.length; i++) {
                if (usedOptions[i] || this.options[i].cost > remainingBudget) {
                    continue;
                }
                
                const option = this.options[i];
                const currentReturn = this.maximizeExpectedReturn(remainingBudget, usedOptions);
                
                // ä¸´æ—¶æ ‡è®°è¿™ä¸ªé€‰é¡¹ä¸ºå·²ä½¿ç”¨
                const tempUsed = [...usedOptions];
                tempUsed[i] = true;
                const newReturn = option.winProbability * option.winPayout * option.cost + 
                                this.maximizeExpectedReturn(remainingBudget - option.cost, tempUsed);
                
                const additionalReturn = newReturn - currentReturn;
                
                if (additionalReturn > bestAdditionalReturn) {
                    bestAdditionalReturn = additionalReturn;
                    bestOption = option;
                    bestIndex = i;
                }
            }
            
            if (bestOption && bestAdditionalReturn > 0) {
                strategy.push(bestOption);
                remainingBudget -= bestOption.cost;
                usedOptions[bestIndex] = true;
            } else {
                break; // æ²¡æœ‰æ›´å¥½çš„é€‰é¡¹äº†
            }
        }
        
        return strategy;
    }
    
    // è®¡ç®—æŠ•æ³¨ç»„åˆçš„é£é™©æŒ‡æ ‡
    calculateRiskMetrics(strategy: BettingOption[]): RiskMetrics {
        let totalCost = 0;
        let expectedReturn = 0;
        let variance = 0;
        
        // è®¡ç®—æ‰€æœ‰å¯èƒ½çš„ç»“æœç»„åˆ
        const outcomes = this.generateAllOutcomes(strategy);
        
        for (const outcome of outcomes) {
            totalCost += outcome.totalCost;
            expectedReturn += outcome.probability * outcome.return;
            variance += outcome.probability * Math.pow(outcome.return - expectedReturn, 2);
        }
        
        const standardDeviation = Math.sqrt(variance);
        const sharpeRatio = expectedReturn / standardDeviation; // é£é™©è°ƒæ•´æ”¶ç›Š
        
        return {
            expectedReturn,
            variance,
            standardDeviation,
            sharpeRatio,
            maxLoss: Math.min(...outcomes.map(o => o.return)),
            maxGain: Math.max(...outcomes.map(o => o.return))
        };
    }
    
    // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ç»“æœç»„åˆ
    generateAllOutcomes(strategy: BettingOption[]): Outcome[] {
        const outcomes: Outcome[] = [];
        const n = strategy.length;
        
        // éå†æ‰€æœ‰å¯èƒ½çš„èƒœè´Ÿç»„åˆ (2^nç§)
        for (let mask = 0; mask < (1 << n); mask++) {
            let probability = 1;
            let totalReturn = 0;
            let totalCost = 0;
            
            for (let i = 0; i < n; i++) {
                const option = strategy[i];
                totalCost += option.cost;
                
                if (mask & (1 << i)) {
                    // è¿™ä¸ªé€‰é¡¹è·èƒœ
                    probability *= option.winProbability;
                    totalReturn += option.winPayout * option.cost;
                } else {
                    // è¿™ä¸ªé€‰é¡¹å¤±è´¥
                    probability *= (1 - option.winProbability);
                    // å¤±å»æŠ•æ³¨æˆæœ¬ï¼ˆå·²åœ¨costä¸­è®¡ç®—ï¼‰
                }
            }
            
            outcomes.push({
                probability,
                return: totalReturn - totalCost,
                totalCost
            });
        }
        
        return outcomes;
    }
}

interface Outcome {
    probability: number;
    return: number;
    totalCost: number;
}

interface RiskMetrics {
    expectedReturn: number;
    variance: number;
    standardDeviation: number;
    sharpeRatio: number;
    maxLoss: number;
    maxGain: number;
}

console.log("åŠ¨æ€è§„åˆ’æ ¸å¿ƒæ•°æ®ç»“æ„:");
console.log("ğŸ—‚ï¸ å“ˆå¸Œè¡¨: è®°å¿†åŒ–å­˜å‚¨å­é—®é¢˜è§£");
console.log("ğŸ“Š æ•°ç»„: çŠ¶æ€è½¬ç§»è¡¨ç¤º");
console.log("ğŸ¯ ä½è¿ç®—: ç»„åˆçŠ¶æ€æšä¸¾");
console.log("ğŸ“ˆ æ¦‚ç‡è®¡ç®—: æœŸæœ›å€¼å’Œæ–¹å·®");
```

## ğŸ“Š ç®—æ³•é€‰æ‹©æ€»ç»“è¡¨

| æ¸¸æˆç±»å‹ | æ ¸å¿ƒç®—æ³• | ä¸»è¦æ•°æ®ç»“æ„ | æ—¶é—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|----------|----------|--------------|------------|----------|
| **å®Œå…¨ä¿¡æ¯åšå¼ˆ** | Minimax + Alpha-Beta | å“ˆå¸Œè¡¨+é€’å½’æ ˆ | O(b^d) â†’ O(b^(d/2)) | è±¡æ£‹ã€å›´æ£‹ |
| **å®æ—¶å¯¹å¼ˆ** | è¿­ä»£åŠ æ·±æœç´¢ | æ ˆ+å“ˆå¸Œè¡¨+å†å²è¡¨ | O(b^d) æ—¶é—´å¯æ§ | åœ¨çº¿æ¸¸æˆ |
| **æ¦‚ç‡æ¸¸æˆ** | è’™ç‰¹å¡ç½—æ¨¡æ‹Ÿ | æ•°ç»„+éšæœºæ•°ç”Ÿæˆå™¨ | O(æ¨¡æ‹Ÿæ¬¡æ•°) | æ‰‘å…‹ã€å½©ç¥¨ |
| **çº¦æŸæ±‚è§£** | å›æº¯+çº¦æŸä¼ æ’­ | äºŒç»´æ•°ç»„+é›†åˆ | O(k^n) å‰ªæä¼˜åŒ– | æ•°ç‹¬ã€å¡«å­— |
| **ä¼˜åŒ–é—®é¢˜** | åŠ¨æ€è§„åˆ’ | å“ˆå¸Œè¡¨+çŠ¶æ€è¡¨ | O(çŠ¶æ€æ•°Ã—é€‰æ‹©æ•°) | æŠ•æ³¨ä¼˜åŒ– |
| **çŠ¶æ€ç¼“å­˜** | ç½®æ¢è¡¨ | å“ˆå¸Œè¡¨+Zobrist | O(1) æŸ¥æ‰¾ | æ‰€æœ‰æœç´¢ç®—æ³• |

**å…³é”®åŸåˆ™**ï¼š
- ğŸ¯ **å®Œå…¨ä¿¡æ¯ â†’ æœç´¢ç®—æ³•**
- ğŸ¯ **ä¸å®Œå…¨ä¿¡æ¯ â†’ æ¦‚ç‡è®¡ç®—**  
- ğŸ¯ **å®æ—¶è¦æ±‚ â†’ æ—¶é—´æ§åˆ¶**
- ğŸ¯ **é‡å¤è®¡ç®— â†’ ç¼“å­˜ä¼˜åŒ–**

è¿™äº›ç®—æ³•éƒ½å¯ä»¥åœ¨å®¢æˆ·ç«¯æˆ–æœåŠ¡å™¨å•ç‹¬å®ç°ï¼Œä¸ä¾èµ–å¤–éƒ¨AIæœåŠ¡ï¼ğŸ’ª