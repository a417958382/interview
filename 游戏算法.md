å¥½çš„ï¼æˆ‘æ¥æ•´ç†ä¸€ä¸‹æ¸¸æˆAIä¸­çš„ç®—æ³•åº”ç”¨ï¼š

## ğŸ® æ¸¸æˆAIç®—æ³•åº”ç”¨æ€»è§ˆ

### 1. è·¯å¾„è§„åˆ’ç±» ğŸ—ºï¸

#### ä½¿ç”¨åœºæ™¯
- **NPCç§»åŠ¨**ï¼šè§’è‰²åœ¨åœ°å›¾ä¸Šå¯»æ‰¾æœ€çŸ­è·¯å¾„
- **RTSæ¸¸æˆ**ï¼šå•ä½é¿å¼€éšœç¢ç‰©ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
- **MMORPG**ï¼šè‡ªåŠ¨å¯»è·¯ç³»ç»Ÿ

#### é€‚é…ç®—æ³• & æ•°æ®ç»“æ„

**A*æœç´¢ç®—æ³•**
```typescript
// æ ¸å¿ƒæ•°æ®ç»“æ„
interface AStarNode {
    position: {x: number, y: number};
    gScore: number;  // ä»èµ·ç‚¹çš„å®é™…è·ç¦»
    fScore: number;  // gScore + å¯å‘å¼è·ç¦»
    parent: AStarNode | null;
}

class AStar {
    private openSet: MinHeap<AStarNode>;    // äºŒå‰å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
    private closedSet: Set<string>;         // å“ˆå¸Œé›†åˆï¼ˆå·²è®¿é—®èŠ‚ç‚¹ï¼‰
    private grid: number[][];               // äºŒç»´æ•°ç»„ï¼ˆåœ°å›¾ï¼‰
    
    findPath(start: Position, goal: Position): Position[] {
        // A* = Dijkstra + å¯å‘å¼å‡½æ•°
        // æ—¶é—´å¤æ‚åº¦: O(b^d)ï¼Œb=åˆ†æ”¯å› å­ï¼Œd=æ·±åº¦
        // ç©ºé—´å¤æ‚åº¦: O(b^d)
        return [];
    }
}
```

**Dijkstraç®—æ³•**
```typescript
// é€‚ç”¨ï¼šæƒé‡å›¾ï¼ˆå¦‚è€ƒè™‘åœ°å½¢éš¾åº¦ï¼‰
class DijkstraPathfinding {
    private heap: MinHeap<{node: number, distance: number}>;  // äºŒå‰å †
    private graph: number[][];                                // é‚»æ¥çŸ©é˜µ
    private distances: number[];                              // ä¸€ç»´æ•°ç»„
    
    // æ—¶é—´å¤æ‚åº¦: O(E log V)
    // ç©ºé—´å¤æ‚åº¦: O(V)
}
```

### 2. æˆ˜æ–—ç­–ç•¥è§„åˆ’ âš”ï¸

#### ä½¿ç”¨åœºæ™¯
- **å›åˆåˆ¶RPG**ï¼šè§„åˆ’æŠ€èƒ½é‡Šæ”¾é¡ºåº
- **å¡ç‰Œæ¸¸æˆ**ï¼šè®¡ç®—æœ€ä¼˜å‡ºç‰Œç­–ç•¥
- **MOBAæ¸¸æˆ**ï¼šå›¢æˆ˜æ—¶æœºåˆ¤æ–­

#### é€‚é…ç®—æ³• & æ•°æ®ç»“æ„

**åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰**
```typescript
interface BattleState {
    playerHP: number;
    playerMP: number;
    enemyHP: number;
    turn: number;
}

class BattleAI {
    private dpTable: Map<string, number>;     // å“ˆå¸Œè¡¨ï¼ˆçŠ¶æ€ç¼“å­˜ï¼‰
    private actions: Action[];                // æ•°ç»„ï¼ˆå¯ç”¨åŠ¨ä½œï¼‰
    
    findOptimalStrategy(state: BattleState): Action[] {
        // çŠ¶æ€å‹ç¼© + è®°å¿†åŒ–æœç´¢
        // æ—¶é—´å¤æ‚åº¦: O(çŠ¶æ€æ•° Ã— åŠ¨ä½œæ•°)
        // ç©ºé—´å¤æ‚åº¦: O(çŠ¶æ€æ•°)
        return [];
    }
}
```

**Minimaxç®—æ³•ï¼ˆå¯¹æŠ—æ€§æ¸¸æˆï¼‰**
```typescript
interface GameNode {
    gameState: any;
    children: GameNode[];
    isMaximizing: boolean;
    value: number;
}

class MinimaxAI {
    private gameTree: GameNode;               // æ ‘ç»“æ„
    private transpositionTable: Map<string, number>; // å“ˆå¸Œè¡¨ï¼ˆçŠ¶æ€ç¼“å­˜ï¼‰
    
    minimax(node: GameNode, depth: number, alpha: number, beta: number): number {
        // Alpha-Betaå‰ªæä¼˜åŒ–
        // æ—¶é—´å¤æ‚åº¦: O(b^d) â†’ O(b^(d/2)) å‰ªæå
        // ç©ºé—´å¤æ‚åº¦: O(d)
        return 0;
    }
}
```

### 3. èµ„æºç®¡ç†ä¼˜åŒ– ğŸ’°

#### ä½¿ç”¨åœºæ™¯
- **åŸå¸‚å»ºé€ æ¸¸æˆ**ï¼šå»ºç­‘å»ºé€ é¡ºåº
- **ç»è¥æ¨¡æ‹Ÿ**ï¼šèµ„æºåˆ†é…ç­–ç•¥
- **ç”Ÿå­˜æ¸¸æˆ**ï¼šç‰©èµ„é‡‡é›†è·¯çº¿

#### é€‚é…ç®—æ³• & æ•°æ®ç»“æ„

**è´ªå¿ƒç®—æ³• + ä¼˜å…ˆé˜Ÿåˆ—**
```typescript
interface Resource {
    type: string;
    priority: number;
    cost: number;
    benefit: number;
}

class ResourceManager {
    private resourceQueue: MaxHeap<Resource>; // äºŒå‰å †ï¼ˆæŒ‰æ”¶ç›Šæ’åºï¼‰
    private inventory: Map<string, number>;   // å“ˆå¸Œè¡¨ï¼ˆåº“å­˜ï¼‰
    private productionGraph: number[][];      // é‚»æ¥çŸ©é˜µï¼ˆç”Ÿäº§é“¾ï¼‰
    
    optimizeProduction(): Resource[] {
        // æŒ‰æ”¶ç›Š/æˆæœ¬æ¯”æ’åº
        // æ—¶é—´å¤æ‚åº¦: O(n log n)
        // ç©ºé—´å¤æ‚åº¦: O(n)
        return [];
    }
}
```

**ç½‘ç»œæµç®—æ³•**
```typescript
class SupplyChainOptimizer {
    private flowGraph: number[][];            // é‚»æ¥çŸ©é˜µï¼ˆæµç½‘ç»œï¼‰
    private capacity: number[][];             // äºŒç»´æ•°ç»„ï¼ˆå®¹é‡é™åˆ¶ï¼‰
    
    maxFlow(source: number, sink: number): number {
        // Ford-Fulkersonç®—æ³•
        // æ—¶é—´å¤æ‚åº¦: O(E Ã— f) f=æœ€å¤§æµå€¼
        // ç©ºé—´å¤æ‚åº¦: O(VÂ²)
        return 0;
    }
}
```

### 4. æŠ€èƒ½è¿å‡»ç³»ç»Ÿ ğŸ”¥

#### ä½¿ç”¨åœºæ™¯
- **æ ¼æ–—æ¸¸æˆ**ï¼šè¿æ‹›åˆ¤å®š
- **ARPG**ï¼šæŠ€èƒ½è¿æºæ•ˆæœ
- **éŸ³æ¸¸**ï¼šè¿å‡»å¥–åŠ±è®¡ç®—

#### é€‚é…ç®—æ³• & æ•°æ®ç»“æ„

**æœ‰é™çŠ¶æ€æœºï¼ˆFSMï¼‰**
```typescript
interface ComboState {
    id: string;
    transitions: Map<string, ComboState>;    // å“ˆå¸Œè¡¨ï¼ˆçŠ¶æ€è½¬æ¢ï¼‰
    effects: Effect[];                       // æ•°ç»„ï¼ˆçŠ¶æ€æ•ˆæœï¼‰
}

class ComboSystem {
    private stateGraph: Map<string, ComboState>; // å“ˆå¸Œè¡¨ï¼ˆçŠ¶æ€å›¾ï¼‰
    private currentState: ComboState;            // å½“å‰çŠ¶æ€
    private inputBuffer: Queue<string>;          // é˜Ÿåˆ—ï¼ˆè¾“å…¥ç¼“å†²ï¼‰
    
    processInput(input: string): boolean {
        // çŠ¶æ€è½¬æ¢æ£€æŸ¥
        // æ—¶é—´å¤æ‚åº¦: O(1) å¹³å‡æƒ…å†µ
        // ç©ºé—´å¤æ‚åº¦: O(çŠ¶æ€æ•°)
        return true;
    }
}
```

**å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•**
```typescript
class ComboMatcher {
    private comboTrie: TrieNode;              // å­—å…¸æ ‘ï¼ˆè¿æ‹›æ¨¡å¼ï¼‰
    private kmpTable: number[];               // æ•°ç»„ï¼ˆKMPé¢„å¤„ç†ï¼‰
    
    matchCombo(inputSequence: string[]): Combo[] {
        // Aho-Corasickç®—æ³•ï¼ˆå¤šæ¨¡å¼åŒ¹é…ï¼‰
        // æ—¶é—´å¤æ‚åº¦: O(n + m + z) n=æ–‡æœ¬é•¿åº¦,m=æ¨¡å¼æ€»é•¿åº¦,z=åŒ¹é…æ•°
        // ç©ºé—´å¤æ‚åº¦: O(m)
        return [];
    }
}
```

### 5. å®æ—¶å†³ç­–ç³»ç»Ÿ âš¡

#### ä½¿ç”¨åœºæ™¯
- **FPSæ¸¸æˆ**ï¼šæ•ŒäººAIè¡Œä¸ºæ ‘
- **å³æ—¶æˆ˜ç•¥**ï¼šå•ä½ç¾¤ä½“è¡Œä¸º
- **å¼€æ”¾ä¸–ç•Œ**ï¼šNPCæ—¥å¸¸è¡Œä¸º

#### é€‚é…ç®—æ³• & æ•°æ®ç»“æ„

**è’™ç‰¹å¡ç½—æ ‘æœç´¢ï¼ˆMCTSï¼‰**
```typescript
interface MCTSNode {
    state: GameState;
    parent: MCTSNode | null;
    children: MCTSNode[];                     // æ•°ç»„ï¼ˆå­èŠ‚ç‚¹ï¼‰
    visits: number;
    wins: number;
}

class MCTS {
    private root: MCTSNode;                   // æ ‘æ ¹
    private nodePool: ObjectPool<MCTSNode>;   // å¯¹è±¡æ± ï¼ˆå†…å­˜ä¼˜åŒ–ï¼‰
    
    search(iterations: number): Action {
        // é€‰æ‹©-æ‰©å±•-æ¨¡æ‹Ÿ-å›ä¼ 
        // æ—¶é—´å¤æ‚åº¦: O(iterations)
        // ç©ºé—´å¤æ‚åº¦: O(tree_size)
        return new Action();
    }
}
```

**è¡Œä¸ºæ ‘ï¼ˆBehavior Treeï¼‰**
```typescript
abstract class BehaviorNode {
    abstract execute(): NodeStatus;
}

class BehaviorTree {
    private root: BehaviorNode;               // æ ‘æ ¹
    private blackboard: Map<string, any>;     // å“ˆå¸Œè¡¨ï¼ˆå…±äº«æ•°æ®ï¼‰
    private nodeStack: Stack<BehaviorNode>;   // æ ˆï¼ˆæ‰§è¡Œæ ˆï¼‰
    
    tick(): NodeStatus {
        // æ·±åº¦ä¼˜å…ˆéå†æ‰§è¡Œ
        // æ—¶é—´å¤æ‚åº¦: O(èŠ‚ç‚¹æ•°)
        // ç©ºé—´å¤æ‚åº¦: O(æ ‘æ·±åº¦)
        return NodeStatus.SUCCESS;
    }
}
```

### 6. è´Ÿæƒé‡å¤„ç†ç‰¹æ®Šæƒ…å†µ ğŸ”„

#### ä½¿ç”¨åœºæ™¯
- **å›è¡€/å›è“æŠ€èƒ½**ï¼šæ¢å¤å‹åŠ¨ä½œ
- **è£…å¤‡äº¤æ˜“**ï¼šä¹°å–è·åˆ©
- **Buff/Debuff**ï¼šçŠ¶æ€æ•ˆæœ

#### é€‚é…ç®—æ³• & æ•°æ®ç»“æ„

**Bellman-Fordç®—æ³•**
```typescript
class NegativeWeightPathfinding {
    private graph: number[][];                // é‚»æ¥çŸ©é˜µ
    private distances: number[];              // ä¸€ç»´æ•°ç»„ï¼ˆè·ç¦»ï¼‰
    private predecessors: number[];           // ä¸€ç»´æ•°ç»„ï¼ˆå‰é©±ï¼‰
    
    findShortestPath(source: number): boolean {
        // æ¾å¼›æ‰€æœ‰è¾¹ V-1 æ¬¡
        // æ—¶é—´å¤æ‚åº¦: O(VE)
        // ç©ºé—´å¤æ‚åº¦: O(V)
        // èƒ½æ£€æµ‹è´Ÿæƒç¯
        return true;
    }
}
```

**SPFAç®—æ³•ï¼ˆBellman-Fordä¼˜åŒ–ï¼‰**
```typescript
class SPFA {
    private queue: Queue<number>;             // é˜Ÿåˆ—ï¼ˆå¾…å¤„ç†èŠ‚ç‚¹ï¼‰
    private inQueue: boolean[];               // å¸ƒå°”æ•°ç»„ï¼ˆåœ¨é˜Ÿåˆ—ä¸­æ ‡è®°ï¼‰
    private distances: number[];              // ä¸€ç»´æ•°ç»„ï¼ˆè·ç¦»ï¼‰
    
    shortestPath(source: number): void {
        // åªå¤„ç†èƒ½è¢«æ¾å¼›çš„èŠ‚ç‚¹
        // å¹³å‡æ—¶é—´å¤æ‚åº¦: O(kE) kæ˜¯å¸¸æ•°
        // æœ€åæ—¶é—´å¤æ‚åº¦: O(VE)
        // ç©ºé—´å¤æ‚åº¦: O(V)
    }
}
```

## ğŸ“Š ç®—æ³•é€‰æ‹©å†³ç­–æ ‘

```typescript
function chooseAlgorithm(gameType: string, scenario: string): string {
    const decisionTree = {
        "è·¯å¾„è§„åˆ’": {
            "æ— æƒå›¾": "BFS + é˜Ÿåˆ—",
            "æ­£æƒå›¾": "Dijkstra + äºŒå‰å †", 
            "æœ‰å¯å‘å¼": "A* + äºŒå‰å †",
            "æœ‰è´Ÿæƒ": "Bellman-Ford + æ•°ç»„"
        },
        "æˆ˜æ–—ç­–ç•¥": {
            "å›åˆåˆ¶": "åŠ¨æ€è§„åˆ’ + å“ˆå¸Œè¡¨",
            "å®æ—¶åˆ¶": "MCTS + æ ‘",
            "å¯¹æŠ—æ€§": "Minimax + Alpha-Betaå‰ªæ"
        },
        "èµ„æºç®¡ç†": {
            "ç®€å•ä¼˜åŒ–": "è´ªå¿ƒ + ä¼˜å…ˆé˜Ÿåˆ—",
            "å¤æ‚çº¦æŸ": "çº¿æ€§è§„åˆ’ + å•çº¯å½¢æ³•",
            "æµç½‘ç»œ": "æœ€å¤§æµ + é‚»æ¥è¡¨"
        },
        "åºåˆ—åŒ¹é…": {
            "å•æ¨¡å¼": "KMP + æ•°ç»„",
            "å¤šæ¨¡å¼": "ACè‡ªåŠ¨æœº + å­—å…¸æ ‘",
            "æ¨¡ç³ŠåŒ¹é…": "ç¼–è¾‘è·ç¦» + åŠ¨æ€è§„åˆ’"
        }
    };
    
    return "æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©å¯¹åº”ç®—æ³•";
}
```

## âš¡ æ€§èƒ½å¯¹æ¯”æ€»ç»“

| ç®—æ³•ç±»å‹ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ä¸»è¦æ•°æ®ç»“æ„ | é€‚ç”¨åœºæ™¯ |
|----------|------------|------------|--------------|----------|
| **A*** | O(b^d) | O(b^d) | äºŒå‰å †+å“ˆå¸Œé›†åˆ | è·¯å¾„è§„åˆ’(æœ‰å¯å‘å¼) |
| **Dijkstra** | O(E log V) | O(V) | äºŒå‰å †+æ•°ç»„ | æœ€çŸ­è·¯å¾„(æ­£æƒ) |
| **åŠ¨æ€è§„åˆ’** | O(çŠ¶æ€Ã—åŠ¨ä½œ) | O(çŠ¶æ€æ•°) | å“ˆå¸Œè¡¨+æ•°ç»„ | ç­–ç•¥ä¼˜åŒ– |
| **MCTS** | O(iterations) | O(tree_size) | æ ‘+å¯¹è±¡æ±  | å¤æ‚å†³ç­– |
| **Bellman-Ford** | O(VE) | O(V) | æ•°ç»„ | è´Ÿæƒå›¾è·¯å¾„ |
| **è¡Œä¸ºæ ‘** | O(èŠ‚ç‚¹æ•°) | O(æ·±åº¦) | æ ‘+æ ˆ+å“ˆå¸Œè¡¨ | AIè¡Œä¸ºé€»è¾‘ |

**å…³é”®åŸåˆ™**ï¼šæ ¹æ®æ¸¸æˆç±»å‹ã€å®æ—¶æ€§è¦æ±‚ã€å¤æ‚åº¦é™åˆ¶æ¥é€‰æ‹©æœ€é€‚åˆçš„ç®—æ³•å’Œæ•°æ®ç»“æ„ç»„åˆï¼ğŸ¯