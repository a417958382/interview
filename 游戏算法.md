好的！我来整理一下游戏AI中的算法应用：

## 🎮 游戏AI算法应用总览

### 1. 路径规划类 🗺️

#### 使用场景
- **NPC移动**：角色在地图上寻找最短路径
- **RTS游戏**：单位避开障碍物移动到目标位置
- **MMORPG**：自动寻路系统

#### 适配算法 & 数据结构

**A*搜索算法**
```typescript
// 核心数据结构
interface AStarNode {
    position: {x: number, y: number};
    gScore: number;  // 从起点的实际距离
    fScore: number;  // gScore + 启发式距离
    parent: AStarNode | null;
}

class AStar {
    private openSet: MinHeap<AStarNode>;    // 二叉堆（优先队列）
    private closedSet: Set<string>;         // 哈希集合（已访问节点）
    private grid: number[][];               // 二维数组（地图）
    
    findPath(start: Position, goal: Position): Position[] {
        // A* = Dijkstra + 启发式函数
        // 时间复杂度: O(b^d)，b=分支因子，d=深度
        // 空间复杂度: O(b^d)
        return [];
    }
}
```

**Dijkstra算法**
```typescript
// 适用：权重图（如考虑地形难度）
class DijkstraPathfinding {
    private heap: MinHeap<{node: number, distance: number}>;  // 二叉堆
    private graph: number[][];                                // 邻接矩阵
    private distances: number[];                              // 一维数组
    
    // 时间复杂度: O(E log V)
    // 空间复杂度: O(V)
}
```

### 2. 战斗策略规划 ⚔️

#### 使用场景
- **回合制RPG**：规划技能释放顺序
- **卡牌游戏**：计算最优出牌策略
- **MOBA游戏**：团战时机判断

#### 适配算法 & 数据结构

**动态规划（DP）**
```typescript
interface BattleState {
    playerHP: number;
    playerMP: number;
    enemyHP: number;
    turn: number;
}

class BattleAI {
    private dpTable: Map<string, number>;     // 哈希表（状态缓存）
    private actions: Action[];                // 数组（可用动作）
    
    findOptimalStrategy(state: BattleState): Action[] {
        // 状态压缩 + 记忆化搜索
        // 时间复杂度: O(状态数 × 动作数)
        // 空间复杂度: O(状态数)
        return [];
    }
}
```

**Minimax算法（对抗性游戏）**
```typescript
interface GameNode {
    gameState: any;
    children: GameNode[];
    isMaximizing: boolean;
    value: number;
}

class MinimaxAI {
    private gameTree: GameNode;               // 树结构
    private transpositionTable: Map<string, number>; // 哈希表（状态缓存）
    
    minimax(node: GameNode, depth: number, alpha: number, beta: number): number {
        // Alpha-Beta剪枝优化
        // 时间复杂度: O(b^d) → O(b^(d/2)) 剪枝后
        // 空间复杂度: O(d)
        return 0;
    }
}
```

### 3. 资源管理优化 💰

#### 使用场景
- **城市建造游戏**：建筑建造顺序
- **经营模拟**：资源分配策略
- **生存游戏**：物资采集路线

#### 适配算法 & 数据结构

**贪心算法 + 优先队列**
```typescript
interface Resource {
    type: string;
    priority: number;
    cost: number;
    benefit: number;
}

class ResourceManager {
    private resourceQueue: MaxHeap<Resource>; // 二叉堆（按收益排序）
    private inventory: Map<string, number>;   // 哈希表（库存）
    private productionGraph: number[][];      // 邻接矩阵（生产链）
    
    optimizeProduction(): Resource[] {
        // 按收益/成本比排序
        // 时间复杂度: O(n log n)
        // 空间复杂度: O(n)
        return [];
    }
}
```

**网络流算法**
```typescript
class SupplyChainOptimizer {
    private flowGraph: number[][];            // 邻接矩阵（流网络）
    private capacity: number[][];             // 二维数组（容量限制）
    
    maxFlow(source: number, sink: number): number {
        // Ford-Fulkerson算法
        // 时间复杂度: O(E × f) f=最大流值
        // 空间复杂度: O(V²)
        return 0;
    }
}
```

### 4. 技能连击系统 🔥

#### 使用场景
- **格斗游戏**：连招判定
- **ARPG**：技能连携效果
- **音游**：连击奖励计算

#### 适配算法 & 数据结构

**有限状态机（FSM）**
```typescript
interface ComboState {
    id: string;
    transitions: Map<string, ComboState>;    // 哈希表（状态转换）
    effects: Effect[];                       // 数组（状态效果）
}

class ComboSystem {
    private stateGraph: Map<string, ComboState>; // 哈希表（状态图）
    private currentState: ComboState;            // 当前状态
    private inputBuffer: Queue<string>;          // 队列（输入缓冲）
    
    processInput(input: string): boolean {
        // 状态转换检查
        // 时间复杂度: O(1) 平均情况
        // 空间复杂度: O(状态数)
        return true;
    }
}
```

**字符串匹配算法**
```typescript
class ComboMatcher {
    private comboTrie: TrieNode;              // 字典树（连招模式）
    private kmpTable: number[];               // 数组（KMP预处理）
    
    matchCombo(inputSequence: string[]): Combo[] {
        // Aho-Corasick算法（多模式匹配）
        // 时间复杂度: O(n + m + z) n=文本长度,m=模式总长度,z=匹配数
        // 空间复杂度: O(m)
        return [];
    }
}
```

### 5. 实时决策系统 ⚡

#### 使用场景
- **FPS游戏**：敌人AI行为树
- **即时战略**：单位群体行为
- **开放世界**：NPC日常行为

#### 适配算法 & 数据结构

**蒙特卡罗树搜索（MCTS）**
```typescript
interface MCTSNode {
    state: GameState;
    parent: MCTSNode | null;
    children: MCTSNode[];                     // 数组（子节点）
    visits: number;
    wins: number;
}

class MCTS {
    private root: MCTSNode;                   // 树根
    private nodePool: ObjectPool<MCTSNode>;   // 对象池（内存优化）
    
    search(iterations: number): Action {
        // 选择-扩展-模拟-回传
        // 时间复杂度: O(iterations)
        // 空间复杂度: O(tree_size)
        return new Action();
    }
}
```

**行为树（Behavior Tree）**
```typescript
abstract class BehaviorNode {
    abstract execute(): NodeStatus;
}

class BehaviorTree {
    private root: BehaviorNode;               // 树根
    private blackboard: Map<string, any>;     // 哈希表（共享数据）
    private nodeStack: Stack<BehaviorNode>;   // 栈（执行栈）
    
    tick(): NodeStatus {
        // 深度优先遍历执行
        // 时间复杂度: O(节点数)
        // 空间复杂度: O(树深度)
        return NodeStatus.SUCCESS;
    }
}
```

### 6. 负权重处理特殊情况 🔄

#### 使用场景
- **回血/回蓝技能**：恢复型动作
- **装备交易**：买卖获利
- **Buff/Debuff**：状态效果

#### 适配算法 & 数据结构

**Bellman-Ford算法**
```typescript
class NegativeWeightPathfinding {
    private graph: number[][];                // 邻接矩阵
    private distances: number[];              // 一维数组（距离）
    private predecessors: number[];           // 一维数组（前驱）
    
    findShortestPath(source: number): boolean {
        // 松弛所有边 V-1 次
        // 时间复杂度: O(VE)
        // 空间复杂度: O(V)
        // 能检测负权环
        return true;
    }
}
```

**SPFA算法（Bellman-Ford优化）**
```typescript
class SPFA {
    private queue: Queue<number>;             // 队列（待处理节点）
    private inQueue: boolean[];               // 布尔数组（在队列中标记）
    private distances: number[];              // 一维数组（距离）
    
    shortestPath(source: number): void {
        // 只处理能被松弛的节点
        // 平均时间复杂度: O(kE) k是常数
        // 最坏时间复杂度: O(VE)
        // 空间复杂度: O(V)
    }
}
```

## 📊 算法选择决策树

```typescript
function chooseAlgorithm(gameType: string, scenario: string): string {
    const decisionTree = {
        "路径规划": {
            "无权图": "BFS + 队列",
            "正权图": "Dijkstra + 二叉堆", 
            "有启发式": "A* + 二叉堆",
            "有负权": "Bellman-Ford + 数组"
        },
        "战斗策略": {
            "回合制": "动态规划 + 哈希表",
            "实时制": "MCTS + 树",
            "对抗性": "Minimax + Alpha-Beta剪枝"
        },
        "资源管理": {
            "简单优化": "贪心 + 优先队列",
            "复杂约束": "线性规划 + 单纯形法",
            "流网络": "最大流 + 邻接表"
        },
        "序列匹配": {
            "单模式": "KMP + 数组",
            "多模式": "AC自动机 + 字典树",
            "模糊匹配": "编辑距离 + 动态规划"
        }
    };
    
    return "根据具体需求选择对应算法";
}
```

## ⚡ 性能对比总结

| 算法类型 | 时间复杂度 | 空间复杂度 | 主要数据结构 | 适用场景 |
|----------|------------|------------|--------------|----------|
| **A*** | O(b^d) | O(b^d) | 二叉堆+哈希集合 | 路径规划(有启发式) |
| **Dijkstra** | O(E log V) | O(V) | 二叉堆+数组 | 最短路径(正权) |
| **动态规划** | O(状态×动作) | O(状态数) | 哈希表+数组 | 策略优化 |
| **MCTS** | O(iterations) | O(tree_size) | 树+对象池 | 复杂决策 |
| **Bellman-Ford** | O(VE) | O(V) | 数组 | 负权图路径 |
| **行为树** | O(节点数) | O(深度) | 树+栈+哈希表 | AI行为逻辑 |

**关键原则**：根据游戏类型、实时性要求、复杂度限制来选择最适合的算法和数据结构组合！🎯