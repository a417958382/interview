# å›åˆåˆ¶æ¸¸æˆæ¶æ„è®¾è®¡

## ğŸ¯ æ¸¸æˆæ¦‚è¿°

å›åˆåˆ¶æ¸¸æˆï¼ˆTurn-Based Gameï¼‰æ˜¯ä¸€ç§ç©å®¶å’ŒAIäº¤æ›¿è¡ŒåŠ¨çš„æ¸¸æˆç±»å‹ï¼Œæ¯ä¸ªå‚ä¸è€…è½®æµè¿›è¡Œæœ‰é™çš„è¡ŒåŠ¨ã€‚æ ¸å¿ƒç©æ³•å›´ç»•ç­–ç•¥æ€è€ƒã€èµ„æºç®¡ç†ã€æˆ˜æœ¯å†³ç­–å±•å¼€ã€‚ä»£è¡¨ä½œå“åŒ…æ‹¬ã€Šæ–‡æ˜ã€‹ã€ã€Šç«ç„°çº¹ç« ã€‹ã€ã€Šæœ€ç»ˆå¹»æƒ³ã€‹ç­‰ã€‚

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„æ¨¡å—

### 0. æ ¸å¿ƒæˆ˜æ–—æ¨¡å— (Combat System)

#### å›åˆåˆ¶æˆ˜æ–—æµç¨‹æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   å›åˆåˆ¶æˆ˜æ–—ç³»ç»Ÿæ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  æˆ˜æ–—å‡†å¤‡    â”‚ -> â”‚  å›åˆå¾ªç¯    â”‚ -> â”‚  æˆ˜æ–—ç»“ç®—    â”‚     â”‚
â”‚  â”‚             â”‚    â”‚             â”‚    â”‚             â”‚     â”‚
â”‚  â”‚ â€¢ åˆå§‹åŒ–    â”‚    â”‚ â€¢ è¡ŒåŠ¨é˜Ÿåˆ—   â”‚    â”‚ â€¢ ç»“æœè®¡ç®—   â”‚     â”‚
â”‚  â”‚ â€¢ ä½ç½®è®¾ç½®  â”‚    â”‚ â€¢ çŠ¶æ€æ›´æ–°   â”‚    â”‚ â€¢ å¥–åŠ±åˆ†é…   â”‚     â”‚
â”‚  â”‚ â€¢ çŠ¶æ€é‡ç½®  â”‚    â”‚ â€¢ äº‹ä»¶å¤„ç†   â”‚    â”‚ â€¢ ç»éªŒè·å¾—   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²                        â–²                        â”‚
         â”‚                        â”‚                        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     èƒœåˆ©/å¤±è´¥åˆ¤å®š     â”‚
                    â”‚                     â”‚
                    â”‚ â€¢ æ¡ä»¶æ£€æŸ¥          â”‚
                    â”‚ â€¢ ç»Ÿè®¡è®¡ç®—          â”‚
                    â”‚ â€¢ åç»­å¤„ç†          â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æˆ˜æ–—ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶

```mermaid
mindmap
  root((å›åˆåˆ¶æˆ˜æ–—å¼•æ“))
    æˆ˜æ–—çŠ¶æ€ç®¡ç†å™¨
      æˆ˜æ–—åˆå§‹åŒ–å™¨
      å›åˆæ§åˆ¶å™¨
      è¡ŒåŠ¨ç®¡ç†å™¨
      çŠ¶æ€åŒæ­¥å™¨
    è¡ŒåŠ¨ç³»ç»Ÿ
      åŸºç¡€è¡ŒåŠ¨
        ç§»åŠ¨è¡ŒåŠ¨
        æ”»å‡»è¡ŒåŠ¨
        é˜²å¾¡è¡ŒåŠ¨
        ç­‰å¾…è¡ŒåŠ¨
      æŠ€èƒ½è¡ŒåŠ¨
        ä¸»åŠ¨æŠ€èƒ½
        è¢«åŠ¨æŠ€èƒ½
        è¿å‡»æŠ€èƒ½
      ç‰¹æ®Šè¡ŒåŠ¨
    æ•ˆæœç³»ç»Ÿ
      å³æ—¶æ•ˆæœ
      æŒç»­æ•ˆæœ
      çŠ¶æ€æ•ˆæœ
      ç¯å¢ƒæ•ˆæœ
    ä¼¤å®³è®¡ç®—å™¨
      åŸºç¡€ä¼¤å®³
      é˜²å¾¡å‡å…
      å…ƒç´ ç›¸å…‹
      ç‰¹æ®ŠåŠ æˆ
    AIå†³ç­–ç³»ç»Ÿ
      æˆ˜æœ¯è¯„ä¼°å™¨
      ç›®æ ‡é€‰æ‹©å™¨
      è¡ŒåŠ¨è§„åˆ’å™¨
      é£é™©è¯„ä¼°å™¨
```

#### æˆ˜æ–—çŠ¶æ€æœºæ¶æ„å›¾

```mermaid
stateDiagram-v2
    [*] --> InitializationState
    InitializationState --> PlanningState
    PlanningState --> ExecutionState
    ExecutionState --> ResolutionState
    ResolutionState --> EndState
    EndState --> [*]

    state "åˆå§‹åŒ–çŠ¶æ€" as InitializationState {
        [*] --> BattlefieldSetup
        BattlefieldSetup --> UnitDeployment
        UnitDeployment --> StatusInitialization
        StatusInitialization --> UIPreparation
        UIPreparation --> [*]

        BattlefieldSetup : æˆ˜åœºè®¾ç½®
        UnitDeployment : å•ä½éƒ¨ç½²
        StatusInitialization : çŠ¶æ€åˆå§‹åŒ–
        UIPreparation : UIå‡†å¤‡
    }

    state "è§„åˆ’çŠ¶æ€" as PlanningState {
        [*] --> ActionSelection
        ActionSelection --> TargetSelection
        TargetSelection --> PositionPlanning
        PositionPlanning --> StrategyEvaluation
        StrategyEvaluation --> [*]

        ActionSelection : è¡ŒåŠ¨é€‰æ‹©
        TargetSelection : ç›®æ ‡é€‰æ‹©
        PositionPlanning : ä½ç½®è§„åˆ’
        StrategyEvaluation : ç­–ç•¥è¯„ä¼°
    }

    state "æ‰§è¡ŒçŠ¶æ€" as ExecutionState {
        [*] --> ActionExecution
        ActionExecution --> EffectApplication
        EffectApplication --> AnimationPlayback
        AnimationPlayback --> StateUpdate
        StateUpdate --> [*]

        ActionExecution : è¡ŒåŠ¨æ‰§è¡Œ
        EffectApplication : æ•ˆæœåº”ç”¨
        AnimationPlayback : åŠ¨ç”»æ’­æ”¾
        StateUpdate : çŠ¶æ€æ›´æ–°
    }

    state "ç»“ç®—çŠ¶æ€" as ResolutionState {
        [*] --> DamageCalculation
        DamageCalculation --> ExperienceDistribution
        ExperienceDistribution --> ItemDrops
        ItemDrops --> AchievementCheck
        AchievementCheck --> [*]

        DamageCalculation : ä¼¤å®³è®¡ç®—
        ExperienceDistribution : ç»éªŒåˆ†é…
        ItemDrops : ç‰©å“æ‰è½
        AchievementCheck : æˆå°±æ£€æŸ¥
    }

    state "ç»“æŸçŠ¶æ€" as EndState {
        [*] --> VictoryConditionCheck
        VictoryConditionCheck --> DefeatConditionCheck
        DefeatConditionCheck --> StatisticsGeneration
        StatisticsGeneration --> ResourceCleanup
        ResourceCleanup --> [*]

        VictoryConditionCheck : èƒœåˆ©æ¡ä»¶æ£€æŸ¥
        DefeatConditionCheck : å¤±è´¥æ¡ä»¶æ£€æŸ¥
        StatisticsGeneration : ç»Ÿè®¡ç”Ÿæˆ
        ResourceCleanup : æ¸…ç†èµ„æº
    }
```

#### å›åˆæµç¨‹æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant P as ç©å®¶
    participant TS as å›åˆç³»ç»Ÿ
    participant CS as æˆ˜æ–—ç³»ç»Ÿ
    participant ES as æ•ˆæœç³»ç»Ÿ

    Note over P,ES: å›åˆå¼€å§‹é˜¶æ®µ
    TS->>TS: å›åˆå¼€å§‹äº‹ä»¶è§¦å‘
    TS->>ES: BUFF/DEBUFFæ•ˆæœç»“ç®—
    ES->>ES: çŠ¶æ€æ¢å¤
    ES->>ES: å†·å´æ—¶é—´æ›´æ–°
    TS->>P: é€šçŸ¥å›åˆå¼€å§‹

    Note over P,ES: è¡ŒåŠ¨è§„åˆ’é˜¶æ®µ
    P->>P: è¡ŒåŠ¨ç‚¹æ•°åˆ†é…
    P->>P: æŠ€èƒ½é€‰æ‹©
    P->>P: ç›®æ ‡é€‰æ‹©
    P->>P: ä½ç½®ç§»åŠ¨è§„åˆ’

    Note over P,ES: è¡ŒåŠ¨æ‰§è¡Œé˜¶æ®µ
    P->>CS: æäº¤è¡ŒåŠ¨åºåˆ—
    CS->>CS: æŒ‰ä¼˜å…ˆçº§æ’åº
    CS->>CS: ä¾æ¬¡æ‰§è¡Œè¡ŒåŠ¨
    CS->>ES: å®æ—¶æ•ˆæœåé¦ˆ
    CS->>CS: æ’­æ”¾åŠ¨ç”»

    Note over P,ES: å›åˆç»“æŸç»“ç®—
    CS->>CS: ä¼¤å®³/æ²»ç–—ç»“ç®—
    CS->>ES: çŠ¶æ€æ•ˆæœæ›´æ–°
    CS->>CS: ç»éªŒå€¼è®¡ç®—
    CS->>TS: å›åˆç»“æŸäº‹ä»¶

    Note over P,ES: åˆ‡æ¢ä¸‹ä¸€ç©å®¶
    TS->>TS: åˆ‡æ¢åˆ°ä¸‹ä¸€ç©å®¶
    TS->>TS: é‡ç½®å›åˆçŠ¶æ€
```

#### æˆ˜æ–—å¹³è¡¡æ€§å‚æ•°
```typescript
interface TurnBasedCombatConfig {
  // å›åˆæ—¶é—´å‚æ•°
  turnTimeLimit: number;           // å›åˆæ—¶é—´é™åˆ¶ (ç§’)
  planningTimeLimit: number;       // è§„åˆ’é˜¶æ®µæ—¶é—´é™åˆ¶ (ç§’)
  executionTimeLimit: number;      // æ‰§è¡Œé˜¶æ®µæ—¶é—´é™åˆ¶ (ç§’)

  // è¡ŒåŠ¨ç‚¹æ•°å‚æ•°
  baseActionPoints: number;        // åŸºç¡€è¡ŒåŠ¨ç‚¹æ•°
  actionPointRecovery: number;     // æ¯å›åˆæ¢å¤ç‚¹æ•°
  maxActionPoints: number;         // æœ€å¤§è¡ŒåŠ¨ç‚¹æ•°

  // ä¼¤å®³è®¡ç®—å‚æ•°
  damageMultiplier: number;        // ä¼¤å®³å€ç‡
  defenseMultiplier: number;       // é˜²å¾¡å€ç‡
  criticalHitChance: number;       // æš´å‡»æ¦‚ç‡
  criticalHitMultiplier: number;   // æš´å‡»å€ç‡

  // çŠ¶æ€æ•ˆæœå‚æ•°
  maxStatusEffects: number;        // æœ€å¤§çŠ¶æ€æ•ˆæœæ•°é‡
  statusEffectDuration: number;    // çŠ¶æ€æ•ˆæœæŒç»­æ—¶é—´
  statusStackLimit: number;        // çŠ¶æ€å åŠ é™åˆ¶

  // AIå‚æ•°
  aiThinkingTime: number;          // AIæ€è€ƒæ—¶é—´ (ç§’)
  aiDifficultyMultiplier: number;  // AIéš¾åº¦å€ç‡
  aiAggressiveness: number;        // AIæ”»å‡»æ€§ (0-1)
}
```

#### å›åˆåˆ¶æˆ˜æ–—ç³»ç»Ÿç±»å›¾

```mermaid
classDiagram
    class TurnBasedCombatEngine {
        -CombatSession combatSession
        -TurnManager turnManager
        -ActionSystem actionSystem
        -EffectSystem effectSystem
        -List<Unit> participants
        +initializeCombat(participants): CombatSession
        +startTurn(currentUnit): TurnResult
        +executeAction(action): ActionResult
        +endTurn(): void
        +resolveCombat(): CombatResult
    }

    class TurnManager {
        -number currentTurn
        -Queue<Unit> turnOrder
        -Map<string, number> actionPointsPool
        -Timer turnTimer
        +calculateTurnOrder(units): Queue<Unit>
        +distributeActionPoints(units): void
        +consumeActionPoints(unit, cost): boolean
        +advanceTurn(): Unit
        +getRemainingTime(): number
    }

    class ActionSystem {
        -Queue<GameAction> pendingActions
        -Map<ActionType, Validator> actionValidators
        -Map<ActionType, Executor> actionExecutors
        +validateAction(action): ValidationResult
        +queueAction(action): boolean
        +executeNextAction(): ActionResult
        +cancelAction(actionId): boolean
        +getAvailableActions(unit): List<GameAction>
    }

    class EffectSystem {
        -Map<string, StatusEffect> activeEffects
        -Map<EffectType, Processor> effectProcessors
        -EffectScheduler effectScheduler
        +applyEffect(effect, target): EffectResult
        +removeEffect(effectId): boolean
        +updateEffects(deltaTime): void
        +getActiveEffects(unit): List<StatusEffect>
        +calculateEffectModifier(unit, stat): number
    }

    class DamageCalculator {
        -DamageFormula baseDamageFormula
        -List<DamageModifier> damageModifiers
        -Map<DefenseType, Calculator> defenseCalculators
        +calculateDamage(attacker, defender, action): DamageResult
        +applyDamageModifiers(damage, modifiers): number
        +calculateDefenseReduction(defender, damageType): number
        +calculateCriticalHit(attacker): CriticalResult
    }

    class Unit {
        -string id
        -string name
        -Position position
        -number health
        -number maxHealth
        -number attack
        -number defense
        -number speed
        -UnitType unitType
        +takeDamage(damage: number): number
        +heal(amount: number): number
        +moveTo(position: Position): boolean
        +attack(target: Unit): number
        +isAlive(): boolean
        +getAvailableActions(): List<GameAction>
    }

    class PlayerUnit {
        <<ç©å®¶æ§åˆ¶>>
        <<æ‰‹åŠ¨è¡ŒåŠ¨>>
        <<UIäº¤äº’>>
    }

    class AIUnit {
        <<AIå†³ç­–>>
        <<è‡ªåŠ¨è¡ŒåŠ¨>>
        <<ç­–ç•¥è®¡ç®—>>
    }

    class GameAction {
        -string id
        -ActionType type
        -Unit actor
        -Unit | Position target
        -ActionParameters parameters
        -number cost
        -number priority
        +validate(): ValidationResult
        +execute(): ActionResult
        +getCost(): number
        +canExecute(actor): boolean
    }

    class MoveAction {
        <<è·¯å¾„è®¡ç®—>>
        <<ä½ç½®éªŒè¯>>
        <<ç§»åŠ¨åŠ¨ç”»>>
    }

    class AttackAction {
        <<ä¼¤å®³è®¡ç®—>>
        <<èŒƒå›´æ£€æŸ¥>>
        <<æ”»å‡»åŠ¨ç”»>>
    }

    TurnBasedCombatEngine --> TurnManager : ç»„åˆ
    TurnBasedCombatEngine --> ActionSystem : ç»„åˆ
    TurnBasedCombatEngine --> EffectSystem : ç»„åˆ
    TurnBasedCombatEngine --> DamageCalculator : ç»„åˆ
    TurnBasedCombatEngine --> Unit : èšåˆ
    Unit <|-- PlayerUnit : ç»§æ‰¿
    Unit <|-- AIUnit : ç»§æ‰¿
    GameAction <|-- MoveAction : ç»§æ‰¿
    GameAction <|-- AttackAction : ç»§æ‰¿
```

#### å›åˆåˆ¶æˆ˜æ–—ç³»ç»Ÿæ—¶åºå›¾

```mermaid
sequenceDiagram
    participant TBCE as TurnBasedCombatEngine
    participant TM as TurnManager
    participant AS as ActionSystem
    participant ES as EffectSystem
    participant DC as DamageCalculator
    participant Unit as Unit

    Note over TBCE,Unit: æˆ˜æ–—åˆå§‹åŒ–é˜¶æ®µ
    TBCE->>TBCE: initializeCombat(participants)
    TBCE->>TM: åˆ›å»ºCombatSessionå®ä¾‹
    TM->>TM: åˆå§‹åŒ–TurnManager
    TM->>TM: è®¡ç®—åˆå§‹è¡ŒåŠ¨é¡ºåº
    TM->>TM: åˆ†é…åˆå§‹è¡ŒåŠ¨ç‚¹æ•°

    Note over TBCE,Unit: å›åˆæ’åºé˜¶æ®µ
    TM->>TM: calculateTurnOrder(units)
    TM->>TM: æŒ‰é€Ÿåº¦æ’åºå•ä½
    TM->>TM: å¤„ç†é€Ÿåº¦ç›¸ç­‰æƒ…å†µ
    TM->>TM: åˆ›å»ºè¡ŒåŠ¨é˜Ÿåˆ—
    TM->>TM: è¿”å›æ’åºåçš„å•ä½åˆ—è¡¨

    Note over TBCE,Unit: å›åˆå¼€å§‹é˜¶æ®µ
    TBCE->>TBCE: startTurn(currentUnit)
    TBCE->>TM: é‡ç½®å•ä½è¡ŒåŠ¨ç‚¹æ•°
    TBCE->>ES: æ¸…é™¤è¿‡æœŸçŠ¶æ€æ•ˆæœ
    ES->>ES: æ›´æ–°BUFF/DEBUFF
    TM->>TM: å¯åŠ¨å›åˆè®¡æ—¶å™¨

    Note over TBCE,Unit: è¡ŒåŠ¨éªŒè¯é˜¶æ®µ
    AS->>AS: validateAction(action)
    AS->>AS: æ£€æŸ¥è¡ŒåŠ¨ç±»å‹åˆæ³•æ€§
    AS->>TM: éªŒè¯è¡ŒåŠ¨ç‚¹æ•°å……è¶³
    AS->>AS: æ£€æŸ¥ç›®æ ‡æœ‰æ•ˆæ€§
    AS->>ES: ç¡®è®¤çŠ¶æ€å…è®¸è¡ŒåŠ¨

    Note over TBCE,Unit: è¡ŒåŠ¨æ’é˜Ÿé˜¶æ®µ
    AS->>AS: queueAction(action)
    AS->>AS: æ·»åŠ åˆ°å¾…æ‰§è¡Œé˜Ÿåˆ—
    AS->>AS: è®¾ç½®è¡ŒåŠ¨ä¼˜å…ˆçº§
    AS->>TM: é¢„æ‰£è¡ŒåŠ¨ç‚¹æ•°
    AS->>AS: å¹¿æ’­è¡ŒåŠ¨æ’é˜Ÿäº‹ä»¶

    Note over TBCE,Unit: è¡ŒåŠ¨æ‰§è¡Œé˜¶æ®µ
    AS->>AS: executeNextAction()
    AS->>AS: ä»é˜Ÿåˆ—å–å‡ºè¡ŒåŠ¨
    AS->>AS: æ‰§è¡Œè¡ŒåŠ¨éªŒè¯
    AS->>DC: è°ƒç”¨å…·ä½“æ‰§è¡Œå™¨

    Note over TBCE,Unit: ä¼¤å®³è®¡ç®—é˜¶æ®µ
    DC->>DC: calculateDamage(attacker, defender, action)
    DC->>DC: è®¡ç®—åŸºç¡€ä¼¤å®³
    DC->>DC: åº”ç”¨ä¼¤å®³ä¿®æ­£
    DC->>DC: è®¡ç®—é˜²å¾¡å‡å…
    DC->>DC: å¤„ç†æš´å‡»åˆ¤å®š

    Note over TBCE,Unit: æ•ˆæœåº”ç”¨é˜¶æ®µ
    ES->>ES: applyEffect(effect, target)
    ES->>ES: éªŒè¯æ•ˆæœåº”ç”¨æ¡ä»¶
    ES->>ES: è®¡ç®—æ•ˆæœå¼ºåº¦
    ES->>ES: è®¾ç½®æ•ˆæœæŒç»­æ—¶é—´
    ES->>ES: è§¦å‘æ•ˆæœå¼€å§‹äº‹ä»¶

    Note over TBCE,Unit: å›åˆæ¨è¿›é˜¶æ®µ
    TM->>TM: advanceTurn()
    TM->>TM: ä¿å­˜å½“å‰å›åˆæ•°æ®
    TM->>TM: åˆ‡æ¢åˆ°ä¸‹ä¸€å•ä½
    TM->>TM: é‡ç½®è¡ŒåŠ¨ç‚¹æ•°
    TM->>TM: æ›´æ–°å›åˆè®¡æ•°

    Note over TBCE,Unit: æˆ˜æ–—ç»“ç®—é˜¶æ®µ
    TBCE->>TBCE: resolveCombat()
    TBCE->>TBCE: æ£€æŸ¥èƒœåˆ©/å¤±è´¥æ¡ä»¶
    TBCE->>TBCE: è®¡ç®—æˆ˜æ–—ç»Ÿè®¡
    TBCE->>TBCE: åˆ†é…ç»éªŒå¥–åŠ±
    TBCE->>TBCE: ç”Ÿæˆæˆ˜æ–—æŠ¥å‘Š
```

### 1. å›åˆç®¡ç†å™¨ (Turn Manager)

#### å›åˆæµç¨‹æ§åˆ¶
```typescript
interface TurnManager {
  currentTurn: number;           // å½“å‰å›åˆæ•°
  currentPlayer: Player;         // å½“å‰è¡ŒåŠ¨ç©å®¶
  turnOrder: Player[];           // è¡ŒåŠ¨é¡ºåº
  turnPhase: TurnPhase;          // å›åˆé˜¶æ®µ
  actionPoints: Map<string, number>; // è¡ŒåŠ¨ç‚¹æ•°
}

enum TurnPhase {
  START = 'start',        // å›åˆå¼€å§‹
  PLANNING = 'planning',  // è§„åˆ’é˜¶æ®µ
  EXECUTION = 'execution', // æ‰§è¡Œé˜¶æ®µ
  END = 'end'            // å›åˆç»“æŸ
}
```

#### è¡ŒåŠ¨ç‚¹æ•°ç³»ç»Ÿ
```typescript
interface ActionPointSystem {
  maxPoints: number;           // æœ€å¤§è¡ŒåŠ¨ç‚¹æ•°
  currentPoints: number;       // å½“å‰å‰©ä½™ç‚¹æ•°
  pointRegeneration: number;   // æ¯å›åˆæ¢å¤ç‚¹æ•°
  actionCosts: Map<string, number>; // è¡ŒåŠ¨æ¶ˆè€—è¡¨

  consumePoints(action: string): boolean;
  regeneratePoints(): void;
  hasEnoughPoints(action: string): boolean;
}
```

#### æ—¶é—´ç®¡ç†
- **å›åˆæ—¶é™**ï¼šæ¯ä¸ªå›åˆçš„æ—¶é—´é™åˆ¶
- **è¡ŒåŠ¨æ—¶é™**ï¼šæ¯ä¸ªè¡ŒåŠ¨çš„æ—¶é—´é™åˆ¶
- **æš‚åœæœºåˆ¶**ï¼šå…è®¸ç©å®¶æš‚åœæ€è€ƒ

### 2. è¡ŒåŠ¨ç³»ç»Ÿ (Action System)

#### åŸºç¡€è¡ŒåŠ¨ç±»å‹
```typescript
enum ActionType {
  MOVE = 'move',           // ç§»åŠ¨
  ATTACK = 'attack',       // æ”»å‡»
  DEFEND = 'defend',       // é˜²å¾¡
  SKILL = 'skill',         // ä½¿ç”¨æŠ€èƒ½
  ITEM = 'item',           // ä½¿ç”¨ç‰©å“
  WAIT = 'wait',           // ç­‰å¾…
  END_TURN = 'end_turn'    // ç»“æŸå›åˆ
}

interface GameAction {
  type: ActionType;
  actor: Unit;
  target?: Unit | Position;
  parameters: ActionParameters;
  cost: number;            // è¡ŒåŠ¨ç‚¹æ•°æ¶ˆè€—
  priority: number;        // è¡ŒåŠ¨ä¼˜å…ˆçº§
}
```

#### è¡ŒåŠ¨é˜Ÿåˆ—
```typescript
interface ActionQueue {
  pendingActions: GameAction[];    // å¾…æ‰§è¡Œè¡ŒåŠ¨
  executedActions: GameAction[];   // å·²æ‰§è¡Œè¡ŒåŠ¨
  maxQueueSize: number;            // æœ€å¤§é˜Ÿåˆ—é•¿åº¦

  addAction(action: GameAction): boolean;
  removeAction(actionId: string): void;
  executeNext(): Promise<GameActionResult>;
  clearQueue(): void;
}
```

#### è¡ŒåŠ¨éªŒè¯
- **å¯è¡Œæ€§æ£€æŸ¥**ï¼šæ£€æŸ¥è¡ŒåŠ¨æ˜¯å¦å¯ä»¥æ‰§è¡Œ
- **èµ„æºéªŒè¯**ï¼šæ£€æŸ¥è¡ŒåŠ¨ç‚¹æ•°å’Œèµ„æºæ˜¯å¦å……è¶³
- **çŠ¶æ€éªŒè¯**ï¼šæ£€æŸ¥å•ä½çŠ¶æ€æ˜¯å¦å…è®¸è¡ŒåŠ¨

### 3. å•ä½ç³»ç»Ÿ (Unit System)

#### å•ä½å±æ€§
```typescript
interface Unit {
  id: string;
  name: string;
  type: UnitType;
  position: Position;

  // åŸºç¡€å±æ€§
  health: number;
  maxHealth: number;
  mana: number;
  maxMana: number;

  // æˆ˜æ–—å±æ€§
  attack: number;
  defense: number;
  speed: number;          // å½±å“è¡ŒåŠ¨é¡ºåº

  // çŠ¶æ€æ•ˆæœ
  statusEffects: StatusEffect[];
  buffs: Buff[];
  debuffs: Debuff[];

  // è¡ŒåŠ¨èƒ½åŠ›
  availableActions: ActionType[];
  movementRange: number;
}
```

#### çŠ¶æ€æ•ˆæœç³»ç»Ÿ
```typescript
interface StatusEffect {
  id: string;
  name: string;
  type: 'buff' | 'debuff' | 'neutral';
  duration: number;       // æŒç»­å›åˆæ•°
  effects: Effect[];      // å…·ä½“æ•ˆæœ
  stackable: boolean;     // æ˜¯å¦å¯å åŠ 
  maxStacks: number;      // æœ€å¤§å åŠ å±‚æ•°
}

interface Effect {
  type: 'modify_stat' | 'prevent_action' | 'damage_over_time';
  targetStat: string;     // å½±å“çš„å±æ€§
  value: number;          // æ•ˆæœæ•°å€¼
  operation: 'add' | 'multiply' | 'set'; // æ“ä½œç±»å‹
}
```

### 4. æˆ˜åœºç³»ç»Ÿ (Battlefield System)

#### ç½‘æ ¼ç³»ç»Ÿ
```typescript
interface GridSystem {
  width: number;
  height: number;
  cells: GridCell[][];

  getCell(x: number, y: number): GridCell;
  isValidPosition(position: Position): boolean;
  getNeighbors(position: Position): Position[];
  getDistance(pos1: Position, pos2: Position): number;
}

interface GridCell {
  position: Position;
  terrain: TerrainType;
  occupant: Unit | null;
  effects: CellEffect[];     // æ ¼å­æ•ˆæœï¼ˆå¦‚ç«ç„°ã€æ¯’æ°”ï¼‰
  movementCost: number;      // ç§»åŠ¨æ¶ˆè€—
}
```

#### åœ°å½¢ç³»ç»Ÿ
```typescript
enum TerrainType {
  PLAIN = 'plain',        // å¹³åŸ
  FOREST = 'forest',      // æ£®æ—
  MOUNTAIN = 'mountain',  // å±±åœ°
  WATER = 'water',        // æ°´åŸŸ
  ROAD = 'road',          // é“è·¯
  WALL = 'wall'          // å¢™å£
}

interface TerrainModifier {
  terrain: TerrainType;
  movementCost: number;     // ç§»åŠ¨æ¶ˆè€—å€ç‡
  defenseBonus: number;     // é˜²å¾¡åŠ æˆ
  attackBonus: number;      // æ”»å‡»åŠ æˆ
  visibility: number;       // è§†é‡å½±å“
}
```

#### èŒƒå›´è®¡ç®—
- **ç§»åŠ¨èŒƒå›´**ï¼šåŸºäºç§»åŠ¨åŠ›è®¡ç®—å¯åˆ°è¾¾åŒºåŸŸ
- **æ”»å‡»èŒƒå›´**ï¼šåŸºäºæ­¦å™¨ç±»å‹è®¡ç®—æ”»å‡»åŒºåŸŸ
- **æŠ€èƒ½èŒƒå›´**ï¼šåŸºäºæŠ€èƒ½ç±»å‹è®¡ç®—å½±å“åŒºåŸŸ
- **è§†é‡èŒƒå›´**ï¼šè®¡ç®—å•ä½å¯è§åŒºåŸŸ

### 5. AIç³»ç»Ÿ (AI System)

#### å†³ç­–æ ‘
```typescript
interface DecisionTree {
  root: DecisionNode;

  evaluate(gameState: GameState): GameAction;
  traverse(node: DecisionNode, context: AIContext): DecisionNode;
}

interface DecisionNode {
  condition: (context: AIContext) => boolean;
  action?: GameAction;
  children: DecisionNode[];
  priority: number;
}
```

#### ç­–ç•¥è¯„ä¼°
```typescript
interface StrategyEvaluator {
  evaluatePosition(unit: Unit, position: Position): number;
  evaluateAction(action: GameAction): number;
  evaluateThreat(unit: Unit): number;
  predictOutcome(action: GameAction): PredictionResult;
}

interface PredictionResult {
  successProbability: number;
  expectedDamage: number;
  expectedPosition: Position;
  riskLevel: 'low' | 'medium' | 'high';
}
```

#### éš¾åº¦è°ƒæ•´
- **AIå¼ºåº¦**ï¼šä»ç®€å•åˆ°å›°éš¾çš„ä¸åŒAIç­‰çº§
- **é¢„æµ‹æ·±åº¦**ï¼šAIè€ƒè™‘çš„å›åˆæ•°é‡
- **éšæœºæ€§**ï¼šAIå†³ç­–çš„éšæœºå› ç´ 

### 6. æŠ€èƒ½ç³»ç»Ÿ (Skill System)

#### ä¸»åŠ¨æŠ€èƒ½
```typescript
interface ActiveSkill {
  id: string;
  name: string;
  description: string;
  manaCost: number;
  cooldown: number;       // å†·å´å›åˆæ•°
  range: number;          // æŠ€èƒ½èŒƒå›´
  area: AreaShape;        // å½±å“åŒºåŸŸå½¢çŠ¶
  effects: SkillEffect[];
  animation: string;      // æŠ€èƒ½åŠ¨ç”»
}

enum AreaShape {
  SINGLE = 'single',      // å•ä½“
  LINE = 'line',          // ç›´çº¿
  CIRCLE = 'circle',      // åœ†å½¢
  CONE = 'cone',          // æ‰‡å½¢
  CROSS = 'cross'         // åå­—
}
```

#### è¢«åŠ¨æŠ€èƒ½
- **æŒç»­æ•ˆæœ**ï¼šå›åˆå¼€å§‹æ—¶è‡ªåŠ¨è§¦å‘
- **æ¡ä»¶è§¦å‘**ï¼šæ»¡è¶³ç‰¹å®šæ¡ä»¶æ—¶æ¿€æ´»
- **è£…å¤‡æŠ€èƒ½**ï¼šé€šè¿‡è£…å¤‡è·å¾—çš„èƒ½åŠ›

### 7. ç‰©å“ç³»ç»Ÿ (Item System)

#### ç‰©å“ç±»å‹
```typescript
enum ItemType {
  CONSUMABLE = 'consumable',    // æ¶ˆè€—å“
  EQUIPMENT = 'equipment',      // è£…å¤‡
  KEY_ITEM = 'key_item',        // å…³é”®ç‰©å“
  MATERIAL = 'material'         // ææ–™
}

interface Item {
  id: string;
  name: string;
  type: ItemType;
  description: string;
  effects: ItemEffect[];
  usableInBattle: boolean;
  usableOutBattle: boolean;
  maxQuantity: number;
}
```

#### ç‰©å“æ•ˆæœ
```typescript
interface ItemEffect {
  type: 'heal' | 'damage' | 'buff' | 'debuff' | 'teleport';
  target: 'self' | 'ally' | 'enemy' | 'area';
  value: number;
  duration: number;       // æ•ˆæœæŒç»­æ—¶é—´
  chance: number;         // è§¦å‘æ¦‚ç‡
}
```

## ğŸ”§ æ ¸å¿ƒç®—æ³•å®ç°

### å›åˆé¡ºåºç®—æ³• (Turn Order Algorithm)

#### é€Ÿåº¦æ’åº
```typescript
function calculateTurnOrder(units: Unit[]): Unit[] {
  // æŒ‰é€Ÿåº¦é™åºæ’åºï¼Œé€Ÿåº¦ç›¸åŒæ—¶éšæœºå†³å®š
  return units.sort((a, b) => {
    if (a.speed !== b.speed) {
      return b.speed - a.speed;
    }
    // é€Ÿåº¦ç›¸åŒæ—¶ï¼ŒåŠ å…¥éšæœºå› ç´ é¿å…æ­»é”
    return Math.random() - 0.5;
  });
}
```

#### è¡ŒåŠ¨ç‚¹æ•°åˆ†é…
```typescript
function distributeActionPoints(units: Unit[], totalPoints: number): Map<string, number> {
  const points = new Map<string, number>();
  const totalSpeed = units.reduce((sum, unit) => sum + unit.speed, 0);

  for (const unit of units) {
    const unitPoints = Math.floor((unit.speed / totalSpeed) * totalPoints);
    points.set(unit.id, Math.max(1, unitPoints)); // è‡³å°‘1ç‚¹
  }

  return points;
}
```

### è·¯å¾„å¯»æ‰¾ç®—æ³• (Pathfinding Algorithm)

#### A*å¯»è·¯
```typescript
function findPath(
  grid: GridSystem,
  start: Position,
  goal: Position,
  unit: Unit
): Position[] {
  const openSet = new PriorityQueue<Position>();
  const cameFrom = new Map<string, Position>();
  const gScore = new Map<string, number>();
  const fScore = new Map<string, number>();

  const startKey = `${start.x},${start.y}`;
  const goalKey = `${goal.x},${goal.y}`;

  openSet.enqueue(start, 0);
  gScore.set(startKey, 0);
  fScore.set(startKey, heuristic(start, goal));

  while (!openSet.isEmpty()) {
    const current = openSet.dequeue();

    if (current.x === goal.x && current.y === goal.y) {
      return reconstructPath(cameFrom, current);
    }

    const neighbors = grid.getNeighbors(current);
    for (const neighbor of neighbors) {
      const neighborKey = `${neighbor.x},${neighbor.y}`;
      const movementCost = grid.getCell(neighbor.x, neighbor.y).movementCost;
      const tentativeGScore = gScore.get(current.x + ',' + current.y) + movementCost;

      if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
        cameFrom.set(neighborKey, current);
        gScore.set(neighborKey, tentativeGScore);
        fScore.set(neighborKey, tentativeGScore + heuristic(neighbor, goal));

        if (!openSet.contains(neighbor)) {
          openSet.enqueue(neighbor, fScore.get(neighborKey));
        }
      }
    }
  }

  return []; // æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
}
```

### ä¼¤å®³è®¡ç®—ç®—æ³• (Damage Calculation)

#### åŸºç¡€ä¼¤å®³å…¬å¼
```typescript
function calculateDamage(
  attacker: Unit,
  defender: Unit,
  attackType: AttackType,
  modifiers: DamageModifier[] = []
): DamageResult {
  let baseDamage = attacker.attack;

  // æ”»å‡»ç±»å‹ä¿®æ­£
  switch (attackType) {
    case AttackType.PHYSICAL:
      baseDamage *= (1 + attacker.level * 0.1);
      break;
    case AttackType.MAGICAL:
      baseDamage = attacker.magicAttack;
      baseDamage *= (1 + attacker.intelligence * 0.05);
      break;
  }

  // é˜²å¾¡å‡å…
  const defenseReduction = defender.defense * (1 + defender.level * 0.05);
  let finalDamage = Math.max(0, baseDamage - defenseReduction);

  // åº”ç”¨ä¼¤å®³ä¿®æ­£
  for (const modifier of modifiers) {
    switch (modifier.type) {
      case 'multiplier':
        finalDamage *= modifier.value;
        break;
      case 'addition':
        finalDamage += modifier.value;
        break;
      case 'percentage':
        finalDamage *= (1 + modifier.value);
        break;
    }
  }

  // æš´å‡»åˆ¤å®š
  const isCritical = Math.random() < attacker.criticalChance;
  if (isCritical) {
    finalDamage *= attacker.criticalMultiplier;
  }

  return {
    damage: Math.floor(finalDamage),
    isCritical,
    attacker: attacker.id,
    defender: defender.id
  };
}
```

### AIå†³ç­–ç®—æ³• (AI Decision Algorithm)

#### æ•ˆç”¨å‡½æ•°
```typescript
function evaluateActionUtility(action: GameAction, context: AIContext): number {
  let utility = 0;

  // å¨èƒè¯„ä¼°
  if (action.type === ActionType.ATTACK) {
    const threatReduction = calculateThreatReduction(action, context);
    utility += threatReduction * 10;
  }

  // ä½ç½®ä¼˜åŠ¿
  if (action.type === ActionType.MOVE) {
    const positionalAdvantage = evaluatePositionAdvantage(action.target as Position, context);
    utility += positionalAdvantage * 5;
  }

  // ç”Ÿå­˜è€ƒè™‘
  const survivalBonus = calculateSurvivalBonus(action, context);
  utility += survivalBonus * 15;

  // éšæœºæ€§é¿å…AIè¿‡äºå®Œç¾
  utility += (Math.random() - 0.5) * 2;

  return utility;
}
```

## ğŸ“Š æ¸¸æˆæµç¨‹è®¾è®¡

### æ ‡å‡†å›åˆæµç¨‹
1. **å›åˆå¼€å§‹**ï¼šé‡ç½®è¡ŒåŠ¨ç‚¹æ•°ï¼Œåº”ç”¨æŒç»­æ•ˆæœ
2. **è¡ŒåŠ¨è§„åˆ’**ï¼šç©å®¶é€‰æ‹©è¡ŒåŠ¨å¹¶åŠ å…¥é˜Ÿåˆ—
3. **è¡ŒåŠ¨æ‰§è¡Œ**ï¼šæŒ‰ä¼˜å…ˆçº§æ‰§è¡Œé˜Ÿåˆ—ä¸­çš„è¡ŒåŠ¨
4. **æ•ˆæœç»“ç®—**ï¼šå¤„ç†ä¼¤å®³ã€æ²»ç–—ã€çŠ¶æ€å˜åŒ–
5. **å›åˆç»“æŸ**ï¼šæ£€æŸ¥èƒœåˆ©æ¡ä»¶ï¼Œè¿›å…¥ä¸‹ä¸€å›åˆ

### æˆ˜æ–—æµç¨‹
1. **æˆ˜æ–—åˆå§‹åŒ–**ï¼šè®¾ç½®æˆ˜åœºï¼Œç¡®å®šè¡ŒåŠ¨é¡ºåº
2. **å›åˆå¾ªç¯**ï¼š
   - ç©å®¶å›åˆï¼šé€‰æ‹©è¡ŒåŠ¨ï¼Œæ‰§è¡Œè¡ŒåŠ¨
   - AIå›åˆï¼šAIè¯„ä¼°ï¼Œæ‰§è¡Œæœ€ä¼˜è¡ŒåŠ¨
   - æ•ˆæœå¤„ç†ï¼šç»“ç®—æ‰€æœ‰è¡ŒåŠ¨ç»“æœ
3. **æˆ˜æ–—ç»“æŸ**ï¼šåˆ¤æ–­èƒœè´Ÿï¼Œåˆ†é…å¥–åŠ±

### ç­–ç•¥æ€è€ƒæ—¶é—´
- **æ— æ—¶é—´é™åˆ¶**ï¼šæ·±åº¦ç­–ç•¥æ€è€ƒ
- **å›åˆæ—¶é™**ï¼šå¢åŠ ç´§è¿«æ„Ÿ
- **è¡ŒåŠ¨æ—¶é™**ï¼šå¿«é€Ÿå†³ç­–è®­ç»ƒ

## ğŸ® ç©å®¶ä½“éªŒè®¾è®¡

### ç­–ç•¥æ·±åº¦
- **å¤æ‚æˆ˜æœ¯**ï¼šå¤šå•ä½ååŒä½œæˆ˜
- **èµ„æºç®¡ç†**ï¼šè¡ŒåŠ¨ç‚¹æ•°å’ŒæŠ€èƒ½å†·å´
- **é£é™©è¯„ä¼°**ï¼šé¢„æµ‹è¡ŒåŠ¨åæœ
- **è¿é”ååº”**ï¼šè¡ŒåŠ¨é—´çš„ç›¸äº’å½±å“

### è§†è§‰åé¦ˆ
- **è¡ŒåŠ¨é¢„è§ˆ**ï¼šæ˜¾ç¤ºè¡ŒåŠ¨èŒƒå›´å’Œæ•ˆæœ
- **ä¼¤å®³æ•°å­—**ï¼šç›´è§‚çš„ä¼¤å®³æ˜¾ç¤º
- **çŠ¶æ€æŒ‡ç¤º**ï¼šæ¸…æ™°çš„çŠ¶æ€æ•ˆæœæ˜¾ç¤º
- **åŠ¨ç”»è¡¨ç°**ï¼šæµç•…çš„æˆ˜æ–—åŠ¨ç”»

### éš¾åº¦æ›²çº¿
- **æ¸è¿›å¼æŒ‘æˆ˜**ï¼šéš¾åº¦éšè¿›åº¦å¢åŠ 
- **æ•™å­¦å…³å¡**ï¼šå­¦ä¹ ç³»ç»Ÿå’Œæœºåˆ¶
- **éš¾åº¦é€‰é¡¹**ï¼šä»ä¼‘é—²åˆ° hardcore
- **åŠ¨æ€è°ƒæ•´**ï¼šæ ¹æ®ç©å®¶è¡¨ç°è°ƒæ•´

## ğŸ”„ ç³»ç»Ÿä¼˜åŒ–ç­–ç•¥

### æ€§èƒ½ä¼˜åŒ–
- **å¯¹è±¡æ± **ï¼šå¤ç”¨æˆ˜æ–—å•ä½å’Œç‰¹æ•ˆ
- **ç©ºé—´åˆ†åŒº**ï¼šç½‘æ ¼ç³»ç»Ÿä¼˜åŒ–ç¢°æ’æ£€æµ‹
- **å¼‚æ­¥è®¡ç®—**ï¼šAIå†³ç­–å¼‚æ­¥å¤„ç†
- **ç¼“å­˜æœºåˆ¶**ï¼šç¼“å­˜è·¯å¾„å’ŒèŒƒå›´è®¡ç®—

### ç½‘ç»œåŒæ­¥ï¼ˆå¤šäººæ¸¸æˆï¼‰
- **ç¡®å®šæ€§å›æ”¾**ï¼šç¡®ä¿æ‰€æœ‰å®¢æˆ·ç«¯åŒæ­¥
- **å»¶è¿Ÿè¡¥å¿**ï¼šé¢„æµ‹å’Œå›æ»šæœºåˆ¶
- **çŠ¶æ€åŒæ­¥**ï¼šå®šæœŸåŒæ­¥æ¸¸æˆçŠ¶æ€
- **è¾“å…¥ç¼“å†²**ï¼šå¤„ç†ç½‘ç»œå»¶è¿Ÿ

## ğŸ“ˆ æ‰©å±•æ€§è®¾è®¡

### æ¨¡ç»„æ”¯æŒ
- **è‡ªå®šä¹‰å•ä½**ï¼šåˆ›å»ºæ–°çš„å•ä½ç±»å‹
- **åœ°å›¾ç¼–è¾‘å™¨**ï¼šè®¾è®¡è‡ªå®šä¹‰æˆ˜åœº
- **è§„åˆ™ä¿®æ”¹å™¨**ï¼šè°ƒæ•´æ¸¸æˆè§„åˆ™
- **AIè„šæœ¬**ï¼šè‡ªå®šä¹‰AIè¡Œä¸º

### å¤šäººæ‰©å±•
- **æœ¬åœ°å¤šäºº**ï¼šåˆ†å±æˆ–è½®æµæ“ä½œ
- **åœ¨çº¿å¤šäºº**ï¼šå®æ—¶ç½‘ç»œå¯¹æˆ˜
- **è§‚æˆ˜æ¨¡å¼**ï¼šè§‚çœ‹å…¶ä»–ç©å®¶æ¸¸æˆ
- **é”¦æ ‡èµ›ç³»ç»Ÿ**ï¼šç«æŠ€æ¯”èµ›åŠŸèƒ½

## ğŸ¯ æ ¸å¿ƒæˆåŠŸè¦ç´ 

1. **ç­–ç•¥æ·±åº¦**ï¼šä¸°å¯Œçš„æˆ˜æœ¯é€‰æ‹©å’Œå†³ç­–ç©ºé—´
2. **å¹³è¡¡æ€§**ï¼šå„å•ä½å’ŒæŠ€èƒ½çš„åˆç†å¹³è¡¡
3. **æµç•…æ€§**ï¼šç›´è§‚çš„æ“ä½œå’Œæ¸…æ™°çš„åé¦ˆ
4. **é‡ç©æ€§**ï¼šå¤šæ ·åŒ–çš„æˆ˜æœ¯ç»„åˆ
5. **æ•™å­¦æ€§**ï¼šè‰¯å¥½çš„ä¸Šæ‰‹æ›²çº¿å’Œæ•™å­¦è®¾è®¡

---

*å›åˆåˆ¶æ¸¸æˆçš„æ ¸å¿ƒé­…åŠ›åœ¨äºç­–ç•¥æ€è€ƒçš„ä¹è¶£ï¼Œé€šè¿‡ç²¾å¿ƒè®¾è®¡çš„å›åˆæœºåˆ¶å’Œä¸°å¯Œçš„æˆ˜æœ¯é€‰æ‹©ï¼Œå¯ä»¥åˆ›é€ å‡ºè€ç©æ€§æå¼ºçš„ç­–ç•¥ä½“éªŒã€‚*
