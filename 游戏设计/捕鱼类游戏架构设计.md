# æ•é±¼ç±»æ¸¸æˆæ¶æ„è®¾è®¡

## ğŸ¯ æ¸¸æˆæ¦‚è¿°

æ•é±¼ç±»æ¸¸æˆæ˜¯ä¸€ç§ä¼‘é—²ç›Šæ™ºæ¸¸æˆï¼Œç©å®¶é€šè¿‡å‘å°„ç‚®å¼¹å‡»ä¸­æ¸¸åŠ¨çš„é±¼ç±»è·å¾—åˆ†æ•°å’Œå¥–åŠ±ã€‚ä»£è¡¨ä½œå“åŒ…æ‹¬ã€Šæ•é±¼è¾¾äººã€‹ã€ã€Šæµ·ç‹ã€‹ç­‰ã€‚æ ¸å¿ƒç©æ³•å›´ç»•ç„å‡†å°„å‡»ã€é±¼ç±»è¡Œä¸ºã€æ¦‚ç‡å¥–åŠ±å’Œé“å…·ç³»ç»Ÿå±•å¼€ã€‚

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„æ¨¡å—

### 0. æ ¸å¿ƒæˆ˜æ–—æ¨¡å— (Combat System)

#### æ•é±¼æˆ˜æ–—æ¨¡å¼æ¶æ„å›¾

```mermaid
flowchart TD
    subgraph æ•é±¼æˆ˜æ–—ç³»ç»Ÿæ¶æ„
        A[ç„å‡†å‘å°„]
        B[å¼¹é“é£è¡Œ]
        C[å‘½ä¸­æ£€æµ‹]
        D[å¥–åŠ±ç»“ç®—ç³»ç»Ÿ]

        A --> B
        B --> C
        C --> D

        subgraph ç„å‡†å‘å°„è¯¦æƒ…
            A1[è§’åº¦è®¡ç®—]
            A2[å¨åŠ›é€‰æ‹©]
            A3[æŠ€èƒ½é‡Šæ”¾]
        end

        subgraph å¼¹é“é£è¡Œè¯¦æƒ…
            B1[è½¨è¿¹è®¡ç®—]
            B2[ç‰©ç†æ¨¡æ‹Ÿ]
            B3[ç‰¹æ•ˆæ˜¾ç¤º]
        end

        subgraph å‘½ä¸­æ£€æµ‹è¯¦æƒ…
            C1[ç¢°æ’æ£€æµ‹]
            C2[ä¼¤å®³è®¡ç®—]
            C3[å‡»æ€åˆ¤å®š]
        end

        subgraph å¥–åŠ±ç»“ç®—è¯¦æƒ…
            D1[é‡‘å¸æ‰è½]
            D2[é“å…·å¥–åŠ±]
            D3[è¿å‡»åŠ æˆ]
            D4[æˆå°±è§£é”]
        end

        A --> A1
        A --> A2
        A --> A3

        B --> B1
        B --> B2
        B --> B3

        C --> C1
        C --> C2
        C --> C3

        D --> D1
        D --> D2
        D --> D3
        D --> D4
    end

    style A fill:#e6f7ff
    style B fill:#bae7ff
    style C fill:#91d5ff
    style D fill:#52c41a
```

#### æ•é±¼æˆ˜æ–—ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶

```mermaid
mindmap
  root((æ•é±¼æˆ˜æ–—å¼•æ“))
    ç‚®å°ç³»ç»Ÿ
      ç„å‡†æ§åˆ¶å™¨
      å‘å°„ç®¡ç†å™¨
      å¼¹è¯é€‰æ‹©å™¨
      æŠ€èƒ½æ¿€æ´»å™¨
    å¼¹é“ç³»ç»Ÿ
      è½¨è¿¹è®¡ç®—å™¨
      ç‰©ç†æ¨¡æ‹Ÿå™¨
      ç¢°æ’æ£€æµ‹å™¨
      ç‰¹æ•ˆæ¸²æŸ“å™¨
    é±¼ç±»ç®¡ç†ç³»ç»Ÿ
      é±¼ç±»ç”Ÿæˆå™¨
      è¡Œä¸ºæ§åˆ¶å™¨
      çŠ¶æ€ç®¡ç†å™¨
      AIå†³ç­–å™¨
    ä¼¤å®³è®¡ç®—ç³»ç»Ÿ
      åŸºç¡€ä¼¤å®³è®¡ç®—å™¨
      æš´å‡»å¤„ç†å™¨
      å…ƒç´ ç›¸å…‹å¤„ç†å™¨
      è¿å‡»å€ç‡è®¡ç®—å™¨
    å¥–åŠ±åˆ†å‘ç³»ç»Ÿ
      é‡‘å¸æ‰è½å™¨
      é“å…·ç”Ÿæˆå™¨
      ç»éªŒåˆ†é…å™¨
      æˆå°±æ£€æŸ¥å™¨
    è¿å‡»ç³»ç»Ÿ
      è¿å‡»è®¡æ•°å™¨
      å€ç‡ç´¯åŠ å™¨
      æ—¶é—´çª—å£ç®¡ç†å™¨
      å¥–åŠ±å¢å¼ºå™¨
```

#### æ•é±¼æˆ˜æ–—çŠ¶æ€æœºæ¶æ„å›¾

```mermaid
stateDiagram-v2
    [*] --> Preparation

    state "å‡†å¤‡çŠ¶æ€" as Preparation {
        [*] --> SceneLoading
        SceneLoading --> TurretInit
        TurretInit --> FishSpawn
        FishSpawn --> UIReady
        UIReady --> [*]

        SceneLoading : åœºæ™¯åŠ è½½
        TurretInit : ç‚®å°åˆå§‹åŒ–
        FishSpawn : é±¼ç±»ç”Ÿæˆ
        UIReady : UIå‡†å¤‡
    }

    Preparation --> Aiming

    state "ç„å‡†çŠ¶æ€" as Aiming {
        [*] --> AngleCalc
        AngleCalc --> TrajectoryPrev
        TrajectoryPrev --> PowerSelect
        PowerSelect --> SkillSelect
        SkillSelect --> [*]

        AngleCalc : è§’åº¦è®¡ç®—
        TrajectoryPrev : è½¨è¿¹é¢„è§ˆ
        PowerSelect : å¨åŠ›é€‰æ‹©
        SkillSelect : æŠ€èƒ½é€‰æ‹©
    }

    Aiming --> Firing

    state "å‘å°„çŠ¶æ€" as Firing {
        [*] --> TrajectoryCalc
        TrajectoryCalc --> PhysicsSim
        PhysicsSim --> AnimationPlay
        AnimationPlay --> SoundTrig
        SoundTrig --> [*]

        TrajectoryCalc : å¼¹é“è®¡ç®—
        PhysicsSim : ç‰©ç†æ¨¡æ‹Ÿ
        AnimationPlay : åŠ¨ç”»æ’­æ”¾
        SoundTrig : éŸ³æ•ˆè§¦å‘
    }

    Firing --> Flight

    state "é£è¡ŒçŠ¶æ€" as Flight {
        [*] --> RealTimeUpdate
        RealTimeUpdate --> CollisionDetect
        CollisionDetect --> EffectRender
        EffectRender --> StateSync
        StateSync --> [*]

        RealTimeUpdate : å®æ—¶è½¨è¿¹æ›´æ–°
        CollisionDetect : ç¢°æ’æ£€æµ‹
        EffectRender : ç‰¹æ•ˆæ¸²æŸ“
        StateSync : çŠ¶æ€åŒæ­¥
    }

    Flight --> Hit : å‘½ä¸­
    Flight --> Flight : æœªå‘½ä¸­

    state "å‘½ä¸­çŠ¶æ€" as Hit {
        [*] --> DamageCalc
        DamageCalc --> FishUpdate
        FishUpdate --> KillJudge
        KillJudge --> ChainTrigger
        ChainTrigger --> RewardCalc
        RewardCalc --> [*]

        DamageCalc : ä¼¤å®³è®¡ç®—
        FishUpdate : é±¼ç±»çŠ¶æ€æ›´æ–°
        KillJudge : å‡»æ€åˆ¤å®š
        ChainTrigger : è¿é”ååº”è§¦å‘
        RewardCalc : å¥–åŠ±è®¡ç®—
    }

    Hit --> Chain : è§¦å‘è¿é”
    Hit --> Resolution : æ— è¿é”

    state "è¿é”çŠ¶æ€" as Chain {
        [*] --> ChainDetect
        ChainDetect --> MultiHitCalc
        MultiHitCalc --> ComboAccum
        ComboAccum --> RewardMulti
        RewardMulti --> EffectChain
        EffectChain --> [*]

        ChainDetect : è¿é”é±¼ç±»æ£€æµ‹
        MultiHitCalc : å¤šé‡å‘½ä¸­è®¡ç®—
        ComboAccum : è¿å‡»å€ç‡ç´¯ç§¯
        RewardMulti : å¥–åŠ±å€å¢
        EffectChain : ç‰¹æ•ˆè¿é”
    }

    Chain --> Resolution

    state "ç»“ç®—çŠ¶æ€" as Resolution {
        [*] --> FinalReward
        FinalReward --> CoinAnim
        CoinAnim --> ItemDistribute
        ItemDistribute --> StatUpdate
        StatUpdate --> Achievement
        Achievement --> [*]

        FinalReward : æœ€ç»ˆå¥–åŠ±è®¡ç®—
        CoinAnim : é‡‘å¸æ‰è½åŠ¨ç”»
        ItemDistribute : é“å…·å¥–åŠ±åˆ†å‘
        StatUpdate : ç»Ÿè®¡æ•°æ®æ›´æ–°
        Achievement : æˆå°±æ£€æŸ¥
    }

    Resolution --> End

    state "ç»“æŸçŠ¶æ€" as End {
        [*] --> SceneClean
        SceneClean --> DataPersist
        DataPersist --> NextWavePrep
        NextWavePrep --> PlayerUpdate
        PlayerUpdate --> [*]

        SceneClean : åœºæ™¯æ¸…ç†
        DataPersist : æ•°æ®æŒä¹…åŒ–
        NextWavePrep : ä¸‹ä¸€æ³¢å‡†å¤‡
        PlayerUpdate : ç©å®¶çŠ¶æ€æ›´æ–°
    }

    End --> [*]

    note right of Flight : å¯èƒ½æ²¡æœ‰å‘½ä¸­
    note right of Hit : å¯èƒ½è§¦å‘è¿é”
    note right of Chain : å¯èƒ½æœ‰å¤šé‡è¿é”
```

#### ç‚®å¼¹è½¨è¿¹æˆ˜æ–—æµç¨‹å›¾

```mermaid
sequenceDiagram
    participant P as ç©å®¶
    participant TS as ç‚®å°ç³»ç»Ÿ
    participant PS as å¼¹é“ç³»ç»Ÿ
    participant CD as ç¢°æ’æ£€æµ‹
    participant FM as é±¼ç±»ç®¡ç†
    participant DC as ä¼¤å®³è®¡ç®—
    participant RS as å¥–åŠ±ç³»ç»Ÿ

    Note over P,RS: å‘å°„å‡†å¤‡é˜¶æ®µ
    P->>TS: å‘å°„æŒ‡ä»¤
    TS->>TS: è®¡ç®—å‘å°„è§’åº¦
    TS->>TS: ç¡®å®šåˆå§‹é€Ÿåº¦
    TS->>TS: è€ƒè™‘é£åŠ›å½±å“
    TS->>TS: è®¾ç½®å¼¹é“è½¨è¿¹

    Note over P,RS: é£è¡Œæ¨¡æ‹Ÿé˜¶æ®µ
    TS->>PS: å‘å°„ç‚®å¼¹
    PS->>PS: å®æ—¶ä½ç½®æ›´æ–°
    PS->>PS: åº”ç”¨é‡åŠ›æ•ˆæœ
    PS->>PS: è®¡ç®—é£é˜»
    PS->>PS: è½¨è¿¹å¯è§†åŒ–

    Note over P,RS: ç¢°æ’æ£€æµ‹é˜¶æ®µ
    PS->>CD: ç¢°æ’æ£€æµ‹è¯·æ±‚
    CD->>FM: é±¼ç±»ç¢°æ’æ£€æµ‹
    CD->>CD: éšœç¢ç‰©ç¢°æ’æ£€æµ‹
    CD->>CD: è¾¹ç•Œç¢°æ’æ£€æµ‹
    CD->>CD: ç©¿é€æ•ˆæœå¤„ç†

    Note over P,RS: å‘½ä¸­ç»“ç®—é˜¶æ®µ
    CD->>DC: å‘½ä¸­äº‹ä»¶
    DC->>DC: è®¡ç®—å®é™…ä¼¤å®³
    DC->>DC: åº”ç”¨æš´å‡»æ•ˆæœ
    DC->>DC: è§¦å‘ç‰¹æ®Šæ•ˆæœ
    DC->>FM: æ›´æ–°é±¼ç±»çŠ¶æ€

    Note over P,RS: è¿é”ååº”é˜¶æ®µ
    FM->>FM: æ£€æµ‹è¿é”ç›®æ ‡
    FM->>DC: è®¡ç®—è¿é”ä¼¤å®³
    DC->>DC: ç´¯ç§¯è¿å‡»å€ç‡
    DC->>DC: è¿é”ç‰¹æ•ˆæ˜¾ç¤º

    Note over P,RS: å¥–åŠ±ç»“ç®—é˜¶æ®µ
    DC->>RS: ç»“ç®—è¯·æ±‚
    RS->>RS: è®¡ç®—åŸºç¡€å¥–åŠ±
    RS->>RS: åº”ç”¨è¿å‡»å€ç‡
    RS->>RS: ç”Ÿæˆæ‰è½ç‰©å“
    RS->>RS: æ›´æ–°ç©å®¶ç»Ÿè®¡

    Note over P,RS: å‡†å¤‡ä¸‹ä¸€å‘
    RS->>P: ç»“ç®—å®Œæˆ
    P->>TS: å‡†å¤‡ä¸‹ä¸€å‘ç‚®å¼¹
```

#### é±¼ç±»æˆ˜æ–—å±æ€§çŸ©é˜µå›¾

```mermaid
flowchart TD
    subgraph "æ™®é€šé±¼ç±»æˆ˜æ–—å±æ€§"
        N1[å°é±¼<br/>HP: 1<br/>é‡‘å¸: 1<br/>é€Ÿåº¦: å¿«<br/>é€ƒè·‘ç‡: ä½]
        N2[ä¸­é±¼<br/>HP: 3<br/>é‡‘å¸: 3<br/>é€Ÿåº¦: ä¸­<br/>é€ƒè·‘ç‡: ä¸­]
        N3[å¤§é±¼<br/>HP: 5<br/>é‡‘å¸: 5<br/>é€Ÿåº¦: æ…¢<br/>é€ƒè·‘ç‡: é«˜]
    end

    subgraph "ç‰¹æ®Šé±¼ç±»æˆ˜æ–—å±æ€§"
        S1[é»„é‡‘é±¼<br/>HP: 10<br/>é‡‘å¸: 20<br/>ç‰¹æ•ˆ: é‡‘å…‰<br/>è¿é”: +5]
        S2[ç‚¸å¼¹é±¼<br/>HP: 8<br/>é‡‘å¸: 15<br/>ç‰¹æ•ˆ: çˆ†ç‚¸<br/>è¿é”: +3]
        S3[å†°å†»é±¼<br/>HP: 6<br/>é‡‘å¸: 12<br/>ç‰¹æ•ˆ: å†°å†»<br/>è¿é”: +2]
    end

    subgraph "BOSSé±¼ç±»æˆ˜æ–—å±æ€§"
        B1[æµ·é¾™ç‹<br/>HP: 100<br/>é‡‘å¸: 100<br/>æŠ€èƒ½: å¤šé‡<br/>å¥–åŠ±: è±ªå]
        B2[ç« é±¼æ€ª<br/>HP: 80<br/>é‡‘å¸: 80<br/>æŠ€èƒ½: è§¦æ‰‹<br/>å¥–åŠ±: ç‰¹æ®Š]
        B3[é²¨é±¼ç‹<br/>HP: 60<br/>é‡‘å¸: 60<br/>æŠ€èƒ½: å†²é”‹<br/>å¥–åŠ±: çè´µ]
    end

    F[é±¼ç±»ç±»å‹] --> N1
    F --> S1
    F --> B1

    N1 --> N2 --> N3
    S1 --> S2 --> S3
    B1 --> B2 --> B3

    style N1 fill:#e6f7ff
    style N2 fill:#bae7ff
    style N3 fill:#91d5ff
    style S1 fill:#fff7e6
    style S2 fill:#ffe7ba
    style S3 fill:#ffd591
    style B1 fill:#ffe6e6
    style B2 fill:#ffcccc
    style B3 fill:#ffaaaa
```

#### æˆ˜æ–—å¹³è¡¡æ€§å‚æ•°
```typescript
interface FishingCombatConfig {
  // ç‚®å¼¹å‚æ•°
  baseDamage: number;               // åŸºç¡€ä¼¤å®³
  criticalHitChance: number;        // æš´å‡»æ¦‚ç‡
  criticalMultiplier: number;       // æš´å‡»å€ç‡
  projectileSpeed: number;          // ç‚®å¼¹é€Ÿåº¦
  projectileGravity: number;        // é‡åŠ›å½±å“

  // é±¼ç±»å‚æ•°
  baseFishHP: number;               // åŸºç¡€é±¼ç±»è¡€é‡
  hpScalingFactor: number;          // è¡€é‡ç¼©æ”¾å› å­
  coinRewardMultiplier: number;     // é‡‘å¸å¥–åŠ±å€ç‡
  escapeSpeedMultiplier: number;    // é€ƒè·‘é€Ÿåº¦å€ç‡

  // è¿å‡»ç³»ç»Ÿå‚æ•°
  comboTimeWindow: number;          // è¿å‡»æ—¶é—´çª—å£ (ç§’)
  maxComboMultiplier: number;       // æœ€å¤§è¿å‡»å€ç‡
  comboDecayRate: number;           // è¿å‡»è¡°å‡ç‡

  // ç‰¹æ®Šæ•ˆæœå‚æ•°
  freezeDuration: number;           // å†°å†»æŒç»­æ—¶é—´
  fireDamageOverTime: number;       // ç«ç„°æŒç»­ä¼¤å®³
  lightningChainRange: number;      // é›·ç”µè¿é”èŒƒå›´
  pierceCount: number;              // ç©¿é€æ•°é‡

  // AIå‚æ•°
  fishEscapeThreshold: number;      // é±¼ç±»é€ƒè·‘é˜ˆå€¼
  threatDetectionRange: number;     // å¨èƒæ£€æµ‹èŒƒå›´
  behaviorUpdateFrequency: number;  // è¡Œä¸ºæ›´æ–°é¢‘ç‡
}
```

#### æ•é±¼æˆ˜æ–—ç³»ç»Ÿç±»å›¾

```mermaid
classDiagram
    class FishingCombatEngine {
        -Turret turret
        -ProjectileManager projectileManager
        -FishManager fishManager
        -DamageCalculator damageCalculator
        -RewardSystem rewardSystem
        +initializeScene(sceneData): SceneSession
        +fireProjectile(angle, power): Projectile
        +updateProjectiles(deltaTime): void
        +checkCollisions(): CollisionResult
        +processHits(hits): HitResult
        +calculateRewards(): RewardResult
    }

    class TurretSystem {
        -Vector2D position
        -number angle
        -number power
        -ProjectileType projectileType
        -number upgradeLevel
        +aimAt(target: Vector2D): number
        +fire(power: number): Projectile
        +upgrade(): boolean
        +switchProjectile(type: ProjectileType): boolean
        +getTrajectoryPreview(): Trajectory
    }

    class ProjectileSystem {
        -List<Projectile> activeProjectiles
        -TrajectoryCalculator trajectoryCalculator
        -PhysicsSimulator physicsSimulator
        -CollisionDetector collisionDetector
        +createProjectile(type, position, velocity): Projectile
        +updateProjectiles(deltaTime): void
        +calculateTrajectory(projectile): Trajectory
        +checkCollisions(projectile): CollisionResult
        +destroyProjectile(projectile): void
    }

    class FishManager {
        -List<Fish> activeFish
        -FishSpawner fishSpawner
        -FishAIController aiController
        -FishBehaviorSystem behaviorSystem
        +spawnFish(type, position): Fish
        +updateFish(deltaTime): void
        +processHit(fish, damage): HitResult
        +removeFish(fish): void
        +getNearbyFish(position, radius): List<Fish>
        +triggerFishBehavior(fish, event): void
    }

    class DamageCalculator {
        -DamageFormula baseDamageFormula
        -List<DamageModifier> damageModifiers
        -CriticalCalculator criticalCalculator
        -ElementalCalculator elementalCalculator
        +calculateDamage(attacker, defender, projectile): DamageResult
        +applyDamageModifiers(damage, modifiers): number
        +calculateCriticalHit(projectile): CriticalResult
        +calculateElementalBonus(projectile, fish): ElementalBonus
    }

    class RewardSystem {
        -CoinCalculator coinCalculator
        -ItemDropper itemDropper
        -ComboTracker comboTracker
        -AchievementChecker achievementChecker
        +calculateCoinReward(fish, combo): number
        +dropItems(fish, luck): List<Item>
        +updateCombo(hit): ComboResult
        +checkAchievements(hit): List<Achievement>
        +distributeRewards(rewards): void
    }

    class Fish {
        -string id
        -FishType type
        -Vector2D position
        -Vector2D velocity
        -number health
        -number maxHealth
        -number speed
        -number value
        -FishBehavior behavior
        +update(deltaTime): void
        +takeDamage(damage: number): number
        +moveTo(target: Vector2D): void
        +changeBehavior(newBehavior: FishBehavior): void
        +isAlive(): boolean
        +getHitbox(): Rectangle
    }

    class NormalFish {
        <<æ ‡å‡†ç§»åŠ¨>>
        <<åŸºç¡€å¥–åŠ±>>
        <<æ™®é€šè¡Œä¸º>>
    }

    class SpecialFish {
        <<ç‰¹æ®Šç§»åŠ¨>>
        <<å¢å¼ºå¥–åŠ±>>
        <<ç‰¹æ®Šè¡Œä¸º>>
    }

    class Projectile {
        -string id
        -ProjectileType type
        -Vector2D position
        -Vector2D velocity
        -number damage
        -number lifetime
        -List<ProjectileEffect> effects
        +update(deltaTime): void
        +checkCollision(target): boolean
        +applyEffect(target): EffectResult
        +destroy(): void
        +getTrajectory(): Trajectory
    }

    class NormalProjectile {
        <<æ ‡å‡†è½¨è¿¹>>
        <<åŸºç¡€ä¼¤å®³>>
        <<æ™®é€šæ•ˆæœ>>
    }

    class SpecialProjectile {
        <<ç‰¹æ®Šè½¨è¿¹>>
        <<å¢å¼ºä¼¤å®³>>
        <<ç‰¹æ®Šæ•ˆæœ>>
    }

    FishingCombatEngine --> TurretSystem : ç»„åˆ
    FishingCombatEngine --> ProjectileSystem : ç»„åˆ
    FishingCombatEngine --> FishManager : ç»„åˆ
    FishingCombatEngine --> DamageCalculator : ç»„åˆ
    FishingCombatEngine --> RewardSystem : ç»„åˆ
    Fish <|-- NormalFish : ç»§æ‰¿
    Fish <|-- SpecialFish : ç»§æ‰¿
    Projectile <|-- NormalProjectile : ç»§æ‰¿
    Projectile <|-- SpecialProjectile : ç»§æ‰¿
```

#### æ•é±¼æˆ˜æ–—ç³»ç»Ÿæ—¶åºå›¾

```mermaid
sequenceDiagram
    participant FCE as FishingCombatEngine
    participant TS as TurretSystem
    participant PS as ProjectileSystem
    participant FM as FishManager
    participant DC as DamageCalculator
    participant RS as RewardSystem

    Note over FCE,RS: ç‚®å¼¹å‘å°„é˜¶æ®µ
    FCE->>FCE: fireProjectile(angle, power)
    FCE->>TS: éªŒè¯ç‚®å°çŠ¶æ€
    TS->>TS: è®¡ç®—å‘å°„å‚æ•°
    TS->>PS: åˆ›å»ºç‚®å¼¹å®ä¾‹
    PS->>PS: æ·»åŠ åˆ°æ´»åŠ¨åˆ—è¡¨

    Note over FCE,RS: ç‚®å¼¹å‘å°„é˜¶æ®µ
    TS->>TS: fire(power)
    TS->>TS: è®¡ç®—å‘å°„è§’åº¦
    TS->>TS: ç¡®å®šåˆå§‹é€Ÿåº¦
    TS->>PS: è®¾ç½®ç‚®å¼¹å±æ€§
    PS->>PS: è§¦å‘å‘å°„äº‹ä»¶

    Note over FCE,RS: å¼¹é“åˆ›å»ºé˜¶æ®µ
    PS->>PS: createProjectile(type, position, velocity)
    PS->>PS: åˆå§‹åŒ–ç‚®å¼¹å±æ€§
    PS->>PS: è®¾ç½®è¿åŠ¨å‚æ•°
    PS->>PS: é…ç½®ç¢°æ’æ£€æµ‹
    PS->>FCE: è¿”å›ç‚®å¼¹å®ä¾‹

    Note over FCE,RS: å¼¹é“æ›´æ–°é˜¶æ®µ
    FCE->>FCE: updateProjectiles(deltaTime)
    FCE->>PS: æ›´æ–°æ‰€æœ‰ç‚®å¼¹ä½ç½®
    PS->>PS: åº”ç”¨ç‰©ç†æ•ˆæœ
    PS->>PS: æ£€æŸ¥ç”Ÿå‘½å‘¨æœŸ
    PS->>FCE: æ‰§è¡Œç¢°æ’æ£€æµ‹

    Note over FCE,RS: ç¢°æ’æ£€æµ‹é˜¶æ®µ
    PS->>PS: checkCollisions(projectile)
    PS->>FM: è·å–é™„è¿‘é±¼ç±»
    FM->>PS: è¿”å›é±¼ç±»åˆ—è¡¨
    PS->>PS: è®¡ç®—ç¢°æ’æ£€æµ‹
    PS->>PS: ç¡®å®šå‘½ä¸­ç›®æ ‡
    PS->>FCE: è¿”å›ç¢°æ’ç»“æœ

    Note over FCE,RS: ç¢°æ’å¤„ç†é˜¶æ®µ
    FCE->>FCE: checkCollisions()
    FCE->>FCE: å¤„ç†æ‰€æœ‰ç¢°æ’
    FCE->>DC: è®¡ç®—å‘½ä¸­ä¼¤å®³
    DC->>DC: è®¡ç®—åŸºç¡€ä¼¤å®³
    DC->>DC: åº”ç”¨æš´å‡»åŠ æˆ
    DC->>DC: è®¡ç®—å…ƒç´ ç›¸å…‹
    DC->>FCE: è¿”å›æœ€ç»ˆä¼¤å®³

    Note over FCE,RS: ä¼¤å®³åº”ç”¨é˜¶æ®µ
    FCE->>FM: processHit(fish, damage)
    FM->>FM: åº”ç”¨ä¼¤å®³åˆ°é±¼ç±»
    FM->>FM: æ£€æŸ¥é±¼ç±»å­˜æ´»çŠ¶æ€
    FM->>FM: è§¦å‘æ­»äº¡åŠ¨ç”»
    FM->>FM: è®°å½•å‡»æ€ç»Ÿè®¡

    Note over FCE,RS: å‘½ä¸­å¤„ç†é˜¶æ®µ
    FCE->>FCE: processHits(hits)
    FCE->>RS: å¤„ç†æ‰€æœ‰å‘½ä¸­
    RS->>RS: æ›´æ–°è¿å‡»è®¡æ•°
    RS->>RS: è§¦å‘è¿é”ååº”
    RS->>RS: æ’­æ”¾å‘½ä¸­ç‰¹æ•ˆ

    Note over FCE,RS: å¥–åŠ±è®¡ç®—é˜¶æ®µ
    RS->>RS: calculateCoinReward(fish, combo)
    RS->>RS: è®¡ç®—åŸºç¡€é‡‘å¸
    RS->>RS: åº”ç”¨è¿å‡»å€ç‡
    RS->>RS: æ·»åŠ é±¼ç±»å€ç‡
    RS->>FCE: è¿”å›æœ€ç»ˆå¥–åŠ±

    Note over FCE,RS: å¥–åŠ±ç»“ç®—é˜¶æ®µ
    FCE->>FCE: calculateRewards()
    FCE->>RS: æ±‡æ€»æ‰€æœ‰å¥–åŠ±
    RS->>RS: æ£€æŸ¥é“å…·æ‰è½
    RS->>RS: æ›´æ–°ç©å®¶ç»Ÿè®¡
    RS->>RS: ä¿å­˜å¥–åŠ±è®°å½•
```

### 1. ç‰©ç†å¼•æ“ç³»ç»Ÿ (Physics Engine System)

#### å‘é‡æ•°å­¦åŸºç¡€
```typescript
class Vector2D {
  constructor(public x: number = 0, public y: number = 0) {}

  // å‘é‡åŠ æ³•
  add(other: Vector2D): Vector2D {
    return new Vector2D(this.x + other.x, this.y + other.y);
  }

  // å‘é‡å‡æ³•
  subtract(other: Vector2D): Vector2D {
    return new Vector2D(this.x - other.x, this.y - other.y);
  }

  // å‘é‡ä¹˜æ³•ï¼ˆæ ‡é‡ï¼‰
  multiply(scalar: number): Vector2D {
    return new Vector2D(this.x * scalar, this.y * scalar);
  }

  // å‘é‡é•¿åº¦
  magnitude(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  // å‘é‡æ ‡å‡†åŒ–
  normalize(): Vector2D {
    const mag = this.magnitude();
    if (mag === 0) return new Vector2D(0, 0);
    return new Vector2D(this.x / mag, this.y / mag);
  }

  // å‘é‡ç‚¹ç§¯
  dot(other: Vector2D): number {
    return this.x * other.x + this.y * other.y;
  }

  // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
  static distance(a: Vector2D, b: Vector2D): number {
    return a.subtract(b).magnitude();
  }

  // è®¡ç®—æ–¹å‘å‘é‡
  static direction(from: Vector2D, to: Vector2D): Vector2D {
    return to.subtract(from).normalize();
  }
}
```

#### ç¢°æ’æ£€æµ‹ç³»ç»Ÿ
```typescript
enum CollisionShape {
  CIRCLE = 'circle',
  RECTANGLE = 'rectangle',
  POLYGON = 'polygon'
}

interface CollisionBody {
  id: string;
  position: Vector2D;
  shape: CollisionShape;
  radius?: number;        // åœ†å½¢åŠå¾„
  width?: number;         // çŸ©å½¢å®½åº¦
  height?: number;        // çŸ©å½¢é«˜åº¦
  vertices?: Vector2D[];  // å¤šè¾¹å½¢é¡¶ç‚¹
}

class CollisionDetector {
  // åœ†å½¢ç¢°æ’æ£€æµ‹
  static circleCollision(
    pos1: Vector2D,
    radius1: number,
    pos2: Vector2D,
    radius2: number
  ): boolean {
    const distance = Vector2D.distance(pos1, pos2);
    return distance <= (radius1 + radius2);
  }

  // çŸ©å½¢ç¢°æ’æ£€æµ‹
  static rectangleCollision(
    pos1: Vector2D,
    width1: number,
    height1: number,
    pos2: Vector2D,
    width2: number,
    height2: number
  ): boolean {
    return (
      pos1.x < pos2.x + width2 &&
      pos1.x + width1 > pos2.x &&
      pos1.y < pos2.y + height2 &&
      pos1.y + height1 > pos2.y
    );
  }

  // ç‚¹åˆ°çº¿æ®µè·ç¦»
  static pointToLineDistance(
    point: Vector2D,
    lineStart: Vector2D,
    lineEnd: Vector2D
  ): number {
    const A = point.x - lineStart.x;
    const B = point.y - lineStart.y;
    const C = lineEnd.x - lineStart.x;
    const D = lineEnd.y - lineStart.y;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;

    if (lenSq === 0) {
      return Vector2D.distance(point, lineStart);
    }

    const param = dot / lenSq;

    let xx: number, yy: number;

    if (param < 0) {
      xx = lineStart.x;
      yy = lineStart.y;
    } else if (param > 1) {
      xx = lineEnd.x;
      yy = lineEnd.y;
    } else {
      xx = lineStart.x + param * C;
      yy = lineStart.y + param * D;
    }

    return Vector2D.distance(point, new Vector2D(xx, yy));
  }

  // é€šç”¨ç¢°æ’æ£€æµ‹
  static checkCollision(body1: CollisionBody, body2: CollisionBody): boolean {
    if (body1.shape === CollisionShape.CIRCLE && body2.shape === CollisionShape.CIRCLE) {
      return this.circleCollision(
        body1.position, body1.radius!,
        body2.position, body2.radius!
      );
    }

    if (body1.shape === CollisionShape.RECTANGLE && body2.shape === CollisionShape.RECTANGLE) {
      return this.rectangleCollision(
        body1.position, body1.width!, body1.height!,
        body2.position, body2.width!, body2.height!
      );
    }

    // å…¶ä»–å½¢çŠ¶çš„ç¢°æ’æ£€æµ‹å¯ä»¥æ‰©å±•
    return false;
  }
}
```

### 2. å¼¹é“è½¨è¿¹ç³»ç»Ÿ (Projectile System)

#### å¼¹é“è®¡ç®—
```typescript
interface Projectile {
  id: string;
  position: Vector2D;
  velocity: Vector2D;
  acceleration: Vector2D;
  damage: number;
  type: ProjectileType;
  lifetime: number;
  maxLifetime: number;
}

enum ProjectileType {
  NORMAL = 'normal',      // æ™®é€šç‚®å¼¹
  FREEZE = 'freeze',      // å†°å†»ç‚®å¼¹
  FIRE = 'fire',          // ç«ç„°ç‚®å¼¹
  LIGHTNING = 'lightning', // é›·ç”µç‚®å¼¹
  PIERCE = 'pierce'       // ç©¿é€ç‚®å¼¹
}

class TrajectoryCalculator {
  // è®¡ç®—æŠ›ç‰©çº¿è½¨è¿¹
  static calculateParabolicPoint(
    startPos: Vector2D,
    velocity: Vector2D,
    gravity: number,
    time: number
  ): Vector2D {
    const x = startPos.x + velocity.x * time;
    const y = startPos.y + velocity.y * time - 0.5 * gravity * time * time;
    return new Vector2D(x, y);
  }

  // è®¡ç®—ç›´çº¿è½¨è¿¹
  static calculateLinearPoint(
    startPos: Vector2D,
    direction: Vector2D,
    speed: number,
    time: number
  ): Vector2D {
    const distance = speed * time;
    const displacement = direction.multiply(distance);
    return startPos.add(displacement);
  }

  // è®¡ç®—è´å¡å°”æ›²çº¿è½¨è¿¹
  static calculateBezierPoint(
    t: number,
    p0: Vector2D,
    p1: Vector2D,
    p2: Vector2D
  ): Vector2D {
    const u = 1 - t;
    const tt = t * t;
    const uu = u * u;

    const x = uu * p0.x + 2 * u * t * p1.x + tt * p2.x;
    const y = uu * p0.y + 2 * u * t * p1.y + tt * p2.y;

    return new Vector2D(x, y);
  }

  // è®¡ç®—è¿½è¸ªå‹è½¨è¿¹ï¼ˆé±¼é›·ï¼‰
  static calculateHomingTrajectory(
    currentPos: Vector2D,
    targetPos: Vector2D,
    currentVelocity: Vector2D,
    maxTurnRate: number,
    speed: number,
    deltaTime: number
  ): Vector2D {
    const desiredDirection = Vector2D.direction(currentPos, targetPos);
    const currentDirection = currentVelocity.normalize();

    // è®¡ç®—è½¬å‘è§’åº¦
    const cross = currentDirection.x * desiredDirection.y - currentDirection.y * desiredDirection.x;
    const dot = currentDirection.dot(desiredDirection);

    let turnAngle = Math.acos(Math.max(-1, Math.min(1, dot)));
    if (cross < 0) turnAngle = -turnAngle;

    // é™åˆ¶è½¬å‘é€Ÿåº¦
    turnAngle = Math.max(-maxTurnRate * deltaTime, Math.min(maxTurnRate * deltaTime, turnAngle));

    // è®¡ç®—æ–°æ–¹å‘
    const cos = Math.cos(turnAngle);
    const sin = Math.sin(turnAngle);

    const newDirectionX = currentDirection.x * cos - currentDirection.y * sin;
    const newDirectionY = currentDirection.x * sin + currentDirection.y * cos;

    const newDirection = new Vector2D(newDirectionX, newDirectionY).normalize();

    return newDirection.multiply(speed);
  }
}
```

#### ç‚®å°ç³»ç»Ÿ
```typescript
interface Turret {
  id: string;
  position: Vector2D;
  angle: number;          // ç‚®å°è§’åº¦
  power: number;          // ç‚®å¼¹å¨åŠ›
  fireRate: number;       // å‘å°„é¢‘ç‡
  projectileType: ProjectileType;
  upgradeLevel: number;
}

class TurretSystem {
  // è®¡ç®—å‘å°„è§’åº¦
  static calculateFireAngle(turretPos: Vector2D, targetPos: Vector2D): number {
    const direction = Vector2D.direction(turretPos, targetPos);
    return Math.atan2(direction.y, direction.x);
  }

  // è®¡ç®—å‘å°„å‚æ•°
  static calculateFireParameters(
    turret: Turret,
    targetPos: Vector2D,
    windForce: Vector2D = new Vector2D(0, 0)
  ): FireParameters {
    const distance = Vector2D.distance(turret.position, targetPos);
    const angle = this.calculateFireAngle(turret.position, targetPos);

    // è€ƒè™‘é£åŠ›å½±å“
    const adjustedAngle = angle + Math.atan2(windForce.y, windForce.x) * 0.1;

    // è®¡ç®—åˆé€Ÿåº¦
    const gravity = 9.8;
    const initialSpeed = Math.sqrt((distance * gravity) / Math.sin(2 * adjustedAngle));

    return {
      angle: adjustedAngle,
      initialSpeed,
      timeToTarget: this.calculateTimeToTarget(distance, initialSpeed, angle, gravity)
    };
  }
}
```

### 3. é±¼ç±»AIç³»ç»Ÿ (Fish AI System)

#### é±¼ç±»è¡Œä¸ºæ¨¡å¼
```typescript
enum MovementPattern {
  LINEAR = 'linear',           // ç›´çº¿ç§»åŠ¨
  CIRCULAR = 'circular',       // åœ†å½¢ç§»åŠ¨
  SINUSOIDAL = 'sinusoidal',   // æ­£å¼¦æ³¢ç§»åŠ¨
  RANDOM = 'random',          // éšæœºç§»åŠ¨
  SCHOOLING = 'schooling'     // é±¼ç¾¤è¡Œä¸º
}

interface Fish {
  id: string;
  position: Vector2D;
  velocity: Vector2D;
  type: FishType;
  health: number;
  maxHealth: number;
  movementPattern: MovementPattern;
  speed: number;
  turnRate: number;
  fearRadius: number;          // ææƒ§åŠå¾„
  escapeSpeed: number;         // é€ƒè·‘é€Ÿåº¦
  value: number;               // ä»·å€¼åˆ†æ•°
  rarity: FishRarity;          // ç¨€æœ‰åº¦
}

enum FishRarity {
  COMMON = 'common',     // æ™®é€š
  RARE = 'rare',         // ç¨€æœ‰
  EPIC = 'epic',         // å²è¯—
  LEGENDARY = 'legendary' // ä¼ è¯´
}
```

#### é±¼ç±»AIç®—æ³•
```typescript
class FishAI {
  // è®¡ç®—ç›´çº¿ç§»åŠ¨
  static calculateLinearPath(
    currentPos: Vector2D,
    targetPos: Vector2D,
    speed: number,
    deltaTime: number
  ): Vector2D {
    const direction = Vector2D.direction(currentPos, targetPos);
    return direction.multiply(speed * deltaTime);
  }

  // è®¡ç®—åœ†å½¢ç§»åŠ¨
  static calculateCircularPath(
    center: Vector2D,
    currentPos: Vector2D,
    radius: number,
    angularSpeed: number,
    time: number
  ): Vector2D {
    const angle = angularSpeed * time;
    const x = center.x + radius * Math.cos(angle);
    const y = center.y + radius * Math.sin(angle);
    return new Vector2D(x, y);
  }

  // è®¡ç®—æ­£å¼¦æ³¢ç§»åŠ¨
  static calculateSinusoidalPath(
    startPos: Vector2D,
    direction: Vector2D,
    amplitude: number,
    frequency: number,
    speed: number,
    time: number
  ): Vector2D {
    const forwardDistance = speed * time;
    const perpendicular = new Vector2D(-direction.y, direction.x);
    const waveOffset = amplitude * Math.sin(frequency * time);

    const forward = direction.multiply(forwardDistance);
    const wave = perpendicular.multiply(waveOffset);

    return startPos.add(forward).add(wave);
  }

  // è®¡ç®—éšæœºæ¸¸èµ°
  static calculateRandomWalk(
    currentPos: Vector2D,
    currentDirection: Vector2D,
    speed: number,
    turnRate: number,
    deltaTime: number
  ): { position: Vector2D; direction: Vector2D } {
    // éšæœºè½¬å‘
    const randomTurn = (Math.random() - 0.5) * turnRate * deltaTime;

    const cos = Math.cos(randomTurn);
    const sin = Math.sin(randomTurn);

    const newDirectionX = currentDirection.x * cos - currentDirection.y * sin;
    const newDirectionY = currentDirection.x * sin + currentDirection.y * cos;

    const newDirection = new Vector2D(newDirectionX, newDirectionY).normalize();
    const displacement = newDirection.multiply(speed * deltaTime);
    const newPosition = currentPos.add(displacement);

    return { position: newPosition, direction: newDirection };
  }

  // è®¡ç®—é±¼ç¾¤è¡Œä¸º
  static calculateSchoolingBehavior(
    fishPos: Vector2D,
    neighbors: Vector2D[],
    separationDistance: number,
    alignmentDistance: number,
    cohesionDistance: number,
    weights: { separation: number; alignment: number; cohesion: number }
  ): Vector2D {
    let separationForce = new Vector2D(0, 0);
    let alignmentForce = new Vector2D(0, 0);
    let cohesionForce = new Vector2D(0, 0);

    let separationCount = 0;
    let alignmentCount = 0;
    let cohesionCount = 0;

    for (const neighbor of neighbors) {
      const distance = Vector2D.distance(fishPos, neighbor);

      // åˆ†ç¦»è¡Œä¸ºï¼šé¿å…å¤ªè¿‘çš„é‚»å±…
      if (distance < separationDistance && distance > 0) {
        const force = Vector2D.direction(neighbor, fishPos).multiply(1 / distance);
        separationForce = separationForce.add(force);
        separationCount++;
      }

      // å¯¹é½è¡Œä¸ºï¼šä¸é‚»å±…ä¿æŒç›¸åŒæ–¹å‘
      if (distance < alignmentDistance) {
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦é‚»å±…çš„é€Ÿåº¦å‘é‡
        alignmentForce = alignmentForce.add(neighbor.subtract(fishPos).normalize());
        alignmentCount++;
      }

      // å†…èšè¡Œä¸ºï¼šå‘é‚»å±…ä¸­å¿ƒç§»åŠ¨
      if (distance < cohesionDistance) {
        cohesionForce = cohesionForce.add(neighbor);
        cohesionCount++;
      }
    }

    // å¹³å‡åŒ–åŠ›
    if (separationCount > 0) separationForce = separationForce.multiply(1 / separationCount);
    if (alignmentCount > 0) alignmentForce = alignmentForce.multiply(1 / alignmentCount);
    if (cohesionCount > 0) {
      cohesionForce = cohesionForce.multiply(1 / cohesionCount);
      cohesionForce = Vector2D.direction(fishPos, cohesionForce);
    }

    // ç»„åˆæ‰€æœ‰åŠ›
    const totalForce = separationForce.multiply(weights.separation)
      .add(alignmentForce.multiply(weights.alignment))
      .add(cohesionForce.multiply(weights.cohesion));

    return totalForce.normalize();
  }
}
```

#### ææƒ§å’Œé€ƒè·‘ç³»ç»Ÿ
```typescript
class FearSystem {
  // è®¡ç®—ææƒ§å“åº”
  static calculateFearResponse(
    fish: Fish,
    threats: Vector2D[],
    deltaTime: number
  ): Vector2D {
    if (threats.length === 0) return new Vector2D(0, 0);

    let fearForce = new Vector2D(0, 0);

    for (const threat of threats) {
      const distance = Vector2D.distance(fish.position, threat);

      if (distance < fish.fearRadius) {
        // è®¡ç®—é€ƒè·‘æ–¹å‘ï¼ˆè¿œç¦»å¨èƒï¼‰
        const escapeDirection = Vector2D.direction(threat, fish.position);

        // ææƒ§å¼ºåº¦éšè·ç¦»è¡°å‡
        const fearIntensity = 1 - (distance / fish.fearRadius);
        const fearVector = escapeDirection.multiply(fearIntensity * fish.escapeSpeed);

        fearForce = fearForce.add(fearVector);
      }
    }

    return fearForce;
  }

  // åˆ¤æ–­æ˜¯å¦è¿›å…¥ææ…ŒçŠ¶æ€
  static isInPanic(fish: Fish, threats: Vector2D[]): boolean {
    const threatCount = threats.filter(threat =>
      Vector2D.distance(fish.position, threat) < fish.fearRadius * 0.5
    ).length;

    return threatCount >= 2; // å¤šä¸ªå¨èƒæ—¶è¿›å…¥ææ…Œ
  }
}
```

### 4. æ¦‚ç‡å¥–åŠ±ç³»ç»Ÿ (Reward System)

#### æ‰è½æ¦‚ç‡è®¡ç®—
```typescript
interface DropTable {
  item: string;
  probability: number;
  quantity: { min: number; max: number };
  conditions?: DropCondition[];
}

interface DropCondition {
  type: 'fish_type' | 'rarity' | 'combo' | 'luck';
  value: any;
}

class DropRateCalculator {
  // è®¡ç®—æš´å‡»æ¦‚ç‡
  static calculateCriticalHit(
    baseRate: number,
    luckModifier: number = 1.0,
    streakBonus: number = 0
  ): boolean {
    const effectiveRate = Math.min(1.0, baseRate * luckModifier * (1 + streakBonus));
    return Math.random() < effectiveRate;
  }

  // è®¡ç®—å¤šé‡æ‰è½
  static calculateMultipleDrops(
    dropTable: DropTable[],
    rolls: number = 1
  ): DropResult[] {
    const results: DropResult[] = [];

    for (let i = 0; i < rolls; i++) {
      const roll = Math.random();
      let cumulative = 0;

      for (const drop of dropTable) {
        cumulative += drop.probability;

        // æ£€æŸ¥æ‰è½æ¡ä»¶
        if (roll <= cumulative && this.checkDropConditions(drop.conditions)) {
          const quantity = this.rollQuantity(drop.quantity);
          const existingItem = results.find(r => r.item === drop.item);

          if (existingItem) {
            existingItem.quantity += quantity;
          } else {
            results.push({ item: drop.item, quantity });
          }
          break;
        }
      }
    }

    return results;
  }

  // è®¡ç®—è¿å‡»å¥–åŠ±
  static calculateComboBonus(
    currentCombo: number,
    baseMultiplier: number = 1.0,
    growthRate: number = 0.1
  ): number {
    if (currentCombo <= 1) return baseMultiplier;
    return baseMultiplier * Math.pow(1 + growthRate, currentCombo);
  }

  // è®¡ç®—ç¨€æœ‰åº¦æ¦‚ç‡
  static calculateRarityProbability(
    baseRates: Record<FishRarity, number>,
    playerLevel: number,
    luckStat: number
  ): Record<FishRarity, number> {
    const luckModifier = 1 + (luckStat / 100);
    const levelModifier = 1 + (playerLevel / 100);

    const adjustedRates: Record<FishRarity, number> = {} as any;

    for (const rarity of Object.keys(baseRates) as FishRarity[]) {
      let rate = baseRates[rarity] * luckModifier * levelModifier;

      // ç¡®ä¿æ¦‚ç‡æ€»å’Œä¸è¶…è¿‡1
      if (rarity === FishRarity.COMMON) {
        rate = Math.max(0.1, baseRates[rarity] - (luckModifier * levelModifier - 1) * 0.1);
      } else {
        rate = Math.min(0.5, rate); // é™åˆ¶ç¨€æœ‰ç‰©å“æ¦‚ç‡ä¸Šé™
      }

      adjustedRates[rarity] = rate;
    }

    return adjustedRates;
  }

  // æ£€æŸ¥æ‰è½æ¡ä»¶
  private static checkDropConditions(conditions?: DropCondition[]): boolean {
    if (!conditions) return true;

    return conditions.every(condition => {
      switch (condition.type) {
        case 'luck':
          return Math.random() < condition.value;
        case 'combo':
          return GameState.currentCombo >= condition.value;
        default:
          return true;
      }
    });
  }

  // éšæœºæ•°é‡
  private static rollQuantity(quantity: { min: number; max: number }): number {
    return Math.floor(Math.random() * (quantity.max - quantity.min + 1)) + quantity.min;
  }
}
```

#### åˆ†æ•°è®¡ç®—ç³»ç»Ÿ
```typescript
class ScoreCalculator {
  // è®¡ç®—åŸºç¡€åˆ†æ•°
  static calculateBaseScore(
    fishValue: number,
    bulletPower: number,
    distance: number,
    isCritical: boolean = false,
    comboMultiplier: number = 1.0
  ): number {
    let score = fishValue * bulletPower;

    // è·ç¦»æƒ©ç½šï¼ˆè¶Šè¿œåˆ†æ•°è¶Šä½ï¼‰
    const distancePenalty = Math.max(0.1, 1 - (distance / 1000));

    // æš´å‡»åŠ æˆ
    if (isCritical) {
      score *= 2;
    }

    // è¿å‡»åŠ æˆ
    score *= comboMultiplier;

    return Math.floor(score * distancePenalty);
  }

  // è®¡ç®—è¿å‡»åˆ†æ•°
  static calculateComboScore(baseScore: number, comboCount: number): number {
    const comboMultiplier = DropRateCalculator.calculateComboBonus(comboCount);
    return Math.floor(baseScore * comboMultiplier);
  }

  // è®¡ç®—å¤šé‡å‡»æ€å¥–åŠ±
  static calculateMultiKillBonus(hitCount: number): number {
    if (hitCount <= 1) return 0;
    return hitCount * hitCount * 10; // äºŒæ¬¡æ–¹å¥–åŠ±
  }
}
```

### 5. é“å…·å’ŒæŠ€èƒ½ç³»ç»Ÿ (Item & Skill System)

#### ç‚®å¼¹ç±»å‹
```typescript
interface BulletType {
  id: string;
  name: string;
  damage: number;
  speed: number;
  effect: BulletEffect;
  cost: number;        // æ¶ˆè€—é‡‘å¸
  cooldown: number;    // å†·å´æ—¶é—´
}

enum BulletEffect {
  NORMAL = 'normal',       // æ™®é€š
  FREEZE = 'freeze',       // å†°å†»ï¼ˆå‡é€Ÿï¼‰
  FIRE = 'fire',           // ç«ç„°ï¼ˆæŒç»­ä¼¤å®³ï¼‰
  LIGHTNING = 'lightning', // é›·ç”µï¼ˆé“¾å¼ä¼¤å®³ï¼‰
  PIERCE = 'pierce',       // ç©¿é€
  EXPLODE = 'explode'      // çˆ†ç‚¸
}
```

#### æŠ€èƒ½ç³»ç»Ÿ
```typescript
interface Skill {
  id: string;
  name: string;
  type: SkillType;
  level: number;
  maxLevel: number;
  effect: SkillEffect;
  cooldown: number;
  duration: number;
  cost: number;
}

enum SkillType {
  PASSIVE = 'passive',     // è¢«åŠ¨æŠ€èƒ½
  ACTIVE = 'active',       // ä¸»åŠ¨æŠ€èƒ½
  AUTO = 'auto'           // è‡ªåŠ¨è§¦å‘
}

class SkillSystem {
  // æ¿€æ´»æŠ€èƒ½
  static async activateSkill(skill: Skill, target?: Vector2D): Promise<SkillResult> {
    // æ£€æŸ¥å†·å´å’Œèµ„æº
    if (!this.canActivateSkill(skill)) {
      return { success: false, reason: 'cooldown_or_cost' };
    }

    // æ¶ˆè€—èµ„æº
    this.consumeSkillCost(skill);

    // åº”ç”¨æŠ€èƒ½æ•ˆæœ
    const effectResult = await this.applySkillEffect(skill, target);

    // è®¾ç½®å†·å´
    this.startCooldown(skill);

    return {
      success: true,
      effect: effectResult,
      cooldown: skill.cooldown
    };
  }

  // åº”ç”¨æŠ€èƒ½æ•ˆæœ
  private static async applySkillEffect(skill: Skill, target?: Vector2D): Promise<EffectResult> {
    switch (skill.effect.type) {
      case 'damage_boost':
        return this.applyDamageBoost(skill.effect.value, skill.duration);
      case 'freeze_all':
        return this.applyFreezeAll(skill.effect.radius, skill.duration);
      case 'summon_bomb':
        return this.summonBomb(target!, skill.effect.damage);
      default:
        return { type: 'none' };
    }
  }
}
```

### 6. å…³å¡å’Œåœºæ™¯ç³»ç»Ÿ (Level System)

#### åœºæ™¯é…ç½®
```typescript
interface Scene {
  id: string;
  name: string;
  background: string;        // èƒŒæ™¯å›¾ç‰‡
  music: string;            // èƒŒæ™¯éŸ³ä¹
  fishTypes: FishType[];    // å‡ºç°çš„é±¼ç±»
  difficulty: number;       // éš¾åº¦ç³»æ•°
  timeLimit?: number;       // æ—¶é—´é™åˆ¶
  targetScore?: number;     // ç›®æ ‡åˆ†æ•°
}

interface Wave {
  id: string;
  sceneId: string;
  fishSpawns: FishSpawn[];  // é±¼ç±»ç”Ÿæˆé…ç½®
  duration: number;         // æ³¢æ¬¡æŒç»­æ—¶é—´
  bossFish?: FishType;      // BOSSé±¼ç±»
}

interface FishSpawn {
  fishType: FishType;
  count: number;
  spawnRate: number;        // ç”Ÿæˆé¢‘ç‡
  spawnArea: Rectangle;     // ç”ŸæˆåŒºåŸŸ
  movementPattern: MovementPattern;
}
```

#### éš¾åº¦å¹³è¡¡
```typescript
class DifficultyBalancer {
  // æ ¹æ®ç©å®¶ç­‰çº§è°ƒæ•´éš¾åº¦
  static adjustDifficultyForPlayer(
    baseScene: Scene,
    playerLevel: number,
    playerScore: number
  ): Scene {
    const adjustedScene = { ...baseScene };

    // è°ƒæ•´é±¼ç±»æ•°é‡
    adjustedScene.fishTypes = adjustedScene.fishTypes.map(fishType => ({
      ...fishType,
      count: Math.floor(fishType.count * (1 + playerLevel * 0.1))
    }));

    // è°ƒæ•´ç”Ÿæˆé¢‘ç‡
    adjustedScene.spawnRate *= (1 + playerLevel * 0.05);

    // å¢åŠ ç¨€æœ‰é±¼ç±»æ¦‚ç‡
    if (playerScore > 10000) {
      adjustedScene.rareFishProbability = Math.min(0.3, 0.1 + playerLevel * 0.01);
    }

    return adjustedScene;
  }

  // åŠ¨æ€éš¾åº¦è°ƒæ•´
  static adjustDynamicDifficulty(
    currentDifficulty: number,
    playerPerformance: number,
    targetPerformance: number
  ): number {
    const performanceRatio = playerPerformance / targetPerformance;
    const adjustment = (performanceRatio - 1) * 0.1; // 10%çš„è°ƒæ•´å¹…åº¦

    return Math.max(0.5, Math.min(2.0, currentDifficulty + adjustment));
  }
}
```

## ğŸ”§ æ ¸å¿ƒç®—æ³•å®ç°

### ç¢°æ’æ£€æµ‹ä¼˜åŒ–ç®—æ³• (Collision Detection Optimization)

#### ç©ºé—´åˆ†åŒº
```typescript
class SpatialPartition {
  private gridSize: number;
  private grid: Map<string, CollisionBody[]>;

  constructor(worldWidth: number, worldHeight: number, gridSize: number) {
    this.gridSize = gridSize;
    this.grid = new Map();

    // åˆå§‹åŒ–ç½‘æ ¼
    const cols = Math.ceil(worldWidth / gridSize);
    const rows = Math.ceil(worldHeight / gridSize);

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const key = `${row}-${col}`;
        this.grid.set(key, []);
      }
    }
  }

  // æ·»åŠ ç‰©ä½“åˆ°ç½‘æ ¼
  addBody(body: CollisionBody): void {
    const cells = this.getOccupiedCells(body);

    for (const cell of cells) {
      const bodies = this.grid.get(cell) || [];
      bodies.push(body);
      this.grid.set(cell, bodies);
    }
  }

  // è·å–å¯èƒ½ç¢°æ’çš„ç‰©ä½“
  getNearbyBodies(body: CollisionBody): CollisionBody[] {
    const cells = this.getOccupiedCells(body);
    const nearbyBodies = new Set<CollisionBody>();

    for (const cell of cells) {
      const bodies = this.grid.get(cell) || [];
      bodies.forEach(b => nearbyBodies.add(b));
    }

    return Array.from(nearbyBodies).filter(b => b.id !== body.id);
  }

  // è·å–ç‰©ä½“å ç”¨çš„ç½‘æ ¼å•å…ƒ
  private getOccupiedCells(body: CollisionBody): string[] {
    const cells: string[] = [];
    const bounds = this.getBodyBounds(body);

    const startRow = Math.floor(bounds.top / this.gridSize);
    const endRow = Math.floor(bounds.bottom / this.gridSize);
    const startCol = Math.floor(bounds.left / this.gridSize);
    const endCol = Math.floor(bounds.right / this.gridSize);

    for (let row = startRow; row <= endRow; row++) {
      for (let col = startCol; col <= endCol; col++) {
        cells.push(`${row}-${col}`);
      }
    }

    return cells;
  }
}
```

### é±¼ç±»ç”Ÿæˆç®—æ³• (Fish Spawning Algorithm)

#### ç¨‹åºåŒ–ç”Ÿæˆ
```typescript
class FishSpawner {
  // ç”Ÿæˆé±¼ç¾¤
  static spawnFishSchool(
    scene: Scene,
    spawnConfig: FishSpawn,
    currentTime: number
  ): Fish[] {
    const fish: Fish[] = [];
    const spawnCount = this.calculateSpawnCount(spawnConfig, currentTime);

    for (let i = 0; i < spawnCount; i++) {
      const position = this.generateSpawnPosition(spawnConfig.spawnArea);
      const fish = this.createFish(spawnConfig.fishType, position);
      fish.movementPattern = spawnConfig.movementPattern;
      fish.aiContext = this.initializeAIContext(fish, spawnConfig);

      fish.push(fish);
    }

    return fish;
  }

  // è®¡ç®—ç”Ÿæˆæ•°é‡
  private static calculateSpawnCount(config: FishSpawn, currentTime: number): number {
    // åŸºäºæ—¶é—´å’Œç”Ÿæˆç‡çš„æ³Šæ¾åˆ†å¸ƒ
    const expectedCount = config.spawnRate * config.duration;
    const variance = Math.sqrt(expectedCount);

    return Math.max(1, Math.floor(
      expectedCount + (Math.random() - 0.5) * variance * 2
    ));
  }

  // ç”Ÿæˆç”Ÿæˆä½ç½®
  private static generateSpawnPosition(area: Rectangle): Vector2D {
    const x = area.x + Math.random() * area.width;
    const y = area.y + Math.random() * area.height;
    return new Vector2D(x, y);
  }

  // åˆå§‹åŒ–AIä¸Šä¸‹æ–‡
  private static initializeAIContext(fish: Fish, config: FishSpawn): AIContext {
    return {
      waypoints: this.generateWaypoints(config.movementPattern, fish.position),
      behaviorWeights: this.getBehaviorWeights(config.fishType),
      threatRadius: fish.fearRadius,
      socialDistance: this.getSocialDistance(config.fishType)
    };
  }
}
```

### å¥–åŠ±ä¼˜åŒ–ç®—æ³• (Reward Optimization Algorithm)

#### åŠ¨æ€å¥–åŠ±è°ƒæ•´
```typescript
class RewardOptimizer {
  // ä¼˜åŒ–å¥–åŠ±åˆ†å¸ƒ
  static optimizeRewardDistribution(
    playerHistory: GameHistory[],
    currentDifficulty: number
  ): RewardAdjustment {
    const averageScore = this.calculateAverageScore(playerHistory);
    const scoreVariance = this.calculateScoreVariance(playerHistory);
    const playerSkill = this.assessPlayerSkill(playerHistory);

    // æ ¹æ®ç©å®¶è¡¨ç°è°ƒæ•´å¥–åŠ±
    let scoreMultiplier = 1.0;
    let dropRateBonus = 0.0;

    if (playerSkill === 'beginner') {
      scoreMultiplier = 1.2;  // æ–°æ‰‹å¥–åŠ±åŠ æˆ
      dropRateBonus = 0.1;    // æ‰è½ç‡åŠ æˆ
    } else if (playerSkill === 'expert') {
      scoreMultiplier = 0.9;  // ä¸“å®¶éš¾åº¦æƒ©ç½š
      dropRateBonus = -0.05;  // æ‰è½ç‡å‡å°‘
    }

    // å¹³è¡¡åˆ†æ•°æ³¢åŠ¨
    if (scoreVariance > 1000) {
      scoreMultiplier *= 0.95; // é«˜æ³¢åŠ¨æ—¶é™ä½å¥–åŠ±
    }

    return {
      scoreMultiplier,
      dropRateBonus,
      specialEventChance: this.calculateSpecialEventChance(playerHistory)
    };
  }

  // è¯„ä¼°ç©å®¶æŠ€èƒ½æ°´å¹³
  private static assessPlayerSkill(history: GameHistory[]): PlayerSkill {
    const recentScores = history.slice(-10).map(h => h.score);
    const averageScore = recentScores.reduce((a, b) => a + b, 0) / recentScores.length;

    if (averageScore < 5000) return 'beginner';
    if (averageScore < 15000) return 'intermediate';
    if (averageScore < 30000) return 'advanced';
    return 'expert';
  }

  // è®¡ç®—ç‰¹æ®Šäº‹ä»¶æ¦‚ç‡
  private static calculateSpecialEventChance(history: GameHistory[]): number {
    const luckyStreak = this.findLuckyStreak(history);
    const baseChance = 0.05; // 5%åŸºç¡€æ¦‚ç‡

    // å¹¸è¿è¿å‡»åŠ æˆ
    const streakBonus = Math.min(0.15, luckyStreak * 0.01);

    return Math.min(0.25, baseChance + streakBonus);
  }
}
```

## ğŸ“Š æ¸¸æˆæµç¨‹è®¾è®¡

### æ ¸å¿ƒæ¸¸æˆå¾ªç¯
1. **åœºæ™¯åˆå§‹åŒ–**ï¼šåŠ è½½èƒŒæ™¯ã€éŸ³ä¹ã€é±¼ç±»é…ç½®
2. **æ³¢æ¬¡å¼€å§‹**ï¼šç”Ÿæˆé±¼ç¾¤ï¼Œè®¾ç½®ç›®æ ‡
3. **ç©å®¶æ“ä½œ**ï¼šç„å‡†ã€å‘å°„ç‚®å¼¹
4. **ç‰©ç†æ¨¡æ‹Ÿ**ï¼šæ›´æ–°å¼¹é“ã€é±¼ç±»ç§»åŠ¨ã€ç¢°æ’æ£€æµ‹
5. **ä¼¤å®³ç»“ç®—**ï¼šè®¡ç®—å‘½ä¸­ã€ä¼¤å®³ã€å¥–åŠ±
6. **çŠ¶æ€æ›´æ–°**ï¼šæ›´æ–°åˆ†æ•°ã€é‡‘å¸ã€è¿å‡»
7. **æ³¢æ¬¡æ£€æŸ¥**ï¼šåˆ¤æ–­æ˜¯å¦å®Œæˆå½“å‰æ³¢æ¬¡
8. **æ¸¸æˆç»“æŸ**ï¼šç»“ç®—å¥–åŠ±ï¼Œè¿›å…¥ä¸‹ä¸€åœºæ™¯

### ç»æµç³»ç»Ÿ
```typescript
interface EconomySystem {
  playerGold: number;
  upgradeCosts: Map<string, number>;
  itemPrices: Map<string, number>;

  // è´­ä¹°å‡çº§
  purchaseUpgrade(upgradeId: string): boolean;
  // å‡ºå”®ç‰©å“
  sellItem(itemId: string, quantity: number): number;
  // è®¡ç®—æŠ˜æ‰£
  calculateDiscount(itemId: string, playerLevel: number): number;
}
```

## ğŸ® ç©å®¶ä½“éªŒè®¾è®¡

### ç„å‡†ç³»ç»Ÿ
- **è‡ªåŠ¨ç„å‡†**ï¼šæ™ºèƒ½é¢„æµ‹é±¼ç±»è½¨è¿¹
- **æ‰‹åŠ¨ç„å‡†**ï¼šç²¾ç¡®æ§åˆ¶å‘å°„è§’åº¦
- **è¾…åŠ©çº¿**ï¼šæ˜¾ç¤ºå¼¹é“è½¨è¿¹é¢„è§ˆ
- **é”å®šæœºåˆ¶**ï¼šè‡ªåŠ¨è·Ÿè¸ªç›®æ ‡

### è§†è§‰åé¦ˆ
- **å‘½ä¸­ç‰¹æ•ˆ**ï¼šé‡‘å¸é£å‡ºã€é±¼ç±»çˆ†ç‚¸
- **è¿å‡»æ˜¾ç¤º**ï¼šè¿å‡»æ•°å­—å’Œå€ç‡æç¤º
- **è¿›åº¦æ¡**ï¼šæ³¢æ¬¡è¿›åº¦å’Œæ—¶é—´æ˜¾ç¤º
- **å¥–åŠ±é¢„è§ˆ**ï¼šæ˜¾ç¤ºæ½œåœ¨å¥–åŠ±

### éŸ³æ•ˆè®¾è®¡
- **å‘å°„éŸ³æ•ˆ**ï¼šä¸åŒç‚®å¼¹çš„ç‹¬ç‰¹éŸ³æ•ˆ
- **å‘½ä¸­éŸ³æ•ˆ**ï¼šæ ¹æ®å¥–åŠ±å¤§å°å˜åŒ–
- **èƒŒæ™¯éŸ³ä¹**ï¼šæ ¹æ®åœºæ™¯å’Œç´§å¼ åº¦å˜åŒ–
- **è¿å‡»éŸ³æ•ˆ**ï¼šæ¿€åŠ±æ€§çš„è¿å‡»æç¤ºéŸ³

## ğŸ”„ ç³»ç»Ÿä¼˜åŒ–ç­–ç•¥

### æ€§èƒ½ä¼˜åŒ–
- **å¯¹è±¡æ± **ï¼šå¤ç”¨ç‚®å¼¹ã€é±¼ç±»ã€ç‰¹æ•ˆå¯¹è±¡
- **LODç³»ç»Ÿ**ï¼šè¿œå¤„é±¼ç±»ç®€åŒ–æ¸²æŸ“
- **æ‰¹é‡æ¸²æŸ“**ï¼šæ‰¹é‡å¤„ç†ç›¸åŒç±»å‹çš„å¯¹è±¡
- **å¼‚æ­¥åŠ è½½**ï¼šé¢„åŠ è½½ä¸‹ä¸€åœºæ™¯èµ„æº

### ç½‘ç»œåŒæ­¥ï¼ˆå¤šäººæ¸¸æˆï¼‰
- **çŠ¶æ€åŒæ­¥**ï¼šå®šæœŸåŒæ­¥æ¸¸æˆçŠ¶æ€
- **é¢„æµ‹è¡¥å¿**ï¼šå®¢æˆ·ç«¯é¢„æµ‹ï¼ŒæœåŠ¡å™¨ä¿®æ­£
- **å»¶è¿Ÿéšè—**ï¼šé€šè¿‡ç‰¹æ•ˆéšè—ç½‘ç»œå»¶è¿Ÿ
- **å…¬å¹³æ€§ä¿è¯**ï¼šé˜²æ­¢ä½œå¼Šçš„éªŒè¯æœºåˆ¶

## ğŸ“ˆ æ‰©å±•æ€§è®¾è®¡

### è‡ªå®šä¹‰æ¨¡å¼
- **åœºæ™¯ç¼–è¾‘å™¨**ï¼šç©å®¶åˆ›å»ºè‡ªå®šä¹‰åœºæ™¯
- **é±¼ç±»å®šåˆ¶**ï¼šè‡ªå®šä¹‰é±¼ç±»è¡Œä¸ºå’Œå¤–è§‚
- **æŒ‘æˆ˜æ¨¡å¼**ï¼šç‰¹æ®Šè§„åˆ™çš„æŒ‘æˆ˜å…³å¡
- **é”¦æ ‡èµ›ç³»ç»Ÿ**ï¼šå¤šäººç«æŠ€æ¯”èµ›

### ç¤¾äº¤åŠŸèƒ½
- **æ’è¡Œæ¦œ**ï¼šå…¨çƒå’Œå¥½å‹æ’è¡Œ
- **æˆå°±ç³»ç»Ÿ**ï¼šå„ç§æ¸¸æˆæˆå°±
- **æ¯æ—¥æŒ‘æˆ˜**ï¼šæ—¥å¸¸ä»»åŠ¡å’Œå¥–åŠ±
- **å…¬ä¼šç³»ç»Ÿ**ï¼šå›¢é˜Ÿåˆä½œç©æ³•

## ğŸ¯ æ ¸å¿ƒæˆåŠŸè¦ç´ 

1. **æµç•…æ€§**ï¼šä¸æ»‘çš„ç„å‡†å’Œå‘å°„ä½“éªŒ
2. **ç­–ç•¥æ€§**ï¼šåˆç†çš„ç„å‡†æ—¶æœºå’Œç‚®å¼¹é€‰æ‹©
3. **é‡ç©æ€§**ï¼šå¤šæ ·åŒ–çš„åœºæ™¯å’ŒæŒ‘æˆ˜
4. **è§†è§‰ä½“éªŒ**ï¼šç»šä¸½çš„ç‰¹æ•ˆå’ŒåŠ¨ç”»
5. **ç»æµå¹³è¡¡**ï¼šåˆç†çš„é‡‘å¸è·å–å’Œæ¶ˆè´¹

---

*æ•é±¼ç±»æ¸¸æˆçš„æ ¸å¿ƒé­…åŠ›åœ¨äºç®€å•æ“ä½œä¸‹çš„ç­–ç•¥æ·±åº¦ï¼Œé€šè¿‡ç²¾å¿ƒçš„ç‰©ç†æ¨¡æ‹Ÿå’Œæ¦‚ç‡ç³»ç»Ÿï¼Œå¯ä»¥åˆ›é€ å‡ºä»¤äººæ²‰è¿·çš„å°„å‡»ä½“éªŒã€‚*
