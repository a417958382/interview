# æ–°æ‰‹å¼•å¯¼ç³»ç»Ÿè®¾è®¡

## ğŸ¯ ç³»ç»Ÿæ¦‚è¿°

æ–°æ‰‹å¼•å¯¼ç³»ç»Ÿï¼ˆTutorial Systemï¼‰æ˜¯ç°ä»£æ¸¸æˆä¸­ä¸å¯æˆ–ç¼ºçš„æ•™å­¦æœºåˆ¶ï¼Œç”¨äºå¸®åŠ©æ–°ç©å®¶å¿«é€ŸæŒæ¡æ¸¸æˆçš„åŸºæœ¬æ“ä½œã€ç†è§£æ ¸å¿ƒç©æ³•ã€ç†Ÿæ‚‰æ¸¸æˆç•Œé¢ã€‚é€šè¿‡ç²¾å¿ƒè®¾è®¡çš„å¼•å¯¼æµç¨‹ï¼Œå¯ä»¥æœ‰æ•ˆé™ä½ç©å®¶æµå¤±ç‡ï¼Œæå‡æ¸¸æˆä½“éªŒå’Œç”¨æˆ·ç•™å­˜ã€‚

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„æ¨¡å—

### æ•°æ®ç»“æ„è®¾è®¡

#### å¼•å¯¼æ­¥éª¤æ•°æ®ç»“æ„

```typescript
interface TutorialStep {
  // æ­¥éª¤å”¯ä¸€æ ‡è¯†
  id: string;
  // æ­¥éª¤åç§°
  name: string;
  // æ­¥éª¤ç±»å‹
  type: TutorialStepType;
  // æ­¥éª¤ä¼˜å…ˆçº§
  priority: number;
  // å‰ç½®æ­¥éª¤IDåˆ—è¡¨
  prerequisites: string[];
  // æ­¥éª¤æ¡ä»¶
  conditions: TutorialCondition[];
  // æ­¥éª¤åŠ¨ä½œ
  actions: TutorialAction[];
  // æ­¥éª¤æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
  duration?: number;
  // æ˜¯å¦å¯è·³è¿‡
  skippable: boolean;
  // æ­¥éª¤çŠ¶æ€
  status: TutorialStepStatus;
  // å®Œæˆæ—¶é—´æˆ³
  completedTime?: number;
}

enum TutorialStepType {
  DIALOGUE = 'dialogue',         // å¯¹è¯å¼•å¯¼
  HIGHLIGHT = 'highlight',       // é«˜äº®å¼•å¯¼
  CLICK = 'click',               // ç‚¹å‡»å¼•å¯¼
  DRAG = 'drag',                 // æ‹–æ‹½å¼•å¯¼
  GESTURE = 'gesture',           // æ‰‹åŠ¿å¼•å¯¼
  WAIT = 'wait',                 // ç­‰å¾…å¼•å¯¼
  CUSTOM = 'custom'              // è‡ªå®šä¹‰å¼•å¯¼
}

enum TutorialStepStatus {
  LOCKED = 'locked',             // æœªè§£é”
  AVAILABLE = 'available',       // å¯è¿›è¡Œ
  IN_PROGRESS = 'in_progress',   // è¿›è¡Œä¸­
  COMPLETED = 'completed',       // å·²å®Œæˆ
  SKIPPED = 'skipped'            // å·²è·³è¿‡
}
```

#### å¼•å¯¼ä»»åŠ¡æ•°æ®ç»“æ„

```typescript
interface TutorialTask {
  // ä»»åŠ¡å”¯ä¸€æ ‡è¯†
  id: string;
  // ä»»åŠ¡åç§°
  name: string;
  // ä»»åŠ¡æè¿°
  description: string;
  // ä»»åŠ¡ç±»å‹
  type: TutorialTaskType;
  // æ‰€å±å¼•å¯¼æµç¨‹
  tutorialId: string;
  // ä»»åŠ¡æ­¥éª¤åˆ—è¡¨
  steps: string[];
  // ä»»åŠ¡å¥–åŠ±
  rewards: TutorialReward[];
  // ä»»åŠ¡çŠ¶æ€
  status: TutorialTaskStatus;
  // è¿›åº¦ä¿¡æ¯
  progress: TutorialProgress;
  // åˆ›å»ºæ—¶é—´
  createdTime: number;
  // å®Œæˆæ—¶é—´
  completedTime?: number;
}

enum TutorialTaskType {
  MAIN = 'main',                 // ä¸»çº¿å¼•å¯¼
  BRANCH = 'branch',             // åˆ†æ”¯å¼•å¯¼
  OPTIONAL = 'optional',         // å¯é€‰å¼•å¯¼
  REPLAY = 'replay'              // é‡ç©å¼•å¯¼
}

interface TutorialProgress {
  currentStep: number;
  totalSteps: number;
  completedSteps: number[];
  startTime: number;
  estimatedTime: number;         // é¢„ä¼°å®Œæˆæ—¶é—´ï¼ˆç§’ï¼‰
}
```

#### å¼•å¯¼æµç¨‹æ•°æ®ç»“æ„

```mermaid
graph TD
    A[å¼•å¯¼æµç¨‹] --> B[ä»»åŠ¡åˆ—è¡¨]
    A --> C[å…¨å±€é…ç½®]
    A --> D[çŠ¶æ€ç®¡ç†]

    B --> B1[ä¸»çº¿ä»»åŠ¡]
    B --> B2[åˆ†æ”¯ä»»åŠ¡]
    B --> B3[å¯é€‰ä»»åŠ¡]

    C --> C1[æ˜¾ç¤ºè®¾ç½®]
    C --> C2[äº¤äº’è®¾ç½®]
    C --> C3[è·³è¿‡è®¾ç½®]

    D --> D1[è¿›åº¦è·Ÿè¸ª]
    D --> D2[æ•°æ®æŒä¹…åŒ–]
    D --> D3[çŠ¶æ€åŒæ­¥]

    style A fill:#e6f7ff
    style B fill:#fff7e6
    style C fill:#e6ffe6
    style D fill:#ffe6e6
```

### ä»£ç æ¶æ„è®¾è®¡

#### æ ¸å¿ƒç»„ä»¶æ¶æ„

```mermaid
classDiagram
    class TutorialManager {
        +Map<string, TutorialTask> tasks
        +TutorialController controller
        +TutorialUIManager uiManager
        +Init()
        +StartTutorial(tutorialId: string)
        +CompleteStep(stepId: string)
        +SkipTutorial(tutorialId: string)
        +GetTutorialProgress(tutorialId: string)
    }

    class TutorialController {
        +TutorialManager manager
        +TutorialExecutor executor
        +CheckConditions(stepId: string): boolean
        +ExecuteStep(step: TutorialStep)
        +HandleStepCompletion(stepId: string)
        +ValidateStepSequence()
    }

    class TutorialExecutor {
        +TutorialController controller
        +ExecuteDialogueStep(step: TutorialStep)
        +ExecuteHighlightStep(step: TutorialStep)
        +ExecuteClickStep(step: TutorialStep)
        +ExecuteWaitStep(step: TutorialStep)
    }

    class TutorialUIManager {
        +TutorialManager manager
        +TutorialMask mask
        +TutorialArrow arrow
        +TutorialDialog dialog
        +ShowMask()
        +ShowArrow(target: RectTransform)
        +ShowDialog(content: string)
        +HideAll()
    }

    TutorialManager --> TutorialTask
    TutorialManager --> TutorialController
    TutorialController --> TutorialExecutor
    TutorialController --> TutorialUIManager
    TutorialUIManager --> TutorialMask
    TutorialUIManager --> TutorialArrow
    TutorialUIManager --> TutorialDialog
```

#### å¼•å¯¼æ‰§è¡Œæµç¨‹

```mermaid
flowchart TD
    A[å¼€å§‹å¼•å¯¼] --> B[åŠ è½½å¼•å¯¼é…ç½®]
    B --> C[åˆå§‹åŒ–å¼•å¯¼çŠ¶æ€]
    C --> D[æ£€æŸ¥å‰ç½®æ¡ä»¶]
    D --> E{æ¡ä»¶æ»¡è¶³?}

    E -->|æ˜¯| F[æ‰§è¡Œå½“å‰æ­¥éª¤]
    E -->|å¦| G[ç­‰å¾…æ¡ä»¶æ»¡è¶³]

    F --> H[æ˜¾ç¤ºUIå¼•å¯¼]
    H --> I[ç­‰å¾…ç©å®¶æ“ä½œ]
    I --> J[éªŒè¯æ“ä½œç»“æœ]

    J --> K{æ“ä½œæ­£ç¡®?}
    K -->|æ˜¯| L[å®Œæˆå½“å‰æ­¥éª¤]
    K -->|å¦| M[æ˜¾ç¤ºé”™è¯¯æç¤º]

    M --> I
    L --> N{è¿˜æœ‰ä¸‹ä¸€æ­¥?}
    N -->|æ˜¯| D
    N -->|å¦| O[å®Œæˆå¼•å¯¼ä»»åŠ¡]

    G --> D
    O --> P[å‘æ”¾å¥–åŠ±]
    P --> Q[ä¿å­˜è¿›åº¦]
    Q --> R[ç»“æŸå¼•å¯¼]

    style A fill:#e6f7ff
    style F fill:#fff7e6
    style O fill:#e6ffe6
```

### UIå®ç°æ€è·¯

#### å¼•å¯¼é®ç½©ç³»ç»Ÿ

```typescript
class TutorialMask {
  private maskImage: Image;
  private highlightArea: RectTransform;
  private maskMaterial: Material;

  // åˆ›å»ºé«˜äº®é®ç½©
  public CreateHighlightMask(targetRect: Rect): void {
    // åˆ›å»ºé®ç½©æè´¨
    this.maskMaterial = this.CreateMaskMaterial();

    // è®¾ç½®é®ç½©å¤§å°å’Œä½ç½®
    this.SetMaskRect(targetRect);

    // åˆ›å»ºé«˜äº®åŒºåŸŸ
    this.CreateHighlightArea(targetRect);
  }

  // åˆ›å»ºé®ç½©æè´¨
  private CreateMaskMaterial(): Material {
    const material = new Material(Shader.Find("Custom/TutorialMask"));
    material.SetColor("_MaskColor", new Color(0, 0, 0, 0.7f));
    material.SetColor("_HighlightColor", new Color(1, 1, 1, 0.3f));
    return material;
  }

  // è®¾ç½®é®ç½©çŸ©å½¢
  private SetMaskRect(rect: Rect): void {
    this.maskImage.rectTransform.sizeDelta = new Vector2(
      Screen.width,
      Screen.height
    );
    this.maskImage.rectTransform.anchoredPosition = Vector2.zero;
  }

  // åˆ›å»ºé«˜äº®åŒºåŸŸ
  private CreateHighlightArea(rect: Rect): void {
    this.highlightArea = new GameObject("HighlightArea").AddComponent<RectTransform>();
    this.highlightArea.SetParent(this.maskImage.transform);
    this.highlightArea.sizeDelta = new Vector2(rect.width, rect.height);
    this.highlightArea.anchoredPosition = new Vector2(rect.x, rect.y);
  }
}
```

#### å¼•å¯¼ç®­å¤´ç³»ç»Ÿ

```typescript
class TutorialArrow {
  private arrowObject: GameObject;
  private arrowImage: Image;
  private animationController: Animator;

  // æ˜¾ç¤ºå¼•å¯¼ç®­å¤´
  public Show(targetPosition: Vector3, direction: ArrowDirection): void {
    if (!this.arrowObject) {
      this.CreateArrowObject();
    }

    // è®¾ç½®ç®­å¤´ä½ç½®
    this.SetArrowPosition(targetPosition);

    // è®¾ç½®ç®­å¤´æ–¹å‘
    this.SetArrowDirection(direction);

    // æ’­æ”¾åŠ¨ç”»
    this.PlayArrowAnimation();

    this.arrowObject.SetActive(true);
  }

  // éšè—å¼•å¯¼ç®­å¤´
  public Hide(): void {
    if (this.arrowObject) {
      this.StopAnimation();
      this.arrowObject.SetActive(false);
    }
  }

  // åˆ›å»ºç®­å¤´å¯¹è±¡
  private CreateArrowObject(): void {
    this.arrowObject = new GameObject("TutorialArrow");
    this.arrowImage = this.arrowObject.AddComponent<Image>();
    this.animationController = this.arrowObject.AddComponent<Animator>();

    // è®¾ç½®ç®­å¤´æ ·å¼
    this.arrowImage.sprite = Resources.Load<Sprite>("UI/Tutorial/Arrow");
    this.arrowImage.SetNativeSize();

    // è®¾ç½®åŠ¨ç”»æ§åˆ¶å™¨
    const controller = Resources.Load<RuntimeAnimatorController>("Animations/TutorialArrow");
    this.animationController.runtimeAnimatorController = controller;
  }

  // è®¾ç½®ç®­å¤´ä½ç½®
  private SetArrowPosition(position: Vector3): void {
    const screenPoint = Camera.main.WorldToScreenPoint(position);
    const canvasRect = this.GetCanvasRect();

    // è½¬æ¢ä¸ºCanvasåæ ‡
    const canvasPos = new Vector2(
      screenPoint.x - canvasRect.width / 2,
      screenPoint.y - canvasRect.height / 2
    );

    this.arrowObject.transform.localPosition = canvasPos;
  }

  // è®¾ç½®ç®­å¤´æ–¹å‘
  private SetArrowDirection(direction: ArrowDirection): void {
    const rotation = this.GetDirectionRotation(direction);
    this.arrowObject.transform.rotation = Quaternion.Euler(0, 0, rotation);
  }

  // è·å–æ–¹å‘å¯¹åº”çš„æ—‹è½¬è§’åº¦
  private GetDirectionRotation(direction: ArrowDirection): number {
    switch (direction) {
      case ArrowDirection.UP: return 0;
      case ArrowDirection.DOWN: return 180;
      case ArrowDirection.LEFT: return 90;
      case ArrowDirection.RIGHT: return -90;
      default: return 0;
    }
  }
}

enum ArrowDirection {
  UP = 'up',
  DOWN = 'down',
  LEFT = 'left',
  RIGHT = 'right'
}
```

#### å¼•å¯¼å¯¹è¯æ¡†ç³»ç»Ÿ

```typescript
class TutorialDialog {
  private dialogPanel: GameObject;
  private contentText: Text;
  private speakerNameText: Text;
  private speakerImage: Image;
  private continueButton: Button;
  private typingEffect: TypingEffect;

  // æ˜¾ç¤ºå¯¹è¯
  public async ShowDialog(dialogue: TutorialDialogue): Promise<void> {
    this.SetupDialog(dialogue);
    await this.PlayTypingEffect(dialogue.content);
    this.ShowContinueButton();
  }

  // è®¾ç½®å¯¹è¯å†…å®¹
  private SetupDialog(dialogue: TutorialDialogue): void {
    if (!this.dialogPanel) {
      this.CreateDialogPanel();
    }

    // è®¾ç½®è¯´è¯äººä¿¡æ¯
    this.speakerNameText.text = dialogue.speakerName;
    if (dialogue.speakerImage) {
      this.speakerImage.sprite = dialogue.speakerImage;
      this.speakerImage.gameObject.SetActive(true);
    } else {
      this.speakerImage.gameObject.SetActive(false);
    }

    // è®¾ç½®å¯¹è¯ä½ç½®
    this.SetDialogPosition(dialogue.position);

    this.dialogPanel.SetActive(true);
  }

  // æ’­æ”¾æ‰“å­—æ•ˆæœ
  private async PlayTypingEffect(content: string): Promise<void> {
    this.contentText.text = "";
    this.typingEffect = new TypingEffect(this.contentText, content);
    await this.typingEffect.Play();
  }

  // æ˜¾ç¤ºç»§ç»­æŒ‰é’®
  private ShowContinueButton(): void {
    this.continueButton.gameObject.SetActive(true);
    this.continueButton.onClick.RemoveAllListeners();
    this.continueButton.onClick.AddListener(() => {
      this.OnContinueClicked();
    });
  }

  // åˆ›å»ºå¯¹è¯æ¡†é¢æ¿
  private CreateDialogPanel(): void {
    this.dialogPanel = Instantiate(Resources.Load<GameObject>("UI/Tutorial/DialogPanel"));

    // è·å–ç»„ä»¶å¼•ç”¨
    this.contentText = this.dialogPanel.transform.Find("Content").GetComponent<Text>();
    this.speakerNameText = this.dialogPanel.transform.Find("SpeakerName").GetComponent<Text>();
    this.speakerImage = this.dialogPanel.transform.Find("SpeakerImage").GetComponent<Image>();
    this.continueButton = this.dialogPanel.transform.Find("ContinueButton").GetComponent<Button>();

    // è®¾ç½®æ ·å¼
    this.SetupDialogStyle();
  }

  // è®¾ç½®å¯¹è¯æ¡†æ ·å¼
  private SetupDialogStyle(): void {
    // è®¾ç½®èƒŒæ™¯
    const background = this.dialogPanel.GetComponent<Image>();
    background.sprite = Resources.Load<Sprite>("UI/Tutorial/DialogBackground");

    // è®¾ç½®æ–‡å­—æ ·å¼
    this.contentText.font = Resources.Load<Font>("Fonts/TutorialFont");
    this.contentText.fontSize = 24;
    this.contentText.color = Color.white;

    // è®¾ç½®æŒ‰é’®æ ·å¼
    const buttonImage = this.continueButton.GetComponent<Image>();
    buttonImage.sprite = Resources.Load<Sprite>("UI/Tutorial/ContinueButton");
  }
}

interface TutorialDialogue {
  speakerName: string;
  speakerImage?: Sprite;
  content: string;
  position: DialoguePosition;
  audioClip?: AudioClip;
}

enum DialoguePosition {
  BOTTOM_LEFT = 'bottom_left',
  BOTTOM_RIGHT = 'bottom_right',
  TOP_LEFT = 'top_left',
  TOP_RIGHT = 'top_right',
  CENTER = 'center'
}
```

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½å®ç°

### 1. å¼•å¯¼ç®¡ç†å™¨

```typescript
class TutorialManager {
  private tasks: Map<string, TutorialTask> = new Map();
  private currentTask: TutorialTask | null = null;
  private controller: TutorialController;
  private uiManager: TutorialUIManager;
  private persistenceManager: TutorialPersistenceManager;

  // åˆå§‹åŒ–
  public Init(): void {
    this.controller = new TutorialController(this);
    this.uiManager = new TutorialUIManager(this);
    this.persistenceManager = new TutorialPersistenceManager();

    // åŠ è½½å¼•å¯¼é…ç½®
    this.LoadTutorialConfigs();

    // æ¢å¤å¼•å¯¼è¿›åº¦
    this.RestoreTutorialProgress();
  }

  // å¼€å§‹å¼•å¯¼ä»»åŠ¡
  public StartTutorial(tutorialId: string): void {
    const task = this.tasks.get(tutorialId);
    if (!task || task.status !== TutorialTaskStatus.AVAILABLE) {
      return;
    }

    this.currentTask = task;
    task.status = TutorialTaskStatus.IN_PROGRESS;
    task.progress.startTime = Date.now();

    // å¼€å§‹æ‰§è¡Œç¬¬ä¸€ä¸ªæ­¥éª¤
    this.controller.StartTask(task);

    // é€šçŸ¥UIæ›´æ–°
    this.uiManager.OnTutorialStarted(task);
  }

  // å®Œæˆæ­¥éª¤
  public CompleteStep(stepId: string): void {
    if (!this.currentTask) return;

    const stepIndex = this.currentTask.steps.indexOf(stepId);
    if (stepIndex === -1) return;

    // æ ‡è®°æ­¥éª¤å®Œæˆ
    this.currentTask.progress.completedSteps.push(stepId);
    this.currentTask.progress.currentStep = stepIndex + 1;

    // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å®Œæˆ
    if (this.IsTaskCompleted(this.currentTask)) {
      this.CompleteTutorial(this.currentTask);
    } else {
      // æ‰§è¡Œä¸‹ä¸€æ­¥
      this.controller.ExecuteNextStep(this.currentTask);
    }

    // ä¿å­˜è¿›åº¦
    this.persistenceManager.SaveProgress(this.currentTask);
  }

  // è·³è¿‡å¼•å¯¼
  public SkipTutorial(tutorialId: string): void {
    const task = this.tasks.get(tutorialId);
    if (!task) return;

    task.status = TutorialTaskStatus.SKIPPED;

    // éšè—æ‰€æœ‰UI
    this.uiManager.HideAll();

    // å‘æ”¾è·³è¿‡å¥–åŠ±ï¼ˆå¦‚æœæœ‰ï¼‰
    this.GrantSkipRewards(task);

    // ä¿å­˜çŠ¶æ€
    this.persistenceManager.SaveTutorialState(task);
  }

  // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å®Œæˆ
  private IsTaskCompleted(task: TutorialTask): boolean {
    return task.progress.completedSteps.length === task.steps.length;
  }

  // å®Œæˆå¼•å¯¼ä»»åŠ¡
  private CompleteTutorial(task: TutorialTask): void {
    task.status = TutorialTaskStatus.COMPLETED;
    task.completedTime = Date.now();

    // å‘æ”¾å¥–åŠ±
    this.GrantRewards(task);

    // è§£é”åç»­ä»»åŠ¡
    this.UnlockNextTasks(task);

    // é€šçŸ¥UI
    this.uiManager.OnTutorialCompleted(task);

    // ç»Ÿè®¡åˆ†æ
    this.AnalyticsTrackCompletion(task);

    this.currentTask = null;
  }
}
```

### 2. å¼•å¯¼æ§åˆ¶å™¨

```typescript
class TutorialController {
  private manager: TutorialManager;
  private executor: TutorialExecutor;
  private currentStep: TutorialStep | null = null;

  // å¼€å§‹ä»»åŠ¡
  public StartTask(task: TutorialTask): void {
    if (task.steps.length === 0) return;

    const firstStepId = task.steps[0];
    this.ExecuteStep(firstStepId);
  }

  // æ‰§è¡Œæ­¥éª¤
  public ExecuteStep(stepId: string): void {
    const step = this.GetStepById(stepId);
    if (!step) return;

    // æ£€æŸ¥å‰ç½®æ¡ä»¶
    if (!this.CheckPrerequisites(step)) {
      return;
    }

    this.currentStep = step;
    step.status = TutorialStepStatus.IN_PROGRESS;

    // æ‰§è¡Œæ­¥éª¤
    this.executor.ExecuteStep(step);
  }

  // æ‰§è¡Œä¸‹ä¸€æ­¥
  public ExecuteNextStep(task: TutorialTask): void {
    const currentIndex = task.steps.indexOf(this.currentStep!.id);
    if (currentIndex === -1 || currentIndex >= task.steps.length - 1) {
      return;
    }

    const nextStepId = task.steps[currentIndex + 1];
    this.ExecuteStep(nextStepId);
  }

  // å®Œæˆæ­¥éª¤
  public CompleteCurrentStep(): void {
    if (!this.currentStep) return;

    this.currentStep.status = TutorialStepStatus.COMPLETED;
    this.currentStep.completedTime = Date.now();

    // é€šçŸ¥ç®¡ç†å™¨
    this.manager.CompleteStep(this.currentStep.id);

    this.currentStep = null;
  }

  // æ£€æŸ¥å‰ç½®æ¡ä»¶
  private CheckPrerequisites(step: TutorialStep): boolean {
    for (const prereqId of step.prerequisites) {
      const prereqStep = this.GetStepById(prereqId);
      if (!prereqStep || prereqStep.status !== TutorialStepStatus.COMPLETED) {
        return false;
      }
    }
    return true;
  }

  // è·å–æ­¥éª¤
  private GetStepById(stepId: string): TutorialStep | null {
    // ä»é…ç½®ä¸­è·å–æ­¥éª¤
    return TutorialConfigManager.Instance.GetStep(stepId);
  }
}
```

### 3. å¼•å¯¼æ‰§è¡Œå™¨

```typescript
class TutorialExecutor {
  private controller: TutorialController;
  private uiManager: TutorialUIManager;

  // æ‰§è¡Œæ­¥éª¤
  public ExecuteStep(step: TutorialStep): void {
    switch (step.type) {
      case TutorialStepType.DIALOGUE:
        this.ExecuteDialogueStep(step);
        break;
      case TutorialStepType.HIGHLIGHT:
        this.ExecuteHighlightStep(step);
        break;
      case TutorialStepType.CLICK:
        this.ExecuteClickStep(step);
        break;
      case TutorialStepType.WAIT:
        this.ExecuteWaitStep(step);
        break;
      default:
        this.ExecuteCustomStep(step);
        break;
    }
  }

  // æ‰§è¡Œå¯¹è¯æ­¥éª¤
  private async ExecuteDialogueStep(step: TutorialStep): Promise<void> {
    const dialogue = step.actions[0] as TutorialDialogue;

    // æ˜¾ç¤ºå¯¹è¯æ¡†
    await this.uiManager.ShowDialog(dialogue);

    // ç­‰å¾…ç©å®¶ç‚¹å‡»ç»§ç»­
    await this.WaitForContinue();

    // å®Œæˆæ­¥éª¤
    this.controller.CompleteCurrentStep();
  }

  // æ‰§è¡Œé«˜äº®æ­¥éª¤
  private ExecuteHighlightStep(step: TutorialStep): void {
    const highlightAction = step.actions[0] as TutorialHighlightAction;

    // è·å–ç›®æ ‡å¯¹è±¡
    const targetObject = this.FindTargetObject(highlightAction.targetPath);

    // æ˜¾ç¤ºé«˜äº®é®ç½©
    this.uiManager.ShowHighlight(targetObject);

    // è®¾ç½®ç‚¹å‡»ç›‘å¬
    this.SetupTargetClickListener(targetObject, step);
  }

  // æ‰§è¡Œç‚¹å‡»æ­¥éª¤
  private ExecuteClickStep(step: TutorialStep): void {
    const clickAction = step.actions[0] as TutorialClickAction;

    // è·å–ç›®æ ‡å¯¹è±¡
    const targetObject = this.FindTargetObject(clickAction.targetPath);

    // æ˜¾ç¤ºç‚¹å‡»å¼•å¯¼
    this.uiManager.ShowClickGuide(targetObject);

    // ç›‘å¬ç‚¹å‡»äº‹ä»¶
    const clickHandler = () => {
      this.OnTargetClicked(step);
    };

    // æ·»åŠ äº‹ä»¶ç›‘å¬
    this.AddClickListener(targetObject, clickHandler);
  }

  // æ‰§è¡Œç­‰å¾…æ­¥éª¤
  private async ExecuteWaitStep(step: TutorialStep): Promise<void> {
    const waitAction = step.actions[0] as TutorialWaitAction;

    // æ˜¾ç¤ºç­‰å¾…æç¤º
    this.uiManager.ShowWaitIndicator(waitAction.message);

    // ç­‰å¾…æŒ‡å®šæ—¶é—´æˆ–æ¡ä»¶
    if (waitAction.duration) {
      await this.WaitForDuration(waitAction.duration);
    } else if (waitAction.condition) {
      await this.WaitForCondition(waitAction.condition);
    }

    // å®Œæˆæ­¥éª¤
    this.controller.CompleteCurrentStep();
  }

  // æŸ¥æ‰¾ç›®æ ‡å¯¹è±¡
  private FindTargetObject(path: string): GameObject {
    // æ”¯æŒå¤šç§å¯»å€æ–¹å¼
    if (path.startsWith("/")) {
      // ç»å¯¹è·¯å¾„
      return GameObject.Find(path);
    } else if (path.startsWith("@")) {
      // ç»„ä»¶æŸ¥æ‰¾
      return this.FindByComponent(path.substring(1));
    } else {
      // ç›¸å¯¹è·¯å¾„
      return GameObject.Find(path);
    }
  }

  // ç›®æ ‡ç‚¹å‡»å¤„ç†
  private OnTargetClicked(step: TutorialStep): void {
    // éªŒè¯ç‚¹å‡»æ˜¯å¦æ­£ç¡®
    if (this.ValidateClick(step)) {
      this.controller.CompleteCurrentStep();
    } else {
      // æ˜¾ç¤ºé”™è¯¯æç¤º
      this.uiManager.ShowErrorMessage("è¯·ç‚¹å‡»æ­£ç¡®çš„ä½ç½®");
    }
  }

  // éªŒè¯ç‚¹å‡»
  private ValidateClick(step: TutorialStep): boolean {
    // æ ¹æ®æ­¥éª¤é…ç½®éªŒè¯ç‚¹å‡»
    const clickAction = step.actions[0] as TutorialClickAction;
    return clickAction.validation?.() ?? true;
  }
}
```

## ğŸ¨ UIç»„ä»¶è®¾è®¡

### å¼•å¯¼é®ç½©ç»„ä»¶

```typescript
class TutorialMaskComponent extends MonoBehaviour {
  [SerializeField] private Image maskImage;
  [SerializeField] private RectTransform highlightArea;
  [SerializeField] private float fadeDuration = 0.3f;

  private Material maskMaterial;
  private Coroutine fadeCoroutine;

  void Awake() {
    this.InitializeMask();
  }

  // åˆå§‹åŒ–é®ç½©
  private void InitializeMask() {
    this.maskMaterial = new Material(Shader.Find("UI/TutorialMask"));
    this.maskImage.material = this.maskMaterial;

    // è®¾ç½®é»˜è®¤å‚æ•°
    this.maskMaterial.SetColor("_MaskColor", new Color(0, 0, 0, 0.8f));
    this.maskMaterial.SetFloat("_HighlightStrength", 0.3f);
  }

  // æ˜¾ç¤ºé«˜äº®åŒºåŸŸ
  public void ShowHighlight(Rect targetRect, bool animate = true) {
    this.gameObject.SetActive(true);

    if (animate) {
      this.AnimateToRect(targetRect);
    } else {
      this.SetHighlightRect(targetRect);
    }
  }

  // éšè—é®ç½©
  public void Hide(bool animate = true) {
    if (animate) {
      this.StartFadeOut();
    } else {
      this.gameObject.SetActive(false);
    }
  }

  // è®¾ç½®é«˜äº®çŸ©å½¢
  private void SetHighlightRect(Rect rect) {
    this.highlightArea.sizeDelta = new Vector2(rect.width, rect.height);
    this.highlightArea.anchoredPosition = new Vector2(rect.x, rect.y);
  }

  // åŠ¨ç”»è¿‡æ¸¡åˆ°ç›®æ ‡çŸ©å½¢
  private void AnimateToRect(Rect targetRect) {
    if (this.fadeCoroutine != null) {
      this.StopCoroutine(this.fadeCoroutine);
    }

    this.fadeCoroutine = this.StartCoroutine(this.AnimateHighlight(targetRect));
  }

  private IEnumerator AnimateHighlight(Rect targetRect) {
    const startSize = this.highlightArea.sizeDelta;
    const startPos = this.highlightArea.anchoredPosition;
    const targetSize = new Vector2(targetRect.width, targetRect.height);
    const targetPos = new Vector2(targetRect.x, targetRect.y);

    float elapsed = 0f;

    while (elapsed < this.fadeDuration) {
      elapsed += Time.deltaTime;
      const t = elapsed / this.fadeDuration;

      this.highlightArea.sizeDelta = Vector2.Lerp(startSize, targetSize, t);
      this.highlightArea.anchoredPosition = Vector2.Lerp(startPos, targetPos, t);

      yield return null;
    }

    this.SetHighlightRect(targetRect);
  }

  // å¼€å§‹æ·¡å‡º
  private void StartFadeOut() {
    if (this.fadeCoroutine != null) {
      this.StopCoroutine(this.fadeCoroutine);
    }

    this.fadeCoroutine = this.StartCoroutine(this.FadeOut());
  }

  private IEnumerator FadeOut() {
    const startAlpha = this.maskImage.color.a;
    float elapsed = 0f;

    while (elapsed < this.fadeDuration) {
      elapsed += Time.deltaTime;
      const t = elapsed / this.fadeDuration;
      const alpha = Mathf.Lerp(startAlpha, 0f, t);

      const color = this.maskImage.color;
      color.a = alpha;
      this.maskImage.color = color;

      yield return null;
    }

    this.gameObject.SetActive(false);
  }
}
```

### å¼•å¯¼ç®­å¤´ç»„ä»¶

```typescript
class TutorialArrowComponent extends MonoBehaviour {
  [SerializeField] private Image arrowImage;
  [SerializeField] private Animator animator;
  [SerializeField] private float bobAmount = 10f;
  [SerializeField] private float bobSpeed = 2f;

  private Vector3 originalPosition;
  private Coroutine bobCoroutine;

  void Awake() {
    this.originalPosition = this.transform.localPosition;
  }

  // æ˜¾ç¤ºç®­å¤´
  public void Show(Vector3 worldPosition, ArrowDirection direction) {
    // è½¬æ¢ä¸–ç•Œåæ ‡åˆ°å±å¹•åæ ‡
    const screenPoint = Camera.main.WorldToScreenPoint(worldPosition);
    const canvasPos = this.ConvertToCanvasPosition(screenPoint);

    this.transform.localPosition = canvasPos;
    this.SetDirection(direction);

    // å¼€å§‹ä¸Šä¸‹æµ®åŠ¨åŠ¨ç”»
    this.StartBobAnimation();

    this.gameObject.SetActive(true);
  }

  // éšè—ç®­å¤´
  public void Hide() {
    if (this.bobCoroutine != null) {
      this.StopCoroutine(this.bobCoroutine);
    }

    this.gameObject.SetActive(false);
    this.transform.localPosition = this.originalPosition;
  }

  // è®¾ç½®æ–¹å‘
  private void SetDirection(ArrowDirection direction) {
    float rotation = 0f;

    switch (direction) {
      case ArrowDirection.UP:
        rotation = 0f;
        break;
      case ArrowDirection.DOWN:
        rotation = 180f;
        break;
      case ArrowDirection.LEFT:
        rotation = 90f;
        break;
      case ArrowDirection.RIGHT:
        rotation = -90f;
        break;
    }

    this.transform.rotation = Quaternion.Euler(0f, 0f, rotation);
  }

  // è½¬æ¢åˆ°Canvasåæ ‡
  private Vector2 ConvertToCanvasPosition(Vector3 screenPoint) {
    const canvas = this.GetComponentInParent<Canvas>();
    const canvasRect = canvas.GetComponent<RectTransform>();

    const canvasSize = canvasRect.sizeDelta;
    return new Vector2(
      screenPoint.x - canvasSize.x / 2,
      screenPoint.y - canvasSize.y / 2
    );
  }

  // å¼€å§‹ä¸Šä¸‹æµ®åŠ¨åŠ¨ç”»
  private void StartBobAnimation() {
    if (this.bobCoroutine != null) {
      this.StopCoroutine(this.bobCoroutine);
    }

    this.bobCoroutine = this.StartCoroutine(this.BobAnimation());
  }

  private IEnumerator BobAnimation() {
    while (true) {
      const bobOffset = Mathf.Sin(Time.time * this.bobSpeed) * this.bobAmount;
      this.transform.localPosition = this.originalPosition + new Vector3(0f, bobOffset, 0f);

      yield return null;
    }
  }
}
```

## ğŸš€ é«˜çº§åŠŸèƒ½

### 1. å¼•å¯¼æ¡ä»¶ç³»ç»Ÿ

```typescript
interface TutorialCondition {
  type: ConditionType;
  key: string;
  operator: ConditionOperator;
  value: any;
  description: string;
}

enum ConditionType {
  GAME_STATE = 'game_state',     // æ¸¸æˆçŠ¶æ€
  PLAYER_LEVEL = 'player_level', // ç©å®¶ç­‰çº§
  ITEM_COUNT = 'item_count',     // ç‰©å“æ•°é‡
  QUEST_STATUS = 'quest_status', // ä»»åŠ¡çŠ¶æ€
  UI_VISIBLE = 'ui_visible',     // UIå¯è§æ€§
  CUSTOM = 'custom'              // è‡ªå®šä¹‰æ¡ä»¶
}

class TutorialConditionEvaluator {
  // è¯„ä¼°æ¡ä»¶
  public EvaluateCondition(condition: TutorialCondition): boolean {
    switch (condition.type) {
      case ConditionType.GAME_STATE:
        return this.EvaluateGameState(condition);
      case ConditionType.PLAYER_LEVEL:
        return this.EvaluatePlayerLevel(condition);
      case ConditionType.ITEM_COUNT:
        return this.EvaluateItemCount(condition);
      case ConditionType.QUEST_STATUS:
        return this.EvaluateQuestStatus(condition);
      case ConditionType.UI_VISIBLE:
        return this.EvaluateUIVisible(condition);
      case ConditionType.CUSTOM:
        return this.EvaluateCustom(condition);
      default:
        return false;
    }
  }

  private EvaluateGameState(condition: TutorialCondition): boolean {
    const currentState = GameStateManager.Instance.GetCurrentState();
    return this.CompareValues(currentState, condition.operator, condition.value);
  }

  private EvaluatePlayerLevel(condition: TutorialCondition): boolean {
    const playerLevel = PlayerManager.Instance.GetLevel();
    return this.CompareValues(playerLevel, condition.operator, condition.value);
  }

  private EvaluateItemCount(condition: TutorialCondition): boolean {
    const itemCount = InventoryManager.Instance.GetItemCount(condition.key);
    return this.CompareValues(itemCount, condition.operator, condition.value);
  }

  private CompareValues(left: any, operator: ConditionOperator, right: any): boolean {
    switch (operator) {
      case ConditionOperator.EQUAL:
        return left === right;
      case ConditionOperator.NOT_EQUAL:
        return left !== right;
      case ConditionOperator.GREATER:
        return left > right;
      case ConditionOperator.GREATER_EQUAL:
        return left >= right;
      case ConditionOperator.LESS:
        return left < right;
      case ConditionOperator.LESS_EQUAL:
        return left <= right;
      default:
        return false;
    }
  }
}
```

### 2. å¼•å¯¼æ•°æ®æŒä¹…åŒ–

```typescript
class TutorialPersistenceManager {
  private readonly SAVE_KEY = "tutorial_progress";
  private saveData: TutorialSaveData;

  // ä¿å­˜å¼•å¯¼è¿›åº¦
  public SaveProgress(task: TutorialTask): void {
    this.loadSaveData();

    const taskProgress: TaskProgress = {
      taskId: task.id,
      status: task.status,
      currentStep: task.progress.currentStep,
      completedSteps: task.progress.completedSteps,
      startTime: task.progress.startTime,
      completedTime: task.completedTime
    };

    this.saveData.taskProgress[task.id] = taskProgress;
    this.saveData.lastSaveTime = Date.now();

    this.SaveToStorage();
  }

  // åŠ è½½å¼•å¯¼è¿›åº¦
  public LoadProgress(): Map<string, TaskProgress> {
    this.loadSaveData();
    return new Map(Object.entries(this.saveData.taskProgress));
  }

  // ä¿å­˜æ•™ç¨‹çŠ¶æ€
  public SaveTutorialState(task: TutorialTask): void {
    this.loadSaveData();

    const taskState: TaskState = {
      taskId: task.id,
      status: task.status,
      completedTime: task.completedTime
    };

    this.saveData.taskStates[task.id] = taskState;
    this.SaveToStorage();
  }

  // åŠ è½½æ•™ç¨‹çŠ¶æ€
  public LoadTutorialStates(): Map<string, TaskState> {
    this.loadSaveData();
    return new Map(Object.entries(this.saveData.taskStates));
  }

  // åŠ è½½ä¿å­˜æ•°æ®
  private loadSaveData(): void {
    if (this.saveData) return;

    const saveString = PlayerPrefs.GetString(this.SAVE_KEY, "");
    if (string.IsNullOrEmpty(saveString)) {
      this.saveData = this.CreateDefaultSaveData();
    } else {
      try {
        this.saveData = JsonUtility.FromJson<TutorialSaveData>(saveString);

        // ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
        if (this.saveData.version !== "1.0") {
          this.MigrateSaveData();
        }
      } catch (Exception e) {
        Debug.LogError($"Failed to load tutorial save data: {e.Message}");
        this.saveData = this.CreateDefaultSaveData();
      }
    }
  }

  // ä¿å­˜åˆ°å­˜å‚¨
  private void SaveToStorage(): void {
    const saveString = JsonUtility.ToJson(this.saveData);
    PlayerPrefs.SetString(this.SAVE_KEY, saveString);
    PlayerPrefs.Save();
  }

  // åˆ›å»ºé»˜è®¤ä¿å­˜æ•°æ®
  private TutorialSaveData CreateDefaultSaveData(): TutorialSaveData {
    return {
      version: "1.0",
      taskProgress: {},
      taskStates: {},
      lastSaveTime: Date.now()
    };
  }

  // æ•°æ®è¿ç§»
  private void MigrateSaveData(): void {
    // å¤„ç†ç‰ˆæœ¬å‡çº§æ—¶çš„å…¼å®¹æ€§
    if (this.saveData.version === "0.9") {
      // ä»0.9ç‰ˆæœ¬è¿ç§»åˆ°1.0çš„é€»è¾‘
      // ...
    }
  }
}

interface TutorialSaveData {
  version: string;
  taskProgress: { [key: string]: TaskProgress };
  taskStates: { [key: string]: TaskState };
  lastSaveTime: number;
}

interface TaskProgress {
  taskId: string;
  status: TutorialTaskStatus;
  currentStep: number;
  completedSteps: string[];
  startTime: number;
  completedTime?: number;
}

interface TaskState {
  taskId: string;
  status: TutorialTaskStatus;
  completedTime?: number;
}
```

### 3. å¼•å¯¼ç»Ÿè®¡åˆ†æ

```typescript
class TutorialAnalytics {
  // è·Ÿè¸ªå¼•å¯¼å¼€å§‹
  public TrackTutorialStart(tutorialId: string, taskId: string): void {
    AnalyticsManager.TrackEvent("tutorial_start", {
      tutorial_id: tutorialId,
      task_id: taskId,
      timestamp: Date.now(),
      player_level: PlayerManager.Instance.GetLevel(),
      session_count: SessionManager.Instance.GetSessionCount()
    });
  }

  // è·Ÿè¸ªæ­¥éª¤å®Œæˆ
  public TrackStepComplete(stepId: string, tutorialId: string, duration: number): void {
    AnalyticsManager.TrackEvent("tutorial_step_complete", {
      step_id: stepId,
      tutorial_id: tutorialId,
      duration: duration,
      timestamp: Date.now()
    });
  }

  // è·Ÿè¸ªå¼•å¯¼å®Œæˆ
  public TrackTutorialComplete(tutorialId: string, taskId: string, totalDuration: number): void {
    AnalyticsManager.TrackEvent("tutorial_complete", {
      tutorial_id: tutorialId,
      task_id: taskId,
      total_duration: totalDuration,
      completion_rate: this.CalculateCompletionRate(taskId),
      timestamp: Date.now()
    });
  }

  // è·Ÿè¸ªå¼•å¯¼è·³è¿‡
  public TrackTutorialSkip(tutorialId: string, taskId: string, skipStep: number): void {
    AnalyticsManager.TrackEvent("tutorial_skip", {
      tutorial_id: tutorialId,
      task_id: taskId,
      skip_step: skipStep,
      timestamp: Date.now()
    });
  }

  // è·Ÿè¸ªå¼•å¯¼å¤±è´¥
  public TrackTutorialFail(tutorialId: string, taskId: string, failReason: string): void {
    AnalyticsManager.TrackEvent("tutorial_fail", {
      tutorial_id: tutorialId,
      task_id: taskId,
      fail_reason: failReason,
      timestamp: Date.now()
    });
  }

  // è®¡ç®—å®Œæˆç‡
  private float CalculateCompletionRate(taskId: string): float {
    const task = TutorialManager.Instance.GetTask(taskId);
    if (!task) return 0f;

    return (float)task.progress.completedSteps.Count / task.steps.Count;
  }

  // ç”Ÿæˆå¼•å¯¼æŠ¥å‘Š
  public TutorialReport GenerateReport(tutorialId: string): TutorialReport {
    const task = TutorialManager.Instance.GetTask(tutorialId);
    if (!task) return null;

    return {
      tutorialId: tutorialId,
      taskId: task.id,
      status: task.status,
      completionRate: this.CalculateCompletionRate(tutorialId),
      totalDuration: task.completedTime - task.progress.startTime,
      averageStepDuration: this.CalculateAverageStepDuration(task),
      skipCount: task.status === TutorialTaskStatus.SKIPPED ? 1 : 0,
      retryCount: 0 // å¯ä»¥ä»å†å²è®°å½•ä¸­è·å–
    };
  }

  // è®¡ç®—å¹³å‡æ­¥éª¤æ—¶é•¿
  private float CalculateAverageStepDuration(task: TutorialTask): float {
    if (task.progress.completedSteps.Count === 0) return 0f;

    // è¿™é‡Œéœ€è¦æ›´å¤æ‚çš„é€»è¾‘æ¥è®¡ç®—æ¯ä¸ªæ­¥éª¤çš„æ—¶é•¿
    // ç®€åŒ–ä¸ºæ€»æ—¶é•¿é™¤ä»¥æ­¥éª¤æ•°
    const totalDuration = task.completedTime - task.progress.startTime;
    return totalDuration / task.steps.Count;
  }
}

interface TutorialReport {
  tutorialId: string;
  taskId: string;
  status: TutorialTaskStatus;
  completionRate: number;
  totalDuration: number;
  averageStepDuration: number;
  skipCount: number;
  retryCount: number;
}
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. è®¾è®¡åŸåˆ™
- **æ¸è¿›å¼å¼•å¯¼**ï¼šä»ç®€å•åˆ°å¤æ‚ï¼Œå¾ªåºæ¸è¿›
- **åŠæ—¶åé¦ˆ**ï¼šæ“ä½œåç«‹å³ç»™äºˆåé¦ˆ
- **å®¹é”™æ€§å¼º**ï¼šå…è®¸ç©å®¶çŠ¯é”™å¹¶å¼•å¯¼çº æ­£
- **ä¸ªæ€§åŒ–**ï¼šæ ¹æ®ç©å®¶è¡Œä¸ºè°ƒæ•´å¼•å¯¼å†…å®¹
- **éä¾µå…¥æ€§**ï¼šä¸å½±å“æ­£å¸¸æ¸¸æˆä½“éªŒ

### 2. å¼•å¯¼ç±»å‹é€‰æ‹©
- **å¼ºåˆ¶å¼•å¯¼**ï¼šæ ¸å¿ƒç©æ³•å¿…é¡»æŒæ¡çš„å†…å®¹
- **å¯é€‰å¼•å¯¼**ï¼šé”¦ä¸Šæ·»èŠ±çš„è¿›é˜¶å†…å®¹
- **æƒ…å¢ƒå¼•å¯¼**ï¼šç‰¹å®šæƒ…å†µä¸‹è§¦å‘çš„å¼•å¯¼
- **æˆå°±å¼•å¯¼**ï¼šé€šè¿‡æˆå°±ç³»ç»Ÿå¼•å¯¼æ¢ç´¢

### 3. UIè®¾è®¡è¦ç‚¹
- **è§†è§‰å±‚æ¬¡æ¸…æ™°**ï¼šå¼•å¯¼å…ƒç´ è¦çªå‡ºä½†ä¸å–§å®¾å¤ºä¸»
- **åŠ¨ç”»æµç•…è‡ªç„¶**ï¼šè¿‡æ¸¡åŠ¨ç”»è¦å¹³æ»‘èˆ’é€‚
- **å“åº”å¼è®¾è®¡**ï¼šé€‚åº”ä¸åŒå±å¹•å°ºå¯¸å’Œåˆ†è¾¨ç‡
- **æ— éšœç¢è®¾è®¡**ï¼šè€ƒè™‘è‰²ç›²ã€è§†åŠ›éšœç¢ç­‰ç‰¹æ®Šéœ€æ±‚

### 4. æ•°æ®é©±åŠ¨è®¾è®¡
- **é…ç½®åŒ–ç®¡ç†**ï¼šå¼•å¯¼å†…å®¹é€šè¿‡é…ç½®ç®¡ç†
- **A/Bæµ‹è¯•æ”¯æŒ**ï¼šæ”¯æŒä¸åŒç‰ˆæœ¬çš„å¼•å¯¼å¯¹æ¯”
- **åŠ¨æ€è°ƒæ•´**ï¼šæ ¹æ®ç©å®¶åé¦ˆè°ƒæ•´å¼•å¯¼ç­–ç•¥
- **ç‰ˆæœ¬å…¼å®¹**ï¼šå¤„ç†æ¸¸æˆç‰ˆæœ¬æ›´æ–°æ—¶çš„å…¼å®¹æ€§

---

*æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„æ–°æ‰‹å¼•å¯¼ç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆï¼ŒåŒ…å«æ•°æ®ç»“æ„ã€ä»£ç æ¶æ„ã€UIå®ç°æ€è·¯ä»¥åŠé«˜çº§åŠŸèƒ½ã€‚åœ¨å®é™…é¡¹ç›®ä¸­å¯æ ¹æ®å…·ä½“éœ€æ±‚è¿›è¡Œè°ƒæ•´å’Œä¼˜åŒ–ã€‚*
