# æ£‹ç‰Œç±»æ¸¸æˆæ¶æ„è®¾è®¡

## ğŸ¯ æ¸¸æˆæ¦‚è¿°

æ£‹ç‰Œç±»æ¸¸æˆæ˜¯ä¸€ç±»åŸºäºè§„åˆ™çš„ç­–ç•¥æ¸¸æˆï¼ŒåŒ…æ‹¬çº¸ç‰Œæ¸¸æˆï¼ˆæ‰‘å…‹ã€æ¡¥ç‰Œã€æ–—åœ°ä¸»ï¼‰å’Œæ£‹ç›˜æ¸¸æˆï¼ˆè±¡æ£‹ã€å›´æ£‹ã€äº”å­æ£‹ã€å›½é™…è±¡æ£‹ï¼‰ã€‚æ ¸å¿ƒç©æ³•å›´ç»•è§„åˆ™ç†è§£ã€ç­–ç•¥æ€è€ƒã€æ¦‚ç‡è®¡ç®—å±•å¼€ã€‚ä»£è¡¨ä½œå“åŒ…æ‹¬ã€ŠTexas Hold'emã€‹ã€ã€Šéº»å°†ã€‹ã€ã€Šè±¡æ£‹ã€‹ç­‰ã€‚

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„æ¨¡å—

### 0. æ ¸å¿ƒæˆ˜æ–—æ¨¡å— (Combat System)

#### æ£‹ç‰Œç«æŠ€æ¨¡å¼æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ£‹ç‰Œç«æŠ€ç³»ç»Ÿæ¶æ„                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  ç­–ç•¥æ€è€ƒ    â”‚ -> â”‚  è¡ŒåŠ¨æ‰§è¡Œ    â”‚ -> â”‚  ç»“æœè¯„ä¼°    â”‚     â”‚
â”‚  â”‚             â”‚    â”‚             â”‚    â”‚             â”‚     â”‚
â”‚  â”‚ â€¢ å±€é¢åˆ†æ   â”‚    â”‚ â€¢ èµ°æ³•é€‰æ‹©   â”‚    â”‚ â€¢ èƒœç‡è®¡ç®—   â”‚     â”‚
â”‚  â”‚ â€¢ å¯¹æ‰‹é¢„æµ‹   â”‚    â”‚ â€¢ è§„åˆ™éªŒè¯   â”‚    â”‚ â€¢ å±€åŠ¿åˆ¤æ–­   â”‚     â”‚
â”‚  â”‚ â€¢ é£é™©è¯„ä¼°   â”‚    â”‚ â€¢ çŠ¶æ€æ›´æ–°   â”‚    â”‚ â€¢ ç­–ç•¥è°ƒæ•´   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²                        â–²                        â”‚
         â”‚                        â”‚                        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     ç«æŠ€ç»“ç®—ç³»ç»Ÿ      â”‚
                    â”‚                     â”‚
                    â”‚ â€¢ èƒœè´Ÿåˆ¤å®š          â”‚
                    â”‚ â€¢ ç§¯åˆ†è®¡ç®—          â”‚
                    â”‚ â€¢ æ’åæ›´æ–°          â”‚
                    â”‚ â€¢ æˆå°±è§£é”          â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ£‹ç‰Œç«æŠ€ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶

```mermaid
mindmap
  root((æ£‹ç‰Œç«æŠ€å¼•æ“))
    ç­–ç•¥åˆ†æç³»ç»Ÿ
      å±€é¢è¯„ä¼°å™¨
      èµ°æ³•ç”Ÿæˆå™¨
      å¯¹æ‰‹å»ºæ¨¡å™¨
      é£é™©è¯„ä¼°å™¨
    è¡ŒåŠ¨æ‰§è¡Œç³»ç»Ÿ
      è§„åˆ™éªŒè¯å™¨
      çŠ¶æ€æ›´æ–°å™¨
      å†å²è®°å½•å™¨
      äº‹ä»¶åˆ†å‘å™¨
    ç«æŠ€AIç³»ç»Ÿ
      æœç´¢ç®—æ³•å™¨
        æå¤§æå°æœç´¢
        Alpha-Betaå‰ªæ
        è’™ç‰¹å¡æ´›æ ‘æœç´¢
      è¯„ä¼°å‡½æ•°å™¨
      å¼€å±€åº“
      æ®‹å±€åº“
    å¯¹æˆ˜ç»Ÿè®¡ç³»ç»Ÿ
      èƒœç‡è®¡ç®—å™¨
      èµ°æ³•ç»Ÿè®¡å™¨
      æ¨¡å¼è¯†åˆ«å™¨
      æ€§èƒ½åˆ†æå™¨
    ç«æŠ€å¹³è¡¡ç³»ç»Ÿ
      éš¾åº¦è°ƒèŠ‚å™¨
      ç§¯åˆ†ç³»ç»Ÿ
      åŒ¹é…æœºåˆ¶
      åä½œå¼Šç³»ç»Ÿ
    ç«æŠ€å¥–åŠ±ç³»ç»Ÿ
      æˆå°±è§£é”å™¨
      å¥–åŠ±åˆ†å‘å™¨
      æ’åç³»ç»Ÿ
      æ™‹çº§æœºåˆ¶
```

#### ç«æŠ€çŠ¶æ€æœºæ¶æ„å›¾

```mermaid
stateDiagram-v2
    [*] --> InitializationState
    InitializationState --> ThinkingState
    ThinkingState --> ActionState
    ActionState --> EvaluationState
    EvaluationState --> ThinkingState
    EvaluationState --> EndState
    ThinkingState --> PauseState
    PauseState --> ThinkingState
    ActionState --> InterruptState
    InterruptState --> [*]

    note right of ThinkingState : ç©å®¶æ€è€ƒè¿‡ç¨‹
    note right of ActionState : æ‰§è¡Œé€‰å®šçš„èµ°æ³•
    note right of EvaluationState : è¯„ä¼°è¡ŒåŠ¨ç»“æœ
    note right of PauseState : å¤„ç†æš‚åœå’Œè¶…æ—¶

    state "åˆå§‹åŒ–çŠ¶æ€" as I
    state "æ¸¸æˆè§„åˆ™åŠ è½½" as GRL
    state "ç©å®¶åŒ¹é…" as PM
    state "åˆå§‹å±€é¢è®¾ç½®" as IPS
    state "è®¡æ—¶å™¨å¯åŠ¨" as TS

    I --> GRL
    I --> PM
    I --> IPS
    I --> TS

    state "æ€è€ƒçŠ¶æ€" as T
    state "å±€é¢åˆ†æ" as PA
    state "èµ°æ³•æšä¸¾" as ME
    state "å¯¹æ‰‹è¡Œä¸ºé¢„æµ‹" as OBP
    state "é£é™©æ”¶ç›Šè¯„ä¼°" as RRA
    state "æœ€ä¼˜èµ°æ³•é€‰æ‹©" as OMS

    T --> PA
    T --> ME
    T --> OBP
    T --> RRA
    T --> OMS

    state "è¡ŒåŠ¨çŠ¶æ€" as A
    state "èµ°æ³•éªŒè¯" as MV
    state "è§„åˆ™åˆè§„æ£€æŸ¥" as RCC
    state "è¡ŒåŠ¨æ‰§è¡Œ" as AE
    state "çŠ¶æ€æ›´æ–°" as SU
    state "å†å²è®°å½•" as HR

    A --> MV
    A --> RCC
    A --> AE
    A --> SU
    A --> HR

    state "è¯„ä¼°çŠ¶æ€" as E
    state "å±€é¢é‡æ–°è¯„ä¼°" as PRE
    state "èƒœç‡é‡æ–°è®¡ç®—" as WRR
    state "ç­–ç•¥æœ‰æ•ˆæ€§éªŒè¯" as SEV
    state "å­¦ä¹ æ•°æ®æ”¶é›†" as LDC
    state "æ¨¡å¼è¯†åˆ«æ›´æ–°" as PRU

    E --> PRE
    E --> WRR
    E --> SEV
    E --> LDC
    E --> PRU

    state "æš‚åœçŠ¶æ€" as P
    state "æ€è€ƒæ—¶é—´ç®¡ç†" as TTM
    state "è¶…æ—¶å¤„ç†" as TOH
    state "æš‚åœè¯·æ±‚å¤„ç†" as PRH
    state "æ¢å¤æœºåˆ¶" as RM

    P --> TTM
    P --> TOH
    P --> PRH
    P --> RM

    state "ç»“æŸçŠ¶æ€" as ES
    state "èƒœè´Ÿåˆ¤å®š" as WLD
    state "æœ€ç»ˆå±€é¢åˆ†æ" as FPA
    state "ç»Ÿè®¡æ•°æ®ç”Ÿæˆ" as SG
    state "ç»éªŒå€¼åˆ†é…" as ED
    state "ä¸‹ä¸€å±€å‡†å¤‡" as NGP

    ES --> WLD
    ES --> FPA
    ES --> SG
    ES --> ED
    ES --> NGP

    state "ä¸­æ–­çŠ¶æ€" as IS
    state "å¼‚å¸¸æƒ…å†µå¤„ç†" as EH
    state "è¿æ¥æ–­å¼€å¤„ç†" as DH
    state "æ•°æ®æ¢å¤æœºåˆ¶" as DRM
    state "å…¬å¹³æ€§ä¿éšœ" as FG

    IS --> EH
    IS --> DH
    IS --> DRM
    IS --> FG
```

#### å†³ç­–æµç¨‹æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant P as ç©å®¶
    participant GS as æ¸¸æˆç³»ç»Ÿ
    participant PA as å±€é¢åˆ†æå™¨
    participant PM as å¯¹æ‰‹å»ºæ¨¡å™¨
    participant MG as èµ°æ³•ç”Ÿæˆå™¨
    participant RA as é£é™©è¯„ä¼°å™¨
    participant AE as è¡ŒåŠ¨æ‰§è¡Œå™¨

    Note over P,AE: å›åˆå¼€å§‹é˜¶æ®µ
    GS->>P: å›åˆå¼€å§‹é€šçŸ¥
    P->>PA: è¯·æ±‚å±€é¢åˆ†æ

    Note over P,AE: å±€é¢æ„ŸçŸ¥é˜¶æ®µ
    PA->>PA: æ”¶é›†å½“å‰å±€é¢ä¿¡æ¯
    PA->>PA: åˆ†æå…³é”®ä½ç½®å’Œæ£‹å­
    PA->>PA: è¯„ä¼°ä¼˜åŠ¿å’ŒåŠ£åŠ¿
    PA->>PA: è¯†åˆ«æ½œåœ¨å¨èƒå’Œæœºä¼š
    PA->>P: è¿”å›åˆ†æç»“æœ

    Note over P,AE: å¯¹æ‰‹é¢„æµ‹é˜¶æ®µ
    P->>PM: è¯·æ±‚å¯¹æ‰‹è¡Œä¸ºé¢„æµ‹
    PM->>PM: åˆ†æå¯¹æ‰‹å†å²è¡Œä¸º
    PM->>PM: é¢„æµ‹å¯èƒ½çš„åº”å¯¹ç­–ç•¥
    PM->>PM: è¯„ä¼°å¯¹æ‰‹é£é™©åå¥½
    PM->>PM: è®¡ç®—å¯¹æ‰‹èƒœç‡ä¼°è®¡
    PM->>P: è¿”å›é¢„æµ‹ç»“æœ

    Note over P,AE: èµ°æ³•ç”Ÿæˆé˜¶æ®µ
    P->>MG: è¯·æ±‚èµ°æ³•ç”Ÿæˆ
    MG->>MG: ç”Ÿæˆæ‰€æœ‰åˆæ³•èµ°æ³•
    MG->>MG: è¯„ä¼°æ¯ä¸ªèµ°æ³•çš„ä»·å€¼
    MG->>MG: è€ƒè™‘çŸ­æœŸå’Œé•¿æœŸå½±å“
    MG->>MG: æ’åºæœ€ä¼˜èµ°æ³•åˆ—è¡¨
    MG->>P: è¿”å›èµ°æ³•åˆ—è¡¨

    Note over P,AE: é£é™©è¯„ä¼°é˜¶æ®µ
    P->>RA: è¯·æ±‚é£é™©è¯„ä¼°
    RA->>RA: è®¡ç®—æ¯ä¸ªèµ°æ³•çš„é£é™©ç³»æ•°
    RA->>RA: è¯„ä¼°æ½œåœ¨çš„åå‡»å¯èƒ½æ€§
    RA->>RA: å¹³è¡¡æ”¶ç›Šå’Œé£é™©
    RA->>RA: é€‰æ‹©æœ€ä¼˜å†³ç­–æ–¹æ¡ˆ
    RA->>P: è¿”å›è¯„ä¼°ç»“æœ

    Note over P,AE: è¡ŒåŠ¨æ‰§è¡Œé˜¶æ®µ
    P->>AE: æ‰§è¡Œé€‰æ‹©çš„èµ°æ³•
    AE->>AE: éªŒè¯èµ°æ³•åˆæ³•æ€§
    AE->>AE: æ›´æ–°æ¸¸æˆçŠ¶æ€
    AE->>AE: å¹¿æ’­è¡ŒåŠ¨ç»“æœ
    AE->>GS: é€šçŸ¥è¡ŒåŠ¨å®Œæˆ

    Note over P,AE: åˆ‡æ¢å¯¹æ‰‹
    GS->>GS: åˆ‡æ¢åˆ°å¯¹æ‰‹å›åˆ
```

#### ç«æŠ€å¹³è¡¡æ€§å‚æ•°çŸ©é˜µå›¾

```mermaid
flowchart TD
    subgraph "æ–°æ‰‹ç©å®¶ç«æŠ€å‚æ•°"
        B1[ç®€å•éš¾åº¦<br/>AIæ·±åº¦: 2<br/>æç¤º: å¤š<br/>æ—¶é—´: é•¿<br/>èƒœç‡: 40%]
        B2[æ™®é€šéš¾åº¦<br/>AIæ·±åº¦: 3<br/>æç¤º: ä¸­<br/>æ—¶é—´: ä¸­<br/>èƒœç‡: 50%]
        B3[å›°éš¾éš¾åº¦<br/>AIæ·±åº¦: 4<br/>æç¤º: å°‘<br/>æ—¶é—´: çŸ­<br/>èƒœç‡: 60%]
    end

    subgraph "ç†Ÿç»ƒç©å®¶ç«æŠ€å‚æ•°"
        I1[æŒ‘æˆ˜éš¾åº¦<br/>AIæ·±åº¦: 5<br/>æç¤º: æ— <br/>æ—¶é—´: ä¸­<br/>èƒœç‡: 30%]
        I2[ä¸“å®¶éš¾åº¦<br/>AIæ·±åº¦: 6<br/>æç¤º: æ— <br/>æ—¶é—´: çŸ­<br/>èƒœç‡: 20%]
        I3[å¤§å¸ˆéš¾åº¦<br/>AIæ·±åº¦: 8<br/>æç¤º: æ— <br/>æ—¶é—´: çŸ­<br/>èƒœç‡: 10%]
    end

    subgraph "é”¦æ ‡èµ›ç«æŠ€å‚æ•°"
        T1[èµ„æ ¼èµ›<br/>åŒ¹é…: ç›¸ä¼¼<br/>ç§¯åˆ†: åŸºç¡€<br/>å¥–åŠ±: æ™®é€š<br/>è§‚ä¼—: æ— ]
        T2[æ·˜æ±°èµ›<br/>åŒ¹é…: ç­‰çº§<br/>ç§¯åˆ†: åŒå€<br/>å¥–åŠ±: ä¸°å¯Œ<br/>è§‚ä¼—: æœ‰]
        T3[å†³èµ›<br/>åŒ¹é…: é¡¶å°–<br/>ç§¯åˆ†: ä¸‰å€<br/>å¥–åŠ±: è±ªå<br/>è§‚ä¼—: ç›´æ’­]
    end

    P[ç©å®¶æ°´å¹³] --> B1
    P --> I1
    P --> T1

    B1 --> B2 --> B3
    I1 --> I2 --> I3
    T1 --> T2 --> T3

    style B1 fill:#e6f3ff
    style B2 fill:#cce6ff
    style B3 fill:#99ccff
    style I1 fill:#ffe6cc
    style I2 fill:#ffcc99
    style I3 fill:#ffaa66
    style T1 fill:#e6ffe6
    style T2 fill:#ccffcc
    style T3 fill:#99ff99
```

#### æˆ˜æ–—å¹³è¡¡æ€§å‚æ•°
```typescript
interface CardBoardCombatConfig {
  // AIç®—æ³•å‚æ•°
  aiSearchDepth: number;            // AIæœç´¢æ·±åº¦
  aiThinkingTime: number;           // AIæ€è€ƒæ—¶é—´ (ç§’)
  aiEvaluationWeight: number;       // AIè¯„ä¼°æƒé‡
  aiRandomnessFactor: number;       // AIéšæœºæ€§å› å­

  // ç«æŠ€å¹³è¡¡å‚æ•°
  playerRatingAdjustment: number;   // ç©å®¶è¯„åˆ†è°ƒæ•´
  matchMakingRange: number;         // åŒ¹é…èŒƒå›´
  winRateTarget: number;           // ç›®æ ‡èƒœç‡
  difficultyScalingFactor: number;  // éš¾åº¦ç¼©æ”¾å› å­

  // æ—¶é—´æ§åˆ¶å‚æ•°
  baseTurnTime: number;            // åŸºç¡€å›åˆæ—¶é—´
  timeBonusPerMove: number;        // æ¯æ­¥æ—¶é—´å¥–åŠ±
  timePenaltyPerTimeout: number;   // è¶…æ—¶æƒ©ç½š
  maximumGameTime: number;         // æœ€å¤§æ¸¸æˆæ—¶é—´

  // å¥–åŠ±ç³»ç»Ÿå‚æ•°
  baseExperienceReward: number;    // åŸºç¡€ç»éªŒå¥–åŠ±
  ratingChangeMultiplier: number;  // è¯„åˆ†å˜åŒ–å€ç‡
  achievementUnlockThreshold: number; // æˆå°±è§£é”é˜ˆå€¼
  tournamentBonusMultiplier: number;  // é”¦æ ‡èµ›å¥–åŠ±å€ç‡

  // åä½œå¼Šå‚æ•°
  moveValidationStrictness: number; // èµ°æ³•éªŒè¯ä¸¥æ ¼ç¨‹åº¦
  timingAnomalyThreshold: number;   // æ—¶é—´å¼‚å¸¸é˜ˆå€¼
  patternDetectionSensitivity: number; // æ¨¡å¼æ£€æµ‹çµæ•åº¦
}
```

#### æ£‹ç‰Œç«æŠ€ç³»ç»Ÿç±»å›¾

```mermaid
classDiagram
    class CardBoardCombatEngine {
        -GameSession gameSession
        -StrategyAnalyzer strategyAnalyzer
        -ActionExecutor actionExecutor
        -AISystem aiSystem
        -MatchStatistics matchStatistics
        +initializeGame(players): GameSession
        +startTurn(currentPlayer): TurnResult
        +executeMove(move): MoveResult
        +evaluatePosition(): PositionEvaluation
        +resolveGame(): GameResult
    }

    class StrategyAnalyzer {
        -PositionEvaluator positionEvaluator
        -MoveGenerator moveGenerator
        -OpponentModeler opponentModeler
        -RiskAssessor riskAssessor
        +analyzePosition(board, player): PositionAnalysis
        +generateMoves(board, player): List<Move>
        +predictOpponentMove(board, opponent): Move
        +assessRisk(move, board): RiskAssessment
        +recommendBestMove(board, player): Move
    }

    class ActionExecutor {
        -RuleValidator ruleValidator
        -StateUpdater stateUpdater
        -HistoryRecorder historyRecorder
        -EventDispatcher eventDispatcher
        +validateMove(move, board, player): ValidationResult
        +executeMove(move, board): ExecutionResult
        +updateGameState(board, move): StateUpdate
        +recordHistory(move, board): HistoryEntry
        +dispatchEvents(events): void
    }

    class AISystem {
        -SearchAlgorithm searchAlgorithm
        -EvaluationFunction evaluationFunction
        -OpeningBook openingBook
        -EndgameDatabase endgameDatabase
        +makeDecision(board, player): Move
        +searchBestMove(board, depth): SearchResult
        +evaluatePosition(board, player): number
        +getOpeningMove(board): Move
        +getEndgameMove(board): Move
    }

    class MatchStatistics {
        -WinRateCalculator winRateCalculator
        -MoveStatistics moveStatistics
        -PatternRecognizer patternRecognizer
        -PerformanceAnalyzer performanceAnalyzer
        +calculateWinRate(player, opponent): number
        +trackMoveStatistics(move, result): void
        +recognizePatterns(board): List<Pattern>
        +analyzePerformance(player): PerformanceReport
        +generateStatisticsReport(): StatisticsReport
    }

    class Player {
        -string id
        -string name
        -number rating
        -number gamesPlayed
        -number gamesWon
        -number winRate
        -PlayStyle preferredStyle
        +makeMove(board): Move
        +evaluatePosition(board): number
        +updateRating(result, opponentRating): number
        +getPlayerStatistics(): PlayerStats
        +isHuman(): boolean
    }

    class HumanPlayer {
        <<ç”¨æˆ·è¾“å…¥>>
        <<æ‰‹åŠ¨æ“ä½œ>>
        <<UIäº¤äº’>>
    }

    class AIPlayer {
        <<ç®—æ³•å†³ç­–>>
        <<è‡ªåŠ¨è®¡ç®—>>
        <<ç­–ç•¥åˆ†æ>>
    }

    CardBoardCombatEngine --> StrategyAnalyzer : ç»„åˆ
    CardBoardCombatEngine --> ActionExecutor : ç»„åˆ
    CardBoardCombatEngine --> AISystem : ç»„åˆ
    CardBoardCombatEngine --> MatchStatistics : ç»„åˆ
    Player <|-- HumanPlayer : ç»§æ‰¿
    Player <|-- AIPlayer : ç»§æ‰¿

    class Board {
        -number width
        -number height
        -Cell[][] cells
        -Player currentPlayer
        -GameState gameState
        -List<Move> moveHistory
        +makeMove(move): MoveResult
        +isValidMove(move): boolean
        +getPossibleMoves(): List<Move>
        +evaluatePosition(): number
        +checkWinCondition(): WinResult
        +getBoardState(): BoardState
    }

    class ChessBoard {
        <<8x8ç½‘æ ¼>>
        <<å¤šç§æ£‹å­>>
        <<è¥¿æ–¹è§„åˆ™>>
    }

    class XiangqiBoard {
        <<9x10ç½‘æ ¼>>
        <<ä¸­å¼æ£‹å­>>
        <<ä¸­å›½è§„åˆ™>>
    }

    class Move {
        -Player player
        -Position fromPosition
        -Position toPosition
        -Piece piece
        -Piece capturedPiece
        -MoveType moveType
        +execute(board): MoveResult
        +undo(board): void
        +isValid(board): boolean
        +getNotation(): string
        +getValue(): number
    }

    Board <|-- ChessBoard : ç»§æ‰¿
    Board <|-- XiangqiBoard : ç»§æ‰¿

    class StandardMove {
        <<æ™®é€šç§»åŠ¨>>
        <<æ ‡å‡†åƒå­>>
        <<åŸºæœ¬è§„åˆ™>>
    }

    class SpecialMove {
        <<ç‰¹æ®Šè§„åˆ™>>
        <<ç‹è½¦æ˜“ä½>>
        <<å…µå‡å˜>>
    }

    Move <|-- StandardMove : ç»§æ‰¿
    Move <|-- SpecialMove : ç»§æ‰¿
```

#### æ£‹ç‰Œç«æŠ€ç³»ç»Ÿæ—¶åºå›¾

```mermaid
sequenceDiagram
    participant CBCE as CardBoardCombatEngine
    participant SA as StrategyAnalyzer
    participant AE as ActionExecutor
    participant AIS as AISystem
    participant MS as MatchStatistics
    participant Player as Player

    Note over CBCE,Player: æ¸¸æˆåˆå§‹åŒ–é˜¶æ®µ
    CBCE->>CBCE: initializeGame(players)
    CBCE->>Player: åˆ›å»ºæ¸¸æˆä¼šè¯å®ä¾‹
    Player->>Player: åˆå§‹åŒ–æ£‹ç›˜çŠ¶æ€
    Player->>Player: è®¾ç½®ç©å®¶ä¿¡æ¯
    Player->>AIS: å‡†å¤‡AIç³»ç»Ÿ

    Note over CBCE,Player: å›åˆå¼€å§‹é˜¶æ®µ
    CBCE->>CBCE: startTurn(currentPlayer)
    CBCE->>CBCE: æ£€æŸ¥æ¸¸æˆçŠ¶æ€
    CBCE->>CBCE: æ›´æ–°æ—¶é—´é™åˆ¶
    CBCE->>Player: æ¿€æ´»ç©å®¶è¾“å…¥
    CBCE->>CBCE: å¯åŠ¨æ€è€ƒè®¡æ—¶å™¨

    Note over CBCE,Player: ç­–ç•¥åˆ†æé˜¶æ®µ
    SA->>SA: analyzePosition(board, player)
    SA->>SA: è¯„ä¼°å½“å‰å±€é¢
    SA->>SA: åˆ†æå…³é”®ä½ç½®
    SA->>SA: è¯†åˆ«å¨èƒå’Œæœºä¼š
    SA->>SA: è®¡ç®—ä½ç½®ä»·å€¼

    Note over CBCE,Player: èµ°æ³•ç”Ÿæˆé˜¶æ®µ
    SA->>SA: generateMoves(board, player)
    SA->>SA: æšä¸¾æ‰€æœ‰åˆæ³•èµ°æ³•
    SA->>SA: è¿‡æ»¤æ— æ•ˆèµ°æ³•
    SA->>SA: è¯„ä¼°èµ°æ³•ä»·å€¼
    SA->>SA: æ’åºæœ€ä¼˜èµ°æ³•

    Note over CBCE,Player: AIå†³ç­–é˜¶æ®µ
    AIS->>AIS: makeDecision(board, player)
    AIS->>AIS: é€‰æ‹©æœç´¢ç®—æ³•
    AIS->>AIS: æ‰§è¡Œæ·±åº¦æœç´¢
    AIS->>AIS: è¯„ä¼°ä½ç½®ä»·å€¼
    AIS->>AIS: è¿”å›æœ€ä¼˜èµ°æ³•

    Note over CBCE,Player: èµ°æ³•éªŒè¯é˜¶æ®µ
    AE->>AE: validateMove(move, board, player)
    AE->>AE: éªŒè¯èµ°æ³•è¯­æ³•
    AE->>AE: æ£€æŸ¥è§„åˆ™åˆè§„
    AE->>AE: ç¡®è®¤ä½ç½®æœ‰æ•ˆ
    AE->>AE: éªŒè¯ç©å®¶æƒé™

    Note over CBCE,Player: èµ°æ³•æ‰§è¡Œé˜¶æ®µ
    AE->>AE: executeMove(move, board)
    AE->>AE: æ‰§è¡Œèµ°æ³•é€»è¾‘
    AE->>AE: æ›´æ–°æ£‹ç›˜çŠ¶æ€
    AE->>AE: å¤„ç†ç‰¹æ®Šè§„åˆ™
    AE->>AE: è§¦å‘çŠ¶æ€äº‹ä»¶

    Note over CBCE,Player: çŠ¶æ€æ›´æ–°é˜¶æ®µ
    AE->>AE: updateGameState(board, move)
    AE->>AE: æ›´æ–°ç©å®¶çŠ¶æ€
    AE->>AE: æ£€æŸ¥è·èƒœæ¡ä»¶
    AE->>AE: æ›´æ–°æ¸¸æˆé˜¶æ®µ
    AE->>AE: å¹¿æ’­çŠ¶æ€å˜åŒ–

    Note over CBCE,Player: ç»Ÿè®¡è®°å½•é˜¶æ®µ
    MS->>MS: trackMoveStatistics(move, result)
    MS->>MS: è®°å½•èµ°æ³•æ•°æ®
    MS->>MS: æ›´æ–°èƒœç‡ç»Ÿè®¡
    MS->>MS: è¯†åˆ«èµ°æ³•æ¨¡å¼
    MS->>MS: åˆ†ææ€§èƒ½æŒ‡æ ‡

    Note over CBCE,Player: ä½ç½®è¯„ä¼°é˜¶æ®µ
    CBCE->>CBCE: evaluatePosition()
    CBCE->>SA: é‡æ–°åˆ†æå±€é¢
    SA->>SA: æ›´æ–°å¨èƒè¯„ä¼°
    SA->>SA: è°ƒæ•´ç­–ç•¥æƒé‡
    SA->>SA: å‡†å¤‡ä¸‹ä¸€å›åˆ

    Note over CBCE,Player: æ¸¸æˆç»“ç®—é˜¶æ®µ
    CBCE->>CBCE: resolveGame()
    CBCE->>CBCE: ç¡®å®šæ¸¸æˆç»“æœ
    CBCE->>CBCE: è®¡ç®—è¯„åˆ†å˜åŒ–
    CBCE->>CBCE: æ›´æ–°ç©å®¶ç»Ÿè®¡
    CBCE->>CBCE: ç”Ÿæˆæ¯”èµ›æŠ¥å‘Š
```

### 1. æ¸¸æˆè§„åˆ™å¼•æ“ (Game Rule Engine)

#### è§„åˆ™é…ç½®ç³»ç»Ÿ
```typescript
interface GameRule {
  id: string;
  name: string;
  type: GameType;
  playerCount: { min: number; max: number };
  deckConfig: DeckConfig;
  scoringRules: ScoringRule[];
  winConditions: WinCondition[];
  specialRules: SpecialRule[];
}

enum GameType {
  CARD_GAME = 'card_game',      // çº¸ç‰Œæ¸¸æˆ
  BOARD_GAME = 'board_game',    // æ£‹ç›˜æ¸¸æˆ
  TILE_GAME = 'tile_game',      // éº»å°†ç­‰ç‰Œç±»æ¸¸æˆ
  DOMINO_GAME = 'domino_game'   // å¤šç±³è¯ºéª¨ç‰Œ
}

interface DeckConfig {
  cardCount: number;
  cardTypes: CardType[];
  shuffleMethod: ShuffleMethod;
  dealMethod: DealMethod;
}

interface ScoringRule {
  condition: string;        // å¾—åˆ†æ¡ä»¶
  points: number;          // åˆ†æ•°å€¼
  multiplier?: number;     // å€ç‡
  isBonus?: boolean;       // æ˜¯å¦ä¸ºå¥–åŠ±åˆ†
}
```

#### è§„åˆ™æ‰§è¡Œå¼•æ“
```typescript
class RuleEngine {
  private rules: GameRule;
  private gameState: GameState;

  constructor(rules: GameRule) {
    this.rules = rules;
    this.gameState = new GameState();
  }

  // éªŒè¯è¡ŒåŠ¨æ˜¯å¦åˆæ³•
  validateAction(action: GameAction, player: Player): ValidationResult {
    // æ£€æŸ¥è¡ŒåŠ¨ç±»å‹
    if (!this.isValidActionType(action.type)) {
      return { valid: false, reason: 'invalid_action_type' };
    }

    // æ£€æŸ¥ç©å®¶çŠ¶æ€
    if (!this.canPlayerAct(player)) {
      return { valid: false, reason: 'player_cannot_act' };
    }

    // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
    if (!this.isValidGameState(action)) {
      return { valid: false, reason: 'invalid_game_state' };
    }

    // æ£€æŸ¥å…·ä½“è§„åˆ™
    return this.validateSpecificRules(action, player);
  }

  // æ‰§è¡Œè¡ŒåŠ¨
  async executeAction(action: GameAction): Promise<ActionResult> {
    // é¢„æ‰§è¡Œæ£€æŸ¥
    const validation = this.validateAction(action, action.player);
    if (!validation.valid) {
      return { success: false, error: validation.reason };
    }

    // æ‰§è¡Œè¡ŒåŠ¨
    const result = await this.performAction(action);

    // æ›´æ–°æ¸¸æˆçŠ¶æ€
    this.updateGameState(result);

    // æ£€æŸ¥è·èƒœæ¡ä»¶
    const winner = this.checkWinConditions();
    if (winner) {
      return { success: true, winner, finalResult: result };
    }

    return { success: true, result };
  }

  // æ£€æŸ¥è·èƒœæ¡ä»¶
  private checkWinConditions(): Player | null {
    for (const condition of this.rules.winConditions) {
      const winner = this.evaluateWinCondition(condition);
      if (winner) return winner;
    }
    return null;
  }
}
```

### 2. å¡ç‰Œ/æ£‹å­ç³»ç»Ÿ (Card/Piece System)

#### å¡ç‰Œæ•°æ®ç»“æ„
```typescript
interface Card {
  id: string;
  suit: CardSuit;          // èŠ±è‰²
  rank: CardRank;          // ç‚¹æ•°
  value: number;           // æ•°å€¼
  name: string;            // åç§°
  effects?: CardEffect[];  // ç‰¹æ®Šæ•ˆæœ
  isWild?: boolean;        // æ˜¯å¦ä¸ºä¸‡èƒ½ç‰Œ
}

enum CardSuit {
  HEARTS = 'hearts',       // çº¢æ¡ƒ
  DIAMONDS = 'diamonds',   // æ–¹å—
  CLUBS = 'clubs',         // æ¢…èŠ±
  SPADES = 'spades',       // é»‘æ¡ƒ
  JOKER = 'joker'          // å¤§å°ç‹
}

enum CardRank {
  ACE = 'A',
  TWO = '2',
  THREE = '3',
  FOUR = '4',
  FIVE = '5',
  SIX = '6',
  SEVEN = '7',
  EIGHT = '8',
  NINE = '9',
  TEN = '10',
  JACK = 'J',
  QUEEN = 'Q',
  KING = 'K'
}

interface CardEffect {
  type: EffectType;
  value: number;
  condition?: string;
  duration?: number;
}
```

#### æ£‹å­ç³»ç»Ÿï¼ˆé€‚ç”¨äºæ£‹ç›˜æ¸¸æˆï¼‰
```typescript
interface ChessPiece {
  id: string;
  type: PieceType;
  color: PieceColor;
  position: Position;
  movePattern: MovePattern[];
  value: number;           // æ£‹å­ä»·å€¼
  abilities: PieceAbility[];
}

enum PieceType {
  KING = 'king',
  QUEEN = 'queen',
  ROOK = 'rook',
  BISHOP = 'bishop',
  KNIGHT = 'knight',
  PAWN = 'pawn'
}

interface MovePattern {
  type: 'straight' | 'diagonal' | 'L_shape' | 'custom';
  range: number;           // ç§»åŠ¨èŒƒå›´
  canJump?: boolean;       // æ˜¯å¦å¯ä»¥è·³è·ƒ
  conditions?: MoveCondition[];
}
```

### 3. ç©å®¶ç³»ç»Ÿ (Player System)

#### ç©å®¶çŠ¶æ€ç®¡ç†
```typescript
interface Player {
  id: string;
  name: string;
  avatar?: string;
  level: number;
  experience: number;

  // æ¸¸æˆç›¸å…³çŠ¶æ€
  hand: Card[];           // æ‰‹ç‰Œ
  position: Position;     // åœ¨æ£‹ç›˜ä¸Šçš„ä½ç½®
  score: number;          // å½“å‰åˆ†æ•°
  chips: number;          // ç­¹ç ï¼ˆæ‰‘å…‹ç­‰ï¼‰
  status: PlayerStatus;   // ç©å®¶çŠ¶æ€

  // ç»Ÿè®¡ä¿¡æ¯
  gamesPlayed: number;
  gamesWon: number;
  winRate: number;
  bestScore: number;
}

enum PlayerStatus {
  WAITING = 'waiting',    // ç­‰å¾…ä¸­
  THINKING = 'thinking',  // æ€è€ƒä¸­
  ACTING = 'acting',      // è¡ŒåŠ¨ä¸­
  FOLDED = 'folded',      // å·²å¼ƒç‰Œ
  ELIMINATED = 'eliminated' // å·²æ·˜æ±°
}
```

#### ç©å®¶è¡ŒåŠ¨ç³»ç»Ÿ
```typescript
interface PlayerAction {
  id: string;
  playerId: string;
  type: ActionType;
  timestamp: number;
  data: ActionData;
}

enum ActionType {
  PLAY_CARD = 'play_card',     // å‡ºç‰Œ
  DRAW_CARD = 'draw_card',     // æŠ½ç‰Œ
  MOVE_PIECE = 'move_piece',   // ç§»åŠ¨æ£‹å­
  PASS = 'pass',              // è¿‡ç‰Œ
  FOLD = 'fold',              // å¼ƒç‰Œ
  BET = 'bet',                // ä¸‹æ³¨
  CALL = 'call',              // è·Ÿæ³¨
  RAISE = 'raise',            // åŠ æ³¨
  CHECK = 'check'             // è®©ç‰Œ
}

interface ActionData {
  cardId?: string;
  position?: Position;
  amount?: number;
  targetPlayerId?: string;
}
```

### 4. AIç³»ç»Ÿ (AI System)

#### å†³ç­–ç®—æ³•æ¡†æ¶
```typescript
abstract class GameAI {
  protected difficulty: AIDifficulty;
  protected personality: AIPersonality;

  constructor(difficulty: AIDifficulty, personality: AIPersonality) {
    this.difficulty = difficulty;
    this.personality = personality;
  }

  // å†³ç­–å…¥å£
  abstract makeDecision(gameState: GameState, player: Player): Promise<PlayerAction>;

  // è¯„ä¼°è¡ŒåŠ¨ä»·å€¼
  protected abstract evaluateAction(action: PlayerAction, gameState: GameState): number;

  // é¢„æµ‹å¯¹æ‰‹è¡ŒåŠ¨
  protected abstract predictOpponentAction(gameState: GameState, opponent: Player): PlayerAction[];
}

enum AIDifficulty {
  EASY = 'easy',          // ç®€å•
  MEDIUM = 'medium',      // ä¸­ç­‰
  HARD = 'hard',          // å›°éš¾
  EXPERT = 'expert'       // ä¸“å®¶
}

interface AIPersonality {
  aggressiveness: number;  // æ”»å‡»æ€§ (0-1)
  riskTolerance: number;   // é£é™©æ‰¿å—åº¦ (0-1)
  bluffFrequency: number;  // è¯ˆå”¬é¢‘ç‡ (0-1)
  patience: number;        // è€å¿ƒåº¦ (0-1)
}
```

#### æ‰‘å…‹AIå®ç°
```typescript
class PokerAI extends GameAI {
  async makeDecision(gameState: PokerGameState, player: Player): Promise<PlayerAction> {
    // è¯„ä¼°æ‰‹ç‰Œå¼ºåº¦
    const handStrength = this.evaluateHandStrength(player.hand, gameState.communityCards);

    // è€ƒè™‘ä½ç½®å› ç´ 
    const positionFactor = this.evaluatePosition(player.position, gameState.playerCount);

    // è®¡ç®—è¡ŒåŠ¨ä»·å€¼
    const actions = this.generatePossibleActions(gameState, player);
    const bestAction = this.selectBestAction(actions, handStrength, positionFactor, gameState);

    // åº”ç”¨AIä¸ªæ€§
    return this.applyPersonality(bestAction, this.personality);
  }

  // è¯„ä¼°æ‰‹ç‰Œå¼ºåº¦
  private evaluateHandStrength(hand: Card[], communityCards: Card[]): number {
    const allCards = [...hand, ...communityCards];
    const pokerHand = this.identifyPokerHand(allCards);

    return this.getHandValue(pokerHand);
  }

  // è¯†åˆ«ç‰Œå‹
  private identifyPokerHand(cards: Card[]): PokerHand {
    // æ’åºå¡ç‰Œ
    const sortedCards = this.sortCardsByRank(cards);

    // æ£€æŸ¥å„ç§ç‰Œå‹
    if (this.isRoyalFlush(sortedCards)) return PokerHand.ROYAL_FLUSH;
    if (this.isStraightFlush(sortedCards)) return PokerHand.STRAIGHT_FLUSH;
    if (this.isFourOfAKind(sortedCards)) return PokerHand.FOUR_OF_A_KIND;
    if (this.isFullHouse(sortedCards)) return PokerHand.FULL_HOUSE;
    if (this.isFlush(sortedCards)) return PokerHand.FLUSH;
    if (this.isStraight(sortedCards)) return PokerHand.STRAIGHT;
    if (this.isThreeOfAKind(sortedCards)) return PokerHand.THREE_OF_A_KIND;
    if (this.isTwoPair(sortedCards)) return PokerHand.TWO_PAIR;
    if (this.isOnePair(sortedCards)) return PokerHand.ONE_PAIR;

    return PokerHand.HIGH_CARD;
  }
}
```

#### æ£‹ç±»AIå®ç°
```typescript
class ChessAI extends GameAI {
  async makeDecision(gameState: ChessGameState, player: Player): Promise<PlayerAction> {
    const maxDepth = this.getSearchDepth(this.difficulty);

    // ä½¿ç”¨Minimaxç®—æ³•æœç´¢æœ€ä½³ç§»åŠ¨
    const bestMove = this.minimax(
      gameState,
      maxDepth,
      true, // maximizing player
      -Infinity,
      Infinity
    );

    return bestMove.action;
  }

  // Minimaxç®—æ³•å®ç°
  private minimax(
    state: ChessGameState,
    depth: number,
    isMaximizing: boolean,
    alpha: number,
    beta: number
  ): { score: number; action: PlayerAction } {
    // ç»ˆæ­¢æ¡ä»¶
    if (depth === 0 || this.isGameOver(state)) {
      return {
        score: this.evaluateBoard(state, isMaximizing),
        action: null
      };
    }

    const possibleMoves = this.generateMoves(state, isMaximizing);

    if (isMaximizing) {
      let maxEval = -Infinity;
      let bestAction: PlayerAction = null;

      for (const move of possibleMoves) {
        const newState = this.makeMove(state, move);
        const evaluation = this.minimax(newState, depth - 1, false, alpha, beta);

        if (evaluation.score > maxEval) {
          maxEval = evaluation.score;
          bestAction = move;
        }

        alpha = Math.max(alpha, evaluation.score);
        if (beta <= alpha) break; // Alpha-betaå‰ªæ
      }

      return { score: maxEval, action: bestAction };
    } else {
      let minEval = Infinity;
      let bestAction: PlayerAction = null;

      for (const move of possibleMoves) {
        const newState = this.makeMove(state, move);
        const evaluation = this.minimax(newState, depth - 1, true, alpha, beta);

        if (evaluation.score < minEval) {
          minEval = evaluation.score;
          bestAction = move;
        }

        beta = Math.min(beta, evaluation.score);
        if (beta <= alpha) break; // Alpha-betaå‰ªæ
      }

      return { score: minEval, action: bestAction };
    }
  }

  // è¯„ä¼°æ£‹ç›˜å±€é¢
  private evaluateBoard(state: ChessGameState, isMaximizing: boolean): number {
    let score = 0;

    // æ£‹å­ä»·å€¼è¯„ä¼°
    for (const piece of state.pieces) {
      const value = this.getPieceValue(piece.type);
      score += piece.color === state.currentPlayer ? value : -value;
    }

    // ä½ç½®è¯„ä¼°
    score += this.evaluatePosition(state);

    // æœºåŠ¨æ€§è¯„ä¼°
    score += this.evaluateMobility(state);

    return isMaximizing ? score : -score;
  }
}
```

### 5. æ¦‚ç‡è®¡ç®—ç³»ç»Ÿ (Probability System)

#### ç‰Œå±€æ¦‚ç‡è®¡ç®—
```typescript
class ProbabilityCalculator {
  // è®¡ç®—è·èƒœæ¦‚ç‡
  static calculateWinProbability(
    playerHand: Card[],
    communityCards: Card[],
    opponentCount: number,
    remainingDeck: Card[]
  ): number {
    const simulations = 10000;
    let wins = 0;

    for (let i = 0; i < simulations; i++) {
      const simulationResult = this.simulateGame(
        playerHand,
        communityCards,
        opponentCount,
        remainingDeck
      );

      if (simulationResult.playerWins) {
        wins++;
      }
    }

    return wins / simulations;
  }

  // æ¨¡æ‹Ÿå•å±€æ¸¸æˆ
  private static simulateGame(
    playerHand: Card[],
    communityCards: Card[],
    opponentCount: number,
    remainingDeck: Card[]
  ): SimulationResult {
    // æ´—ç‰Œ
    const deck = this.shuffle([...remainingDeck]);

    // å‘å‰©ä½™çš„å…¬å…±ç‰Œ
    const remainingCommunityCards = deck.splice(0, 5 - communityCards.length);

    // ç»™å¯¹æ‰‹å‘ç‰Œ
    const opponentHands: Card[][] = [];
    for (let i = 0; i < opponentCount; i++) {
      opponentHands.push([deck.splice(0, 2)[0], deck.splice(0, 2)[1]]);
    }

    // è¯„ä¼°æ‰€æœ‰æ‰‹ç‰Œ
    const playerStrength = this.evaluateHandStrength([...playerHand, ...communityCards, ...remainingCommunityCards]);
    let playerWins = true;

    for (const opponentHand of opponentHands) {
      const opponentStrength = this.evaluateHandStrength([...opponentHand, ...communityCards, ...remainingCommunityCards]);
      if (opponentStrength >= playerStrength) {
        playerWins = false;
        break;
      }
    }

    return { playerWins };
  }

  // è®¡ç®—å¼ƒç‰Œæ¦‚ç‡
  static calculateFoldProbability(
    handStrength: number,
    potOdds: number,
    opponentBehavior: OpponentBehavior,
    position: Position
  ): number {
    // åŸºäºæ‰‹ç‰Œå¼ºåº¦ã€åº•æ± èµ”ç‡ã€å¯¹æ‰‹è¡Œä¸ºå’Œä½ç½®è®¡ç®—å¼ƒç‰Œæ¦‚ç‡
    let foldProbability = 0.5; // åŸºç¡€50%å¼ƒç‰Œç‡

    // æ‰‹ç‰Œå¼ºåº¦å½±å“
    if (handStrength > 0.8) {
      foldProbability -= 0.3; // å¼ºç‰Œå‡å°‘å¼ƒç‰Œç‡
    } else if (handStrength < 0.3) {
      foldProbability += 0.2; // å¼±ç‰Œå¢åŠ å¼ƒç‰Œç‡
    }

    // åº•æ± èµ”ç‡å½±å“
    if (potOdds > 0.5) {
      foldProbability -= 0.1; // å¥½çš„åº•æ± èµ”ç‡å‡å°‘å¼ƒç‰Œç‡
    }

    // å¯¹æ‰‹è¡Œä¸ºå½±å“
    if (opponentBehavior.aggressiveness > 0.7) {
      foldProbability += 0.1; // æ¿€è¿›å¯¹æ‰‹å¢åŠ å¼ƒç‰Œç‡
    }

    // ä½ç½®å½±å“
    if (position === 'button') {
      foldProbability -= 0.05; // åº„å®¶ä½ç½®å‡å°‘å¼ƒç‰Œç‡
    }

    return Math.max(0, Math.min(1, foldProbability));
  }
}
```

### 6. è®¡åˆ†å’Œæ’åç³»ç»Ÿ (Scoring & Ranking System)

#### è®¡åˆ†è§„åˆ™
```typescript
interface ScoringSystem {
  baseScoring: Map<string, number>;     // åŸºç¡€å¾—åˆ†
  multipliers: Map<string, number>;     // å€ç‡
  bonuses: Map<string, number>;         // å¥–åŠ±åˆ†
  penalties: Map<string, number>;       // æƒ©ç½šåˆ†
}

class ScoreCalculator {
  // è®¡ç®—æ¸¸æˆå¾—åˆ†
  static calculateGameScore(
    gameResult: GameResult,
    player: Player,
    scoringRules: ScoringRule[]
  ): number {
    let totalScore = 0;

    for (const rule of scoringRules) {
      if (this.evaluateScoringCondition(rule.condition, gameResult, player)) {
        let score = rule.points;

        // åº”ç”¨å€ç‡
        if (rule.multiplier) {
          score *= rule.multiplier;
        }

        // åº”ç”¨å¥–åŠ±/æƒ©ç½š
        if (rule.isBonus) {
          score = Math.max(0, score); // ç¡®ä¿å¥–åŠ±ä¸ºæ­£
        }

        totalScore += score;
      }
    }

    // åº”ç”¨ç©å®¶ç­‰çº§ä¿®æ­£
    totalScore *= this.getLevelMultiplier(player.level);

    return Math.floor(totalScore);
  }

  // è®¡ç®—ELOè¯„åˆ†å˜åŒ–
  static calculateEloChange(
    playerRating: number,
    opponentRating: number,
    gameResult: GameResult,
    kFactor: number = 32
  ): number {
    const expectedScore = 1 / (1 + Math.pow(10, (opponentRating - playerRating) / 400));
    const actualScore = gameResult.isWin ? 1 : gameResult.isDraw ? 0.5 : 0;

    return Math.round(kFactor * (actualScore - expectedScore));
  }

  // è®¡ç®—æ’ååˆ†æ•°
  static calculateRankingScore(
    playerStats: PlayerStats,
    gameType: GameType
  ): number {
    const baseScore = playerStats.winRate * 1000;
    const experienceBonus = Math.log(playerStats.gamesPlayed + 1) * 100;
    const consistencyBonus = this.calculateConsistencyBonus(playerStats);

    return Math.floor(baseScore + experienceBonus + consistencyBonus);
  }

  // è®¡ç®—ä¸€è‡´æ€§å¥–åŠ±
  private static calculateConsistencyBonus(stats: PlayerStats): number {
    // åŸºäºèƒœç‡æ³¢åŠ¨è®¡ç®—ä¸€è‡´æ€§
    const recentGames = stats.recentResults.slice(-20);
    if (recentGames.length < 10) return 0;

    const winRate = recentGames.filter(r => r).length / recentGames.length;
    const variance = this.calculateVariance(recentGames.map(r => r ? 1 : 0));

    // ä½æ³¢åŠ¨ = é«˜ä¸€è‡´æ€§ = é«˜å¥–åŠ±
    return Math.max(0, (1 - variance) * 200);
  }
}
```

## ğŸ”§ æ ¸å¿ƒç®—æ³•å®ç°

### æ´—ç‰Œç®—æ³• (Shuffle Algorithm)

#### Fisher-Yatesæ´—ç‰Œ
```typescript
class DeckShuffler {
  // Fisher-Yatesæ´—ç‰Œç®—æ³•
  static shuffle<T>(deck: T[]): T[] {
    const shuffled = [...deck];

    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }

    return shuffled;
  }

  // å¤šé‡æ´—ç‰Œï¼ˆå¢åŠ éšæœºæ€§ï¼‰
  static multiShuffle<T>(deck: T[], shuffleCount: number = 3): T[] {
    let shuffled = [...deck];

    for (let i = 0; i < shuffleCount; i++) {
      shuffled = this.shuffle(shuffled);
    }

    return shuffled;
  }

  // åˆ‡å‰²æ´—ç‰Œï¼ˆæ¨¡æ‹ŸçœŸå®æ´—ç‰Œï¼‰
  static cutShuffle<T>(deck: T[]): T[] {
    const cutPoint = Math.floor(Math.random() * (deck.length - 20)) + 10;
    return [...deck.slice(cutPoint), ...deck.slice(0, cutPoint)];
  }

  // éªŒè¯æ´—ç‰Œå‡åŒ€æ€§
  static validateShuffle<T>(originalDeck: T[], shuffledDeck: T[]): boolean {
    if (originalDeck.length !== shuffledDeck.length) return false;

    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½å­˜åœ¨
    const originalSet = new Set(originalDeck);
    const shuffledSet = new Set(shuffledDeck);

    if (originalSet.size !== shuffledSet.size) return false;

    for (const item of originalSet) {
      if (!shuffledSet.has(item)) return false;
    }

    return true;
  }
}
```

### å‘ç‰Œç®—æ³• (Deal Algorithm)

#### æ ‡å‡†å‘ç‰Œ
```typescript
class CardDealer {
  // æ ‡å‡†å‘ç‰Œç®—æ³•
  static dealCards(
    deck: Card[],
    players: Player[],
    cardsPerPlayer: number,
    communityCards?: number
  ): DealResult {
    const shuffledDeck = DeckShuffler.shuffle(deck);
    let cardIndex = 0;

    // å‘æ‰‹ç‰Œ
    const playerHands: Map<string, Card[]> = new Map();

    for (const player of players) {
      const hand: Card[] = [];
      for (let i = 0; i < cardsPerPlayer; i++) {
        hand.push(shuffledDeck[cardIndex++]);
      }
      playerHands.set(player.id, hand);
    }

    // å‘å…¬å…±ç‰Œï¼ˆå¦‚é€‚ç”¨ï¼‰
    let communityCardsResult: Card[] = [];
    if (communityCards) {
      communityCardsResult = shuffledDeck.slice(cardIndex, cardIndex + communityCards);
      cardIndex += communityCards;
    }

    // å‰©ä½™ç‰Œåº“
    const remainingDeck = shuffledDeck.slice(cardIndex);

    return {
      playerHands,
      communityCards: communityCardsResult,
      remainingDeck,
      burnCards: [] // çƒ§ç‰Œï¼ˆæŸäº›æ¸¸æˆéœ€è¦ï¼‰
    };
  }

  // å¾·å·æ‰‘å…‹å‘ç‰Œ
  static dealTexasHoldem(deck: Card[], players: Player[]): TexasHoldemDeal {
    const deal = this.dealCards(deck, players, 2, 5);

    return {
      playerHands: deal.playerHands,
      flop: deal.communityCards.slice(0, 3),    // ç¿»ç‰Œ
      turn: deal.communityCards[3],             // è½¬ç‰Œ
      river: deal.communityCards[4],            // æ²³ç‰Œ
      remainingDeck: deal.remainingDeck
    };
  }

  // éº»å°†å‘ç‰Œ
  static dealMahjong(tiles: MahjongTile[], players: Player[]): MahjongDeal {
    const shuffledTiles = DeckShuffler.shuffle(tiles);
    const playerHands: Map<string, MahjongTile[]> = new Map();

    // æ¯äºº13å¼ ç‰Œ
    let tileIndex = 0;
    for (const player of players) {
      const hand = shuffledTiles.slice(tileIndex, tileIndex + 13);
      playerHands.set(player.id, hand);
      tileIndex += 13;
    }

    return {
      playerHands,
      remainingTiles: shuffledTiles.slice(tileIndex),
      deadTiles: [] // æ­»ç‰Œ
    };
  }
}
```

### ç‰Œå‹è¯†åˆ«ç®—æ³• (Hand Evaluation Algorithm)

#### æ‰‘å…‹ç‰Œå‹è¯†åˆ«
```typescript
class PokerHandEvaluator {
  // è¯„ä¼°ç‰Œå‹
  static evaluateHand(cards: Card[]): PokerHandResult {
    const sortedCards = this.sortCardsByRank(cards);
    const suits = this.groupBySuit(cards);
    const ranks = this.groupByRank(cards);

    // æ£€æŸ¥çš‡å®¶åŒèŠ±é¡º
    if (this.isRoyalFlush(sortedCards, suits)) {
      return { hand: PokerHand.ROYAL_FLUSH, value: 10, cards: this.getRoyalFlushCards(sortedCards) };
    }

    // æ£€æŸ¥åŒèŠ±é¡º
    if (this.isStraightFlush(sortedCards, suits)) {
      return { hand: PokerHand.STRAIGHT_FLUSH, value: 9, cards: this.getStraightFlushCards(sortedCards) };
    }

    // æ£€æŸ¥å››æ¡
    if (this.isFourOfAKind(ranks)) {
      return { hand: PokerHand.FOUR_OF_A_KIND, value: 8, cards: this.getFourOfAKindCards(ranks) };
    }

    // æ£€æŸ¥æ»¡å ‚çº¢
    if (this.isFullHouse(ranks)) {
      return { hand: PokerHand.FULL_HOUSE, value: 7, cards: this.getFullHouseCards(ranks) };
    }

    // æ£€æŸ¥åŒèŠ±
    if (this.isFlush(suits)) {
      return { hand: PokerHand.FLUSH, value: 6, cards: this.getFlushCards(suits) };
    }

    // æ£€æŸ¥é¡ºå­
    if (this.isStraight(sortedCards)) {
      return { hand: PokerHand.STRAIGHT, value: 5, cards: this.getStraightCards(sortedCards) };
    }

    // æ£€æŸ¥ä¸‰æ¡
    if (this.isThreeOfAKind(ranks)) {
      return { hand: PokerHand.THREE_OF_A_KIND, value: 4, cards: this.getThreeOfAKindCards(ranks) };
    }

    // æ£€æŸ¥ä¸¤å¯¹
    if (this.isTwoPair(ranks)) {
      return { hand: PokerHand.TWO_PAIR, value: 3, cards: this.getTwoPairCards(ranks) };
    }

    // æ£€æŸ¥ä¸€å¯¹
    if (this.isOnePair(ranks)) {
      return { hand: PokerHand.ONE_PAIR, value: 2, cards: this.getOnePairCards(ranks) };
    }

    // é«˜ç‰Œ
    return { hand: PokerHand.HIGH_CARD, value: 1, cards: this.getHighCardCards(sortedCards) };
  }

  // æ£€æŸ¥çš‡å®¶åŒèŠ±é¡º
  private static isRoyalFlush(sortedCards: Card[], suits: Map<CardSuit, Card[]>): boolean {
    if (suits.size !== 1) return false; // å¿…é¡»åŒèŠ±

    const suitCards = Array.from(suits.values())[0];
    const royalRanks = ['10', 'J', 'Q', 'K', 'A'];

    return royalRanks.every(rank =>
      suitCards.some(card => card.rank === rank)
    );
  }

  // æ£€æŸ¥åŒèŠ±é¡º
  private static isStraightFlush(sortedCards: Card[], suits: Map<CardSuit, Card[]>): boolean {
    return suits.size === 1 && this.isStraight(sortedCards);
  }

  // æ£€æŸ¥é¡ºå­
  private static isStraight(sortedCards: Card[]): boolean {
    if (sortedCards.length < 5) return false;

    for (let i = 0; i <= sortedCards.length - 5; i++) {
      const hand = sortedCards.slice(i, i + 5);
      if (this.isConsecutive(hand)) {
        return true;
      }
    }

    return false;
  }

  // æ£€æŸ¥æ˜¯å¦è¿ç»­
  private static isConsecutive(cards: Card[]): boolean {
    for (let i = 1; i < cards.length; i++) {
      const currentValue = this.getRankValue(cards[i].rank);
      const previousValue = this.getRankValue(cards[i - 1].rank);

      if (currentValue !== previousValue + 1) {
        return false;
      }
    }
    return true;
  }

  // è·å–ç‰Œé¢å€¼
  private static getRankValue(rank: CardRank): number {
    const values: Record<CardRank, number> = {
      '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
      'J': 11, 'Q': 12, 'K': 13, 'A': 14
    };
    return values[rank] || 0;
  }
}
```

## ğŸ“Š æ¸¸æˆæµç¨‹è®¾è®¡

### å›åˆåˆ¶æ¸¸æˆæµç¨‹
1. **æ¸¸æˆåˆå§‹åŒ–**ï¼šåˆ›å»ºæ¸¸æˆæˆ¿é—´ï¼Œç­‰å¾…ç©å®¶åŠ å…¥
2. **å‘ç‰Œé˜¶æ®µ**ï¼šæ´—ç‰Œï¼Œå‘ç»™ç©å®¶æ‰‹ç‰Œ
3. **è¡ŒåŠ¨é˜¶æ®µ**ï¼šç©å®¶è½®æµè¿›è¡Œè¡ŒåŠ¨
4. **ç»“ç®—é˜¶æ®µ**ï¼šè®¡ç®—è¡ŒåŠ¨ç»“æœï¼Œæ›´æ–°æ¸¸æˆçŠ¶æ€
5. **æ£€æŸ¥ç»“æŸ**ï¼šåˆ¤æ–­æ˜¯å¦æ»¡è¶³ç»“æŸæ¡ä»¶
6. **åˆ†æ•°ç»“ç®—**ï¼šè®¡ç®—æœ€ç»ˆå¾—åˆ†ï¼Œæ›´æ–°æ’å

### å®æ—¶æ¸¸æˆæµç¨‹
1. **æˆ¿é—´åŒ¹é…**ï¼šæ ¹æ®ç­‰çº§å’Œåå¥½åŒ¹é…ç©å®¶
2. **æ¸¸æˆå‡†å¤‡**ï¼šåŠ è½½æ¸¸æˆèµ„æºï¼ŒåŒæ­¥æ¸¸æˆè§„åˆ™
3. **å®æ—¶äº¤äº’**ï¼šç©å®¶å®æ—¶è¡ŒåŠ¨ï¼Œç³»ç»Ÿå³æ—¶å“åº”
4. **çŠ¶æ€åŒæ­¥**ï¼šä¿æŒæ‰€æœ‰ç©å®¶æ¸¸æˆçŠ¶æ€ä¸€è‡´
5. **å¼‚å¸¸å¤„ç†**ï¼šå¤„ç†ç½‘ç»œå»¶è¿Ÿã€æ‰çº¿ç­‰æƒ…å†µ
6. **ç»“æœç»“ç®—**ï¼šè®¡ç®—æœ€ç»ˆç»“æœï¼Œå¥–åŠ±å‘æ”¾

### é”¦æ ‡èµ›ç³»ç»Ÿ
```typescript
interface Tournament {
  id: string;
  name: string;
  type: TournamentType;
  entryFee: number;
  prizePool: number;
  maxPlayers: number;
  currentPlayers: number;
  status: TournamentStatus;
  bracket: TournamentBracket;
}

enum TournamentType {
  SINGLE_ELIMINATION = 'single_elimination',  // å•æ·˜æ±°èµ›
  DOUBLE_ELIMINATION = 'double_elimination', // åŒæ·˜æ±°èµ›
  ROUND_ROBIN = 'round_robin',              // å¾ªç¯èµ›
  SWISS_SYSTEM = 'swiss_system'              // ç‘å£«åˆ¶
}

class TournamentManager {
  // ç”Ÿæˆæ¯”èµ›å¯¹é˜µ
  static generateBracket(players: Player[], tournamentType: TournamentType): TournamentBracket {
    switch (tournamentType) {
      case TournamentType.SINGLE_ELIMINATION:
        return this.generateSingleEliminationBracket(players);
      case TournamentType.DOUBLE_ELIMINATION:
        return this.generateDoubleEliminationBracket(players);
      case TournamentType.ROUND_ROBIN:
        return this.generateRoundRobinBracket(players);
      case TournamentType.SWISS_SYSTEM:
        return this.generateSwissBracket(players);
      default:
        throw new Error('Unsupported tournament type');
    }
  }

  // æ›´æ–°é”¦æ ‡èµ›è¿›åº¦
  static updateTournamentProgress(tournament: Tournament, gameResult: GameResult): Tournament {
    const updatedTournament = { ...tournament };

    // æ›´æ–°ç©å®¶çŠ¶æ€
    this.updatePlayerStatus(updatedTournament, gameResult);

    // æ£€æŸ¥æ˜¯å¦å®Œæˆ
    if (this.isTournamentComplete(updatedTournament)) {
      updatedTournament.status = TournamentStatus.COMPLETED;
      this.distributePrizes(updatedTournament);
    }

    return updatedTournament;
  }
}
```

## ğŸ® ç©å®¶ä½“éªŒè®¾è®¡

### ç•Œé¢è®¾è®¡
- **æ¸…æ™°çš„ç‰Œé¢æ˜¾ç¤º**ï¼šå¤§å°ºå¯¸ã€æ˜“è¯»çš„å¡ç‰Œ
- **ç›´è§‚çš„è¡ŒåŠ¨æç¤º**ï¼šé«˜äº®å¯è¡ŒåŠ¨åŒºåŸŸ
- **å®æ—¶åé¦ˆ**ï¼šè¡ŒåŠ¨ç»“æœå³æ—¶æ˜¾ç¤º
- **å†å²è®°å½•**ï¼šå¯æŸ¥çœ‹æ¸¸æˆå†å²

### éŸ³æ•ˆå’ŒåŠ¨ç”»
- **å¡ç‰ŒéŸ³æ•ˆ**ï¼šå‡ºç‰Œã€æŠ½ç‰Œçš„éŸ³æ•ˆ
- **èƒœåˆ©éŸ³æ•ˆ**ï¼šä¸åŒçš„èƒœåˆ©åº†ç¥éŸ³æ•ˆ
- **èƒŒæ™¯éŸ³ä¹**ï¼šæ ¹æ®æ¸¸æˆé˜¶æ®µå˜åŒ–
- **åŠ¨ç”»æ•ˆæœ**ï¼šæµç•…çš„å¡ç‰Œç§»åŠ¨åŠ¨ç”»

### ç¤¾äº¤åŠŸèƒ½
- **å¥½å‹ç³»ç»Ÿ**ï¼šæ·»åŠ å¥½å‹ï¼Œä¸€èµ·æ¸¸æˆ
- **èŠå¤©ç³»ç»Ÿ**ï¼šæ¸¸æˆå†…æ–‡å­—å’Œè¯­éŸ³èŠå¤©
- **è§‚æˆ˜åŠŸèƒ½**ï¼šè§‚çœ‹å…¶ä»–ç©å®¶æ¸¸æˆ
- **æˆå°±ç³»ç»Ÿ**ï¼šæ¸¸æˆæˆå°±å’Œå¾½ç« 

## ğŸ”„ ç³»ç»Ÿä¼˜åŒ–ç­–ç•¥

### æ€§èƒ½ä¼˜åŒ–
- **å¯¹è±¡æ± **ï¼šå¤ç”¨å¡ç‰Œå’Œæ¸¸æˆå¯¹è±¡
- **çŠ¶æ€å‹ç¼©**ï¼šä¼˜åŒ–æ¸¸æˆçŠ¶æ€å­˜å‚¨
- **å¼‚æ­¥è®¡ç®—**ï¼šAIå†³ç­–å¼‚æ­¥å¤„ç†
- **ç¼“å­˜æœºåˆ¶**ï¼šç¼“å­˜å¸¸ç”¨è®¡ç®—ç»“æœ

### ç½‘ç»œåŒæ­¥
- **çŠ¶æ€åŒæ­¥**ï¼šå®šæœŸåŒæ­¥å®Œæ•´æ¸¸æˆçŠ¶æ€
- **å¢é‡æ›´æ–°**ï¼šåªåŒæ­¥çŠ¶æ€å˜åŒ–
- **é¢„æµ‹æ‰§è¡Œ**ï¼šå®¢æˆ·ç«¯é¢„æµ‹ï¼ŒæœåŠ¡å™¨éªŒè¯
- **é‡è¿æœºåˆ¶**ï¼šæ–­çº¿é‡è¿å’ŒçŠ¶æ€æ¢å¤

## ğŸ“ˆ æ‰©å±•æ€§è®¾è®¡

### è‡ªå®šä¹‰æ¸¸æˆ
- **è§„åˆ™ç¼–è¾‘å™¨**ï¼šåˆ›å»ºè‡ªå®šä¹‰æ¸¸æˆè§„åˆ™
- **ç‰Œç»„å®šåˆ¶**ï¼šè®¾è®¡è‡ªå®šä¹‰å¡ç‰Œå’Œæ£‹å­
- **åœ°å›¾ç¼–è¾‘å™¨**ï¼šåˆ›å»ºè‡ªå®šä¹‰æ£‹ç›˜å¸ƒå±€
- **AIå®šåˆ¶**ï¼šè°ƒæ•´AIè¡Œä¸ºå’Œéš¾åº¦

### æ•°æ®åˆ†æ
- **ç©å®¶è¡Œä¸ºåˆ†æ**ï¼šåˆ†æç©å®¶æ¸¸æˆæ¨¡å¼
- **å¹³è¡¡æ€§è°ƒæ•´**ï¼šåŸºäºæ•°æ®è°ƒæ•´æ¸¸æˆå¹³è¡¡
- **ä¸ªæ€§åŒ–æ¨è**ï¼šæ¨èé€‚åˆçš„æ¸¸æˆç±»å‹
- **åä½œå¼Šç³»ç»Ÿ**ï¼šæ£€æµ‹å’Œé˜²æ­¢ä½œå¼Šè¡Œä¸º

## ğŸ¯ æ ¸å¿ƒæˆåŠŸè¦ç´ 

1. **å…¬å¹³æ€§**ï¼šå…¬æ­£çš„æ´—ç‰Œå’Œå‘ç‰Œç®—æ³•
2. **ç­–ç•¥æ€§**ï¼šä¸°å¯Œçš„æˆ˜æœ¯é€‰æ‹©å’Œå†³ç­–ç©ºé—´
3. **ç¤¾äº¤æ€§**ï¼šå¤šäººäº’åŠ¨å’Œç«æŠ€ä½“éªŒ
4. **æµç•…æ€§**ï¼šä¼˜ç§€çš„ç”¨æˆ·ç•Œé¢å’Œæ“ä½œä½“éªŒ
5. **æ‰©å±•æ€§**ï¼šå¼ºå¤§çš„è‡ªå®šä¹‰å’ŒModæ”¯æŒ

---

*æ£‹ç‰Œç±»æ¸¸æˆçš„æ ¸å¿ƒé­…åŠ›åœ¨äºè§„åˆ™çš„ç²¾å¦™å’Œç­–ç•¥çš„æ·±åº¦ï¼Œé€šè¿‡ç²¾å¿ƒè®¾è®¡çš„ç®—æ³•å’Œå¹³è¡¡æœºåˆ¶ï¼Œå¯ä»¥åˆ›é€ å‡ºå†ä¹…å¼¥æ–°çš„ç»å…¸æ¸¸æˆä½“éªŒã€‚*
