# æ¶ˆé™¤ç±»æ¸¸æˆæ¶æ„è®¾è®¡

## ğŸ¯ æ¸¸æˆæ¦‚è¿°

æ¶ˆé™¤ç±»æ¸¸æˆï¼ˆMatch-3 Gameï¼‰æ˜¯ä¸€ç§é€šè¿‡äº¤æ¢ç›¸é‚»å…ƒç´ å½¢æˆä¸‰è¿æ¶ˆé™¤çš„ç›Šæ™ºæ¸¸æˆã€‚ä»£è¡¨ä½œå“åŒ…æ‹¬ã€ŠCandy Crushã€‹ã€ã€Šå®çŸ³è¿·é˜µã€‹ç­‰ã€‚æ ¸å¿ƒç©æ³•å›´ç»•åŒ¹é…æ¶ˆé™¤ã€è¿é”ååº”ã€ç‰¹æ®Šå…ƒç´ ç»„åˆå±•å¼€ã€‚

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„æ¨¡å—

### 0. æ ¸å¿ƒæˆ˜æ–—æ¨¡å— (Combat System)

#### æ¶ˆé™¤æˆ˜æ–—æ¨¡å¼æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ¶ˆé™¤ç±»æˆ˜æ–—ç³»ç»Ÿæ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  æ¶ˆé™¤è§¦å‘    â”‚ -> â”‚  æ•ˆæœæ¿€æ´»    â”‚ -> â”‚  è¿é”ååº”    â”‚     â”‚
â”‚  â”‚             â”‚    â”‚             â”‚    â”‚             â”‚     â”‚
â”‚  â”‚ â€¢ åŒ¹é…æ£€æµ‹   â”‚    â”‚ â€¢ ç‰¹æ®Šå…ƒç´    â”‚    â”‚ â€¢ è¿é”æ¶ˆé™¤   â”‚     â”‚
â”‚  â”‚ â€¢ åŸºç¡€æ¶ˆé™¤   â”‚    â”‚ â€¢ æŠ€èƒ½é‡Šæ”¾   â”‚    â”‚ â€¢ å€ç‡ç´¯ç§¯   â”‚     â”‚
â”‚  â”‚ â€¢ åˆ†æ•°è®¡ç®—   â”‚    â”‚ â€¢ BUFFåº”ç”¨   â”‚    â”‚ â€¢ å¥–åŠ±å¢å¼º   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²                        â–²                        â”‚
         â”‚                        â”‚                        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     æˆ˜æ–—ç»“ç®—ç³»ç»Ÿ      â”‚
                    â”‚                     â”‚
                    â”‚ â€¢ æœ€ç»ˆåˆ†æ•°è®¡ç®—      â”‚
                    â”‚ â€¢ è¿å‡»å¥–åŠ±          â”‚
                    â”‚ â€¢ æˆå°±è§£é”          â”‚
                    â”‚ â€¢ ç­‰çº§æå‡          â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ¶ˆé™¤æˆ˜æ–—ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶

```mermaid
mindmap
  root((æ¶ˆé™¤æˆ˜æ–—å¼•æ“))
    æ¶ˆé™¤è§¦å‘å™¨
      åŒ¹é…æ£€æµ‹å™¨
      æ¶ˆé™¤æ‰§è¡Œå™¨
      åˆ†æ•°è®¡ç®—å™¨
      ç‰¹æ•ˆç”Ÿæˆå™¨
    ç‰¹æ®Šå…ƒç´ ç³»ç»Ÿ
      ç‚¸å¼¹å…ƒç´ 
        èŒƒå›´çˆ†ç‚¸
        é“¾å¼ååº”
        ä¼¤å®³å€ç‡
      ç›´çº¿å…ƒç´ 
        æ°´å¹³æ¶ˆé™¤
        å‚ç›´æ¶ˆé™¤
        åå­—æ¶ˆé™¤
      åŒè‰²å…ƒç´ 
        å…¨è‰²æ¸…é™¤
        é¢œè‰²è½¬æ¢
        é¢œè‰²è¿é”
      æ··åˆå…ƒç´ 
    è¿å‡»ç³»ç»Ÿ
      è¿å‡»è®¡æ•°å™¨
      å€ç‡è®¡ç®—å™¨
      æ—¶é—´çª—å£ç®¡ç†å™¨
      è¿å‡»å¥–åŠ±åˆ†å‘å™¨
    æˆ˜æ–—çŠ¶æ€ç®¡ç†å™¨
      æˆ˜æ–—é˜¶æ®µæ§åˆ¶å™¨
      æ¶ˆé™¤è¿›åº¦è·Ÿè¸ªå™¨
      ç›®æ ‡è¾¾æˆæ£€æŸ¥å™¨
      å¤±è´¥æ¡ä»¶ç›‘è§†å™¨
    æˆ˜æ–—AIç³»ç»Ÿ
      æœ€ä½³ç§»åŠ¨å»ºè®®å™¨
      ç‰¹æ®Šå…ƒç´ è§„åˆ’å™¨
      è¿å‡»æœºä¼šè¯†åˆ«å™¨
      ç­–ç•¥ä¼˜åŒ–å™¨
```

#### æ¶ˆé™¤æˆ˜æ–—çŠ¶æ€æœºæ¶æ„å›¾

```mermaid
stateDiagram-v2
    [*] --> InitializationState
    InitializationState --> PlayerActionState
    PlayerActionState --> EliminationState
    EliminationState --> ChainReactionState
    ChainReactionState --> GravityState
    GravityState --> RefillState
    RefillState --> ResolutionState
    ResolutionState --> EndState
    EndState --> [*]

    note right of PlayerActionState : æ£€æŸ¥æ˜¯å¦æœ‰æ–°åŒ¹é…
    note right of EliminationState : å¯èƒ½è§¦å‘è¿é”ååº”
    note right of ChainReactionState : å¯èƒ½å›åˆ°æ¶ˆé™¤çŠ¶æ€

    state "åˆå§‹åŒ–çŠ¶æ€" as I
    state "ç½‘æ ¼ç”Ÿæˆ" as GG
    state "å…³å¡è®¾ç½®" as LS
    state "ç›®æ ‡åˆå§‹åŒ–" as OI
    state "UIå‡†å¤‡" as UP

    I --> GG
    I --> LS
    I --> OI
    I --> UP

    state "ç©å®¶æ“ä½œçŠ¶æ€" as PA
    state "å…ƒç´ é€‰æ‹©" as ES
    state "ç§»åŠ¨éªŒè¯" as MV
    state "é¢„è§ˆæ˜¾ç¤º" as PD
    state "ç§»åŠ¨æ‰§è¡Œ" as ME

    PA --> ES
    PA --> MV
    PA --> PD
    PA --> ME

    state "æ¶ˆé™¤å¤„ç†çŠ¶æ€" as E
    state "åŒ¹é…æ£€æµ‹" as MD
    state "æ¶ˆé™¤åŠ¨ç”»" as EA
    state "åˆ†æ•°è®¡ç®—" as SC
    state "ç‰¹æ•ˆæ’­æ”¾" as EP

    E --> MD
    E --> EA
    E --> SC
    E --> EP

    state "è¿é”ååº”çŠ¶æ€" as CR
    state "æ–°åŒ¹é…æ£€æµ‹" as NMD
    state "è¿é”è®¡æ•°" as CC
    state "å€ç‡ç´¯ç§¯" as MA
    state "å¥–åŠ±å¢å¼º" as RE

    CR --> NMD
    CR --> CC
    CR --> MA
    CR --> RE

    state "é‡åŠ›ä¸‹è½çŠ¶æ€" as G
    state "ç©ºéš™æ£€æµ‹" as GD
    state "ä¸‹è½è®¡ç®—" as FC
    state "ç¢°æ’æ£€æµ‹" as CD
    state "åŠ¨ç”»åŒæ­¥" as AS

    G --> GD
    G --> FC
    G --> CD
    G --> AS

    state "æ–°å…ƒç´ å¡«å……çŠ¶æ€" as R
    state "ç©ºä½è¯†åˆ«" as ESI
    state "å…ƒç´ ç”Ÿæˆ" as EG
    state "æ‰è½åŠ¨ç”»" as DA
    state "ä½ç½®è°ƒæ•´" as PA2

    R --> ESI
    R --> EG
    R --> DA
    R --> PA2

    state "ç»“ç®—çŠ¶æ€" as RS
    state "ç›®æ ‡æ£€æŸ¥" as OC
    state "åˆ†æ•°ç»“ç®—" as SS
    state "å¥–åŠ±åˆ†å‘" as RD
    state "ç»Ÿè®¡æ›´æ–°" as SU

    RS --> OC
    RS --> SS
    RS --> RD
    RS --> SU

    state "ç»“æŸçŠ¶æ€" as ES
    state "èƒœåˆ©å¤„ç†" as VH
    state "å¤±è´¥å¤„ç†" as DF
    state "æ•°æ®ä¿å­˜" as DP
    state "ä¸‹ä¸€å…³å‡†å¤‡" as NLP

    ES --> VH
    ES --> DF
    ES --> DP
    ES --> NLP
```

#### æ¶ˆé™¤æˆ˜æ–—æµç¨‹æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant P as ç©å®¶
    participant GS as æ¸¸æˆç³»ç»Ÿ
    participant MS as åŒ¹é…ç³»ç»Ÿ
    participant SS as ç‰¹æ®Šå…ƒç´ ç³»ç»Ÿ
    participant GSYS as é‡åŠ›ç³»ç»Ÿ
    participant RS as å¥–åŠ±ç³»ç»Ÿ

    Note over P,RS: ç©å®¶æ“ä½œé˜¶æ®µ
    P->>GS: å…ƒç´ äº¤æ¢æ“ä½œ
    GS->>GS: å…ƒç´ äº¤æ¢éªŒè¯
    GS->>GS: æ£€æŸ¥æœ‰æ•ˆåŒ¹é…
    GS->>GS: éªŒè¯ç§»åŠ¨åˆæ³•æ€§
    GS->>GS: è®¡ç®—é¢„ä¼°åˆ†æ•°

    Note over P,RS: æ¶ˆé™¤æ‰§è¡Œé˜¶æ®µ
    GS->>MS: è§¦å‘æ¶ˆé™¤æ£€æµ‹
    MS->>MS: æ£€æµ‹æ‰€æœ‰åŒ¹é…ç»„åˆ
    MS->>MS: æ‰§è¡Œæ¶ˆé™¤åŠ¨ç”»
    MS->>MS: è®¡ç®—åŸºç¡€åˆ†æ•°
    MS->>SS: æ¿€æ´»ç‰¹æ®Šå…ƒç´ æ•ˆæœ

    Note over P,RS: è¿é”ååº”é˜¶æ®µ
    SS->>SS: å¤„ç†ç‰¹æ®Šå…ƒç´ 
    SS->>MS: æ£€æµ‹æ–°åŒ¹é…
    MS->>MS: ç´¯ç§¯è¿å‡»å€ç‡
    MS->>MS: å¢å¼ºå¥–åŠ±æ•ˆæœ
    MS->>MS: æ›´æ–°è¿å‡»è®¡æ•°

    Note over P,RS: é‡åŠ›å¡«å……é˜¶æ®µ
    GS->>GSYS: æ‰§è¡Œé‡åŠ›ä¸‹è½
    GSYS->>GSYS: å…ƒç´ ä½ç½®æ›´æ–°
    GSYS->>GSYS: ç”Ÿæˆæ–°å…ƒç´ 
    GSYS->>GSYS: æ£€æµ‹æ–°åŒ¹é…
    GSYS->>GS: é‡å¤è¿é”æµç¨‹

    Note over P,RS: æˆ˜æ–—ç»“ç®—é˜¶æ®µ
    GS->>RS: è®¡ç®—æœ€ç»ˆåˆ†æ•°
    RS->>RS: æ£€æŸ¥å…³å¡ç›®æ ‡
    RS->>RS: åˆ†å‘å¥–åŠ±
    RS->>RS: æ›´æ–°ç©å®¶çŠ¶æ€

    Note over P,RS: å‡†å¤‡ä¸‹ä¸€å›åˆ
    GS->>GS: é‡ç½®å›åˆçŠ¶æ€
    GS->>P: é€šçŸ¥ä¸‹ä¸€å›åˆ
```

#### ç‰¹æ®Šå…ƒç´ æˆ˜æ–—æ•ˆæœå›¾

```mermaid
flowchart TD
    subgraph "ç‚¸å¼¹å…ƒç´ æˆ˜æ–—æ•ˆæœ"
        B1[3x3èŒƒå›´æ¶ˆé™¤<br/>åŸºç¡€å€ç‡2x<br/>è¿é”+1<br/>ç‰¹æ•ˆçˆ†ç‚¸]
        B2[5x5èŒƒå›´æ¶ˆé™¤<br/>åŸºç¡€å€ç‡3x<br/>è¿é”+2<br/>ç‰¹æ•ˆçˆ†ç‚¸]
        B3[åå­—èŒƒå›´æ¶ˆé™¤<br/>åŸºç¡€å€ç‡2.5x<br/>è¿é”+1.5<br/>ç‰¹æ•ˆçˆ†ç‚¸]
    end

    subgraph "ç›´çº¿å…ƒç´ æˆ˜æ–—æ•ˆæœ"
        L1[æ°´å¹³ç›´çº¿æ¶ˆé™¤<br/>å€ç‡1.5x<br/>å…¨è¡Œæ¸…é™¤<br/>ç²’å­ç‰¹æ•ˆ]
        L2[å‚ç›´ç›´çº¿æ¶ˆé™¤<br/>å€ç‡1.5x<br/>å…¨åˆ—æ¸…é™¤<br/>ç²’å­ç‰¹æ•ˆ]
        L3[Lå½¢ç›´çº¿æ¶ˆé™¤<br/>å€ç‡2x<br/>Lå½¢åŒºåŸŸæ¸…é™¤<br/>ç²’å­ç‰¹æ•ˆ]
    end

    subgraph "åŒè‰²å…ƒç´ æˆ˜æ–—æ•ˆæœ"
        C1[å•è‰²å…¨æ¸…<br/>å€ç‡3x<br/>è¿é”+3<br/>å½©è™¹ç‰¹æ•ˆ]
        C2[åŒè‰²å…¨æ¸…<br/>å€ç‡5x<br/>è¿é”+5<br/>å½©è™¹ç‰¹æ•ˆ]
        C3[ä¸‰è‰²å…¨æ¸…<br/>å€ç‡8x<br/>è¿é”+8<br/>å½©è™¹ç‰¹æ•ˆ]
    end

    SE[ç‰¹æ®Šå…ƒç´ æ¿€æ´»] --> B1
    SE --> L1
    SE --> C1

    style B1 fill:#ffcccc
    style B2 fill:#ffaaaa
    style B3 fill:#ff8888
    style L1 fill:#ccffcc
    style L2 fill:#aaffaa
    style L3 fill:#88ff88
    style C1 fill:#ccccff
    style C2 fill:#aaaaff
    style C3 fill:#8888ff
```

#### æˆ˜æ–—å¹³è¡¡æ€§å‚æ•°
```typescript
interface Match3CombatConfig {
  // åŸºç¡€åˆ†æ•°å‚æ•°
  baseScorePerGem: number;         // æ¯ä¸ªå®çŸ³åŸºç¡€åˆ†æ•°
  matchLengthMultiplier: number;   // åŒ¹é…é•¿åº¦å€ç‡
  specialGemMultiplier: number;    // ç‰¹æ®Šå®çŸ³å€ç‡

  // è¿å‡»ç³»ç»Ÿå‚æ•°
  comboTimeWindow: number;         // è¿å‡»æ—¶é—´çª—å£ (ç§’)
  maxComboMultiplier: number;      // æœ€å¤§è¿å‡»å€ç‡
  comboDecayRate: number;          // è¿å‡»è¡°å‡ç‡

  // è¿é”ååº”å‚æ•°
  chainReactionMultiplier: number; // è¿é”ååº”å€ç‡
  maxChainLength: number;          // æœ€å¤§è¿é”é•¿åº¦
  chainBonusThreshold: number;     // è¿é”å¥–åŠ±é˜ˆå€¼

  // ç‰¹æ®Šå…ƒç´ å‚æ•°
  bombExplosionRadius: number;     // ç‚¸å¼¹çˆ†ç‚¸åŠå¾„
  lineClearWidth: number;          // ç›´çº¿æ¸…é™¤å®½åº¦
  colorClearMultiplier: number;    // åŒè‰²æ¸…é™¤å€ç‡

  // AIå‚æ•°
  aiMoveDelay: number;             // AIç§»åŠ¨å»¶è¿Ÿ
  aiDifficultyLevel: number;       // AIéš¾åº¦ç­‰çº§
  aiHintAccuracy: number;          // AIæç¤ºå‡†ç¡®åº¦
}
```

#### æ¶ˆé™¤ç±»æˆ˜æ–—ç³»ç»Ÿç±»å›¾

```mermaid
classDiagram
    class Match3CombatEngine {
        -GameGrid gameGrid
        -EliminationSystem eliminationSystem
        -SpecialElementSystem specialElementSystem
        -ComboSystem comboSystem
        -ScoreSystem scoreSystem
        +initializeGame(levelData): GameSession
        +processMove(fromPos, toPos): MoveResult
        +executeElimination(matches): EliminationResult
        +processChainReaction(): ChainResult
        +calculateScore(): number
    }

    class EliminationSystem {
        -MatchDetector matchDetector
        -GravitySystem gravitySystem
        -FillSystem fillSystem
        -Queue<Elimination> eliminationQueue
        +findMatches(grid): List<Match>
        +executeElimination(match): EliminationResult
        +applyGravity(grid): GravityResult
        +fillEmptySpaces(grid): FillResult
        +processCascade(): CascadeResult
    }

    class SpecialElementSystem {
        -Map<string, BombElement> bombElements
        -Map<string, LineElement> lineElements
        -Map<string, ColorElement> colorElements
        -Map<ElementType, Processor> effectProcessors
        +createSpecialElement(match): SpecialElement
        +activateElement(element, position): EffectResult
        +processBombEffect(position, radius): BombResult
        +processLineEffect(position, direction): LineResult
        +processColorEffect(color): ColorResult
    }

    class ComboSystem {
        -number currentCombo
        -number comboMultiplier
        -Timer comboTimer
        -number maxComboMultiplier
        +registerElimination(count): ComboResult
        +calculateComboBonus(): number
        +resetCombo(): void
        +isComboActive(): boolean
        +getComboLevel(): ComboLevel
    }

    class ScoreSystem {
        -Map<GemType, number> baseScores
        -Map<BonusType, number> multipliers
        -List<ScoreEntry> scoreHistory
        +calculateBaseScore(gem, matchLength): number
        +applyMultiplier(score, multiplier): number
        +calculateTotalScore(): number
        +getScoreBreakdown(): ScoreBreakdown
        +updateHighScore(score): boolean
    }

    class Gem {
        -string id
        -GemType type
        -Position position
        -number baseScore
        -boolean isSpecial
        -List<GemEffect> effects
        +getScore(): number
        +canMatchWith(other: Gem): boolean
        +activateEffect(): EffectResult
        +destroy(): void
        +clone(): Gem
    }

    class NormalGem {
        <<åŸºç¡€åŒ¹é…>>
        <<æ ‡å‡†åˆ†æ•°>>
        <<æ™®é€šæ¶ˆé™¤>>
    }

    class SpecialGem {
        <<ç‰¹æ®Šæ•ˆæœ>>
        <<å¢å¼ºåˆ†æ•°>>
        <<è¿é”ååº”>>
    }

    class Match {
        -string id
        -List<Position> positions
        -GemType gemType
        -number length
        -MatchDirection direction
        +getScore(): number
        +getSpecialElement(): SpecialElement | null
        +canCreateCombo(): boolean
        +execute(): EliminationResult
    }

    class HorizontalMatch {
        <<è¡Œæ¶ˆé™¤>>
        <<æ°´å¹³ç‰¹æ•ˆ>>
        <<å·¦åˆ°å³>>
    }

    class VerticalMatch {
        <<åˆ—æ¶ˆé™¤>>
        <<å‚ç›´ç‰¹æ•ˆ>>
        <<ä¸Šåˆ°ä¸‹>>
    }

    Match3CombatEngine --> EliminationSystem : ç»„åˆ
    Match3CombatEngine --> SpecialElementSystem : ç»„åˆ
    Match3CombatEngine --> ComboSystem : ç»„åˆ
    Match3CombatEngine --> ScoreSystem : ç»„åˆ
    Gem <|-- NormalGem : ç»§æ‰¿
    Gem <|-- SpecialGem : ç»§æ‰¿
    Match <|-- HorizontalMatch : ç»§æ‰¿
    Match <|-- VerticalMatch : ç»§æ‰¿
```

#### æ¶ˆé™¤ç±»æˆ˜æ–—ç³»ç»Ÿæ—¶åºå›¾

```mermaid
sequenceDiagram
    participant M3CE as Match3CombatEngine
    participant ES as EliminationSystem
    participant SES as SpecialElementSystem
    participant CS as ComboSystem
    participant SS as ScoreSystem
    participant Gem as Gem

    Note over M3CE,Gem: ç©å®¶ç§»åŠ¨é˜¶æ®µ
    M3CE->>M3CE: processMove(fromPos, toPos)
    M3CE->>ES: éªŒè¯ç§»åŠ¨åˆæ³•æ€§
    ES->>ES: æ‰§è¡Œå®çŸ³äº¤æ¢
    ES->>ES: æ£€æŸ¥æ˜¯å¦äº§ç”ŸåŒ¹é…

    Note over M3CE,Gem: åŒ¹é…æ£€æµ‹é˜¶æ®µ
    ES->>ES: findMatches(grid)
    ES->>ES: æ‰«ææ°´å¹³åŒ¹é…
    ES->>ES: æ‰«æå‚ç›´åŒ¹é…
    ES->>ES: åˆå¹¶é‡å åŒ¹é…
    ES->>M3CE: è¿”å›åŒ¹é…åˆ—è¡¨

    Note over M3CE,Gem: æ¶ˆé™¤æ‰§è¡Œé˜¶æ®µ
    M3CE->>M3CE: executeElimination(matches)
    M3CE->>ES: executeElimination(match)
    ES->>ES: ç§»é™¤åŒ¹é…çš„å®çŸ³
    ES->>SES: ç”Ÿæˆç‰¹æ®Šå…ƒç´ 
    SES->>SES: createSpecialElement(match)
    ES->>ES: æ’­æ”¾æ¶ˆé™¤åŠ¨ç”»
    ES->>SS: æ›´æ–°åˆ†æ•°

    Note over M3CE,Gem: é‡åŠ›ä¸‹è½é˜¶æ®µ
    ES->>ES: applyGravity(grid)
    ES->>ES: æ£€æµ‹ç©ºéš™ä½ç½®
    ES->>ES: è®¡ç®—ä¸‹è½è·ç¦»
    ES->>ES: æ‰§è¡Œå®çŸ³ä¸‹è½
    ES->>ES: æ›´æ–°ç½‘æ ¼çŠ¶æ€

    Note over M3CE,Gem: å¡«å……ç©ºä½é˜¶æ®µ
    ES->>ES: fillEmptySpaces(grid)
    ES->>ES: è¯†åˆ«ç©ºä½
    ES->>ES: ç”Ÿæˆæ–°å®çŸ³
    ES->>ES: æ‰§è¡Œå¡«å……åŠ¨ç”»
    ES->>ES: æ£€æŸ¥æ–°åŒ¹é…

    Note over M3CE,Gem: è¿å‡»å¤„ç†é˜¶æ®µ
    CS->>CS: registerElimination(count)
    CS->>CS: æ›´æ–°è¿å‡»è®¡æ•°
    CS->>CS: è®¡ç®—è¿å‡»å€ç‡
    CS->>CS: é‡ç½®è¿å‡»è®¡æ—¶å™¨
    CS->>CS: è§¦å‘è¿å‡»ç‰¹æ•ˆ

    Note over M3CE,Gem: åˆ†æ•°è®¡ç®—é˜¶æ®µ
    SS->>SS: calculateBaseScore(gem, matchLength)
    SS->>SS: è®¡ç®—åŸºç¡€åˆ†æ•°
    SS->>SS: åº”ç”¨é•¿åº¦åŠ æˆ
    SS->>SS: è€ƒè™‘å®çŸ³ç±»å‹
    SS->>M3CE: è¿”å›æœ€ç»ˆåˆ†æ•°

    Note over M3CE,Gem: è¿é”ååº”é˜¶æ®µ
    M3CE->>M3CE: processChainReaction()
    M3CE->>ES: æ£€æµ‹æ–°äº§ç”Ÿçš„åŒ¹é…
    ES->>ES: æ‰§è¡Œè¿é”æ¶ˆé™¤
    ES->>CS: ç´¯ç§¯è¿é”å€ç‡
    CS->>CS: æ›´æ–°è¿å‡»çŠ¶æ€

    Note over M3CE,Gem: ç‰¹æ®Šå…ƒç´ æ¿€æ´»é˜¶æ®µ
    SES->>SES: activateElement(element, position)
    SES->>SES: éªŒè¯æ¿€æ´»æ¡ä»¶
    SES->>SES: æ‰§è¡Œç‰¹æ®Šæ•ˆæœ
    SES->>ES: æ›´æ–°ç½‘æ ¼çŠ¶æ€
    SES->>M3CE: è§¦å‘è¿é”ååº”

    Note over M3CE,Gem: æœ€ç»ˆåˆ†æ•°ç»“ç®—é˜¶æ®µ
    M3CE->>SS: calculateScore()
    SS->>SS: è®¡ç®—åŸºç¡€åˆ†æ•°
    SS->>CS: åº”ç”¨è¿å‡»å€ç‡
    SS->>SES: æ·»åŠ ç‰¹æ®Šå…ƒç´ å¥–åŠ±
    SS->>M3CE: è¿”å›æœ€ç»ˆåˆ†æ•°
```

### 1. æ¸¸æˆç½‘æ ¼ç³»ç»Ÿ (Grid System)

#### ç½‘æ ¼æ•°æ®ç»“æ„
```typescript
interface GameGrid {
  rows: number;           // è¡Œæ•°
  cols: number;           // åˆ—æ•°
  cells: GridCell[][];    // ç½‘æ ¼æ•°æ®
}

interface GridCell {
  gem: Gem | null;        // å®çŸ³å¯¹è±¡
  position: Position;     // ä½ç½®åæ ‡
  isEmpty: boolean;       // æ˜¯å¦ä¸ºç©º
  isLocked: boolean;      // æ˜¯å¦é”å®šï¼ˆä¸å¯ç§»åŠ¨ï¼‰
}

interface Position {
  row: number;
  col: number;
}
```

#### å®çŸ³ç±»å‹ç³»ç»Ÿ
```typescript
enum GemType {
  RED = 'red',           // çº¢è‰²
  BLUE = 'blue',         // è“è‰²
  GREEN = 'green',       // ç»¿è‰²
  YELLOW = 'yellow',     // é»„è‰²
  PURPLE = 'purple',     // ç´«è‰²
  ORANGE = 'orange',     // æ©™è‰²

  // ç‰¹æ®Šå®çŸ³
  SPECIAL_BOMB = 'bomb',       // ç‚¸å¼¹ï¼ˆçˆ†ç‚¸æ¶ˆé™¤ï¼‰
  SPECIAL_LINE_H = 'line_h',   // æ°´å¹³ç›´çº¿æ¶ˆé™¤
  SPECIAL_LINE_V = 'line_v',   // å‚ç›´ç›´çº¿æ¶ˆé™¤
  SPECIAL_COLOR = 'color',     // åŒè‰²æ¶ˆé™¤

  // ç‰¹æ®ŠçŠ¶æ€
  BLOCKER = 'blocker',         // éšœç¢ç‰©
  EMPTY = 'empty'             // ç©ºä½ç½®
}
```

#### ç½‘æ ¼æ“ä½œ
- **åˆå§‹åŒ–ç½‘æ ¼**ï¼šéšæœºç”Ÿæˆæˆ–åŠ è½½é¢„è®¾å¸ƒå±€
- **äº¤æ¢å…ƒç´ **ï¼šç›¸é‚»å…ƒç´ çš„ä½ç½®äº¤æ¢
- **ç§»é™¤å…ƒç´ **ï¼šæ¶ˆé™¤åŒ¹é…çš„å…ƒç´ 
- **å¡«å……ç©ºéš™**ï¼šé‡åŠ›ä¸‹è½å’Œæ–°å…ƒç´ ç”Ÿæˆ

### 2. åŒ¹é…æ£€æµ‹ç³»ç»Ÿ (Match Detection System)

#### åŸºç¡€åŒ¹é…ç®—æ³•
```typescript
interface MatchResult {
  positions: Position[];      // åŒ¹é…ä½ç½®é›†åˆ
  type: GemType;             // åŒ¹é…çš„å®çŸ³ç±»å‹
  length: number;            // åŒ¹é…é•¿åº¦
  direction: 'horizontal' | 'vertical'; // åŒ¹é…æ–¹å‘
}

class MatchDetector {
  // æ£€æµ‹æ°´å¹³åŒ¹é…
  static findHorizontalMatches(grid: GameGrid): MatchResult[] {
    const matches: MatchResult[] = [];

    for (let row = 0; row < grid.rows; row++) {
      let currentType = GemType.EMPTY;
      let count = 0;
      let startCol = 0;

      for (let col = 0; col <= grid.cols; col++) {
        const cell = col < grid.cols ? grid.cells[row][col] : null;
        const gemType = cell?.gem?.type || GemType.EMPTY;

        if (gemType === currentType && gemType !== GemType.EMPTY) {
          count++;
        } else {
          if (count >= 3 && currentType !== GemType.EMPTY) {
            matches.push({
              positions: this.getMatchPositions(row, startCol, count, 'horizontal'),
              type: currentType,
              length: count,
              direction: 'horizontal'
            });
          }
          currentType = gemType;
          count = 1;
          startCol = col;
        }
      }
    }

    return matches;
  }

  // æ£€æµ‹å‚ç›´åŒ¹é…
  static findVerticalMatches(grid: GameGrid): MatchResult[] {
    // ç±»ä¼¼æ°´å¹³åŒ¹é…çš„å®ç°
    return [];
  }

  // è·å–åŒ¹é…ä½ç½®
  private static getMatchPositions(
    row: number,
    startCol: number,
    length: number,
    direction: 'horizontal' | 'vertical'
  ): Position[] {
    const positions: Position[] = [];

    for (let i = 0; i < length; i++) {
      positions.push({
        row: direction === 'horizontal' ? row : row + i,
        col: direction === 'horizontal' ? startCol + i : startCol
      });
    }

    return positions;
  }
}
```

#### ç‰¹æ®ŠåŒ¹é…æ£€æµ‹
- **Lå½¢åŒ¹é…**ï¼šä¸¤ä¸ªæ–¹å‘åŒæ—¶åŒ¹é…
- **Tå½¢åŒ¹é…**ï¼šä¸‰ä¸ªæ–¹å‘çš„äº¤å‰åŒ¹é…
- **ç‰¹æ®Šå…ƒç´ ç”Ÿæˆ**ï¼šæ ¹æ®åŒ¹é…ç±»å‹ç”Ÿæˆå¯¹åº”çš„ç‰¹æ®Šå…ƒç´ 

### 3. æ¶ˆé™¤ç³»ç»Ÿ (Elimination System)

#### æ¶ˆé™¤æ‰§è¡Œ
```typescript
class EliminationEngine {
  // æ‰§è¡Œæ¶ˆé™¤
  static async eliminateMatches(
    grid: GameGrid,
    matches: MatchResult[]
  ): Promise<EliminationResult> {
    const eliminatedGems: EliminatedGem[] = [];
    const specialEffects: SpecialEffect[] = [];

    for (const match of matches) {
      // å¤„ç†æ™®é€šæ¶ˆé™¤
      for (const position of match.positions) {
        const cell = grid.cells[position.row][position.col];
        if (cell.gem) {
          eliminatedGems.push({
            position,
            gem: cell.gem,
            score: this.calculateGemScore(cell.gem, match.length)
          });
          cell.gem = null;
          cell.isEmpty = true;
        }
      }

      // ç”Ÿæˆç‰¹æ®Šå…ƒç´ 
      const specialGem = this.generateSpecialGem(match);
      if (specialGem) {
        specialEffects.push({
          type: 'create_special',
          position: this.findSpecialGemPosition(match),
          gemType: specialGem
        });
      }
    }

    return { eliminatedGems, specialEffects };
  }

  // è®¡ç®—å®çŸ³åˆ†æ•°
  private static calculateGemScore(gem: Gem, matchLength: number): number {
    const baseScore = gem.baseScore || 10;
    const lengthBonus = (matchLength - 3) * 5; // è¶…è¿‡3ä¸ªçš„é¢å¤–åˆ†æ•°
    return baseScore + lengthBonus;
  }

  // ç”Ÿæˆç‰¹æ®Šå…ƒç´ 
  private static generateSpecialGem(match: MatchResult): GemType | null {
    if (match.length >= 5) return GemType.SPECIAL_COLOR;
    if (match.length === 4) {
      return match.direction === 'horizontal'
        ? GemType.SPECIAL_LINE_H
        : GemType.SPECIAL_LINE_V;
    }
    if (match.length === 3) {
      // æ£€æŸ¥æ˜¯å¦ä¸ºLå½¢æˆ–Tå½¢åŒ¹é…
      return this.checkSpecialShape(match) ? GemType.SPECIAL_BOMB : null;
    }
    return null;
  }
}
```

#### æ¶ˆé™¤åŠ¨ç”»
- **æ¶ˆå¤±åŠ¨ç”»**ï¼šå®çŸ³æ¶ˆå¤±çš„ç‰¹æ•ˆ
- **ç²’å­æ•ˆæœ**ï¼šæ¶ˆé™¤æ—¶çš„ç²’å­å–·å‘
- **éŸ³æ•ˆé…åˆ**ï¼šæ¶ˆé™¤éŸ³æ•ˆå’ŒèƒŒæ™¯éŸ³ä¹

### 4. é‡åŠ›ä¸å¡«å……ç³»ç»Ÿ (Gravity & Fill System)

#### é‡åŠ›ä¸‹è½
```typescript
class GravitySystem {
  // åº”ç”¨é‡åŠ›
  static applyGravity(grid: GameGrid): MoveAnimation[] {
    const animations: MoveAnimation[] = [];

    for (let col = 0; col < grid.cols; col++) {
      let emptyRow = grid.rows - 1;

      // ä»åº•éƒ¨å‘ä¸Šæ£€æŸ¥
      for (let row = grid.rows - 1; row >= 0; row--) {
        const cell = grid.cells[row][col];

        if (cell.isEmpty) {
          // æ‰¾åˆ°ä¸Šé¢çš„éç©ºå…ƒç´ 
          let sourceRow = row - 1;
          while (sourceRow >= 0 && grid.cells[sourceRow][col].isEmpty) {
            sourceRow--;
          }

          if (sourceRow >= 0) {
            const sourceCell = grid.cells[sourceRow][col];

            // åˆ›å»ºç§»åŠ¨åŠ¨ç”»
            animations.push({
              fromPosition: { row: sourceRow, col },
              toPosition: { row, col },
              gem: sourceCell.gem!,
              duration: this.calculateFallDuration(sourceRow, row)
            });

            // æ‰§è¡Œç§»åŠ¨
            grid.cells[row][col].gem = sourceCell.gem;
            grid.cells[row][col].isEmpty = false;
            grid.cells[sourceRow][col].gem = null;
            grid.cells[sourceRow][col].isEmpty = true;
          }
        }
      }
    }

    return animations;
  }

  // è®¡ç®—ä¸‹è½æ—¶é—´
  private static calculateFallDuration(fromRow: number, toRow: number): number {
    const distance = fromRow - toRow;
    return Math.sqrt(distance) * 0.1; // è·ç¦»è¶Šè¿œï¼Œä¸‹è½æ—¶é—´è¶Šé•¿
  }
}
```

#### æ–°å…ƒç´ ç”Ÿæˆ
```typescript
class FillSystem {
  // ç”Ÿæˆæ–°å…ƒç´ 
  static generateNewGems(grid: GameGrid, count: number): SpawnAnimation[] {
    const animations: SpawnAnimation[] = [];
    const gemTypes = this.getAvailableGemTypes();
    let generated = 0;

    // ä¼˜å…ˆå¡«å……åº•éƒ¨ç©ºä½
    for (let col = 0; col < grid.cols && generated < count; col++) {
      for (let row = grid.rows - 1; row >= 0 && generated < count; row--) {
        const cell = grid.cells[row][col];

        if (cell.isEmpty) {
          const gemType = this.selectGemType(gemTypes);
          const newGem = this.createGem(gemType);

          cell.gem = newGem;
          cell.isEmpty = false;

          animations.push({
            position: { row, col },
            gem: newGem,
            spawnType: 'fall_in', // ä»ä¸Šæ–¹è½ä¸‹
            delay: generated * 0.05 // äº¤é”™ç”Ÿæˆ
          });

          generated++;
        }
      }
    }

    return animations;
  }

  // é€‰æ‹©å®çŸ³ç±»å‹ï¼ˆé¿å…ç«‹å³åŒ¹é…ï¼‰
  private static selectGemType(availableTypes: GemType[]): GemType {
    let selectedType: GemType;
    let attempts = 0;
    const maxAttempts = 10;

    do {
      selectedType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
      attempts++;
    } while (this.wouldCreateMatch(selectedType) && attempts < maxAttempts);

    return selectedType;
  }
}
```

### 5. ç‰¹æ®Šå…ƒç´ ç³»ç»Ÿ (Special Elements System)

#### ç‰¹æ®Šå…ƒç´ ç±»å‹
```typescript
interface SpecialElement {
  type: GemType;
  effects: SpecialEffect[];
  priority: number;        // æ¿€æ´»ä¼˜å…ˆçº§
}

class SpecialElementSystem {
  // å¤„ç†ç‰¹æ®Šå…ƒç´ æ¿€æ´»
  static async activateSpecialElement(
    grid: GameGrid,
    position: Position,
    triggerType: 'match' | 'tap' | 'chain'
  ): Promise<SpecialEffectResult> {
    const cell = grid.cells[position.row][position.col];
    if (!cell.gem) return { effects: [] };

    const specialElement = this.getSpecialElement(cell.gem.type);
    if (!specialElement) return { effects: [] };

    const effects = await this.executeSpecialEffects(grid, specialElement, position);
    return { effects, score: this.calculateSpecialScore(specialElement) };
  }

  // æ‰§è¡Œç‰¹æ®Šæ•ˆæœ
  private static async executeSpecialEffects(
    grid: GameGrid,
    element: SpecialElement,
    center: Position
  ): Promise<SpecialEffect[]> {
    const effects: SpecialEffect[] = [];

    for (const effect of element.effects) {
      switch (effect.type) {
        case 'explode':
          effects.push(...await this.createExplosion(grid, center, effect.radius));
          break;
        case 'line_clear':
          effects.push(...this.createLineClear(grid, center, effect.direction));
          break;
        case 'color_clear':
          effects.push(...this.createColorClear(grid, center, effect.targetColor));
          break;
      }
    }

    return effects;
  }
}
```

#### ç‰¹æ®Šå…ƒç´ ç»„åˆ
- **ç‚¸å¼¹+ç‚¸å¼¹**ï¼šå¤§èŒƒå›´çˆ†ç‚¸
- **ç›´çº¿+ç›´çº¿**ï¼šåå­—æ¶ˆé™¤
- **ç‚¸å¼¹+ç›´çº¿**ï¼šTå½¢çˆ†ç‚¸
- **åŒè‰²+æ™®é€š**ï¼šå¢å¼ºåŒè‰²æ¶ˆé™¤

### 6. è¿å‡»ç³»ç»Ÿ (Combo System)

#### è¿å‡»æ£€æµ‹
```typescript
interface ComboSystem {
  currentCombo: number;         // å½“å‰è¿å‡»æ•°
  maxCombo: number;            // æœ€å¤§è¿å‡»æ•°
  comboMultiplier: number;     // è¿å‡»å€ç‡
  comboTimer: number;          // è¿å‡»è®¡æ—¶å™¨
  comboWindow: number;         // è¿å‡»æ—¶é—´çª—å£
}

class ComboManager {
  // å¤„ç†è¿å‡»
  static processCombo(eliminationCount: number, timeSinceLastElimination: number): ComboResult {
    let comboCount = 1;
    let multiplier = 1;

    if (timeSinceLastElimination < this.comboWindow) {
      comboCount = Math.min(this.maxCombo, this.currentCombo + 1);
      multiplier = this.calculateMultiplier(comboCount);
    } else {
      comboCount = 1;
      multiplier = 1;
    }

    return {
      comboCount,
      multiplier,
      bonusScore: eliminationCount * multiplier * 10,
      isNewRecord: comboCount > this.maxCombo
    };
  }

  // è®¡ç®—è¿å‡»å€ç‡
  private static calculateMultiplier(comboCount: number): number {
    if (comboCount <= 1) return 1;
    return 1 + (comboCount - 1) * 0.25; // æ¯è¿å‡»1æ¬¡å¢åŠ 25%
  }
}
```

#### è¿é”ååº”
- **è‡ªåŠ¨è¿é”**ï¼šæ¶ˆé™¤åç«‹å³æ£€æµ‹æ–°åŒ¹é…
- **è¿é”è®¡æ•°**ï¼šç»Ÿè®¡è¿é”ååº”æ¬¡æ•°
- **è¿é”å¥–åŠ±**ï¼šæ ¹æ®è¿é”æ¬¡æ•°ç»™äºˆé¢å¤–åˆ†æ•°

### 7. AIæç¤ºç³»ç»Ÿ (Hint System)

#### ç§»åŠ¨å»ºè®®
```typescript
interface HintSystem {
  availableMoves: PossibleMove[];
  bestMove: PossibleMove | null;
  hintLevel: 'basic' | 'advanced' | 'expert';
}

interface PossibleMove {
  fromPosition: Position;
  toPosition: Position;
  score: number;           // ç§»åŠ¨è¯„åˆ†
  matchCount: number;      // æ¶ˆé™¤æ•°é‡
  specialGems: number;     // ç”Ÿæˆç‰¹æ®Šå…ƒç´ æ•°
  comboPotential: number;  // è¿å‡»æ½œåŠ›
}

class HintEngine {
  // å¯»æ‰¾å¯èƒ½çš„ç§»åŠ¨
  static findPossibleMoves(grid: GameGrid): PossibleMove[] {
    const moves: PossibleMove[] = [];

    for (let row = 0; row < grid.rows; row++) {
      for (let col = 0; col < grid.cols; col++) {
        // æ£€æŸ¥ä¸å³ä¾§äº¤æ¢
        if (col < grid.cols - 1) {
          const move = this.evaluateMove(grid, {row, col}, {row, col: col + 1});
          if (move) moves.push(move);
        }

        // æ£€æŸ¥ä¸ä¸‹æ–¹äº¤æ¢
        if (row < grid.rows - 1) {
          const move = this.evaluateMove(grid, {row, col}, {row: row + 1, col});
          if (move) moves.push(move);
        }
      }
    }

    return moves.sort((a, b) => b.score - a.score);
  }

  // è¯„ä¼°ç§»åŠ¨ä»·å€¼
  private static evaluateMove(
    grid: GameGrid,
    from: Position,
    to: Position
  ): PossibleMove | null {
    // åˆ›å»ºä¸´æ—¶ç½‘æ ¼å‰¯æœ¬
    const tempGrid = this.cloneGrid(grid);

    // æ‰§è¡Œäº¤æ¢
    this.swapCells(tempGrid, from, to);

    // æ£€æµ‹åŒ¹é…
    const matches = MatchDetector.findAllMatches(tempGrid);
    if (matches.length === 0) return null;

    // è®¡ç®—åˆ†æ•°
    const score = this.calculateMoveScore(matches);

    return {
      fromPosition: from,
      toPosition: to,
      score,
      matchCount: matches.length,
      specialGems: this.countSpecialGems(matches),
      comboPotential: this.evaluateComboPotential(tempGrid, matches)
    };
  }
}
```

## ğŸ”§ æ ¸å¿ƒç®—æ³•å®ç°

### åŒ¹é…æ£€æµ‹ç®—æ³• (Match Detection Algorithm)

#### é«˜æ•ˆåŒ¹é…æ‰«æ
```typescript
function findAllMatches(grid: GameGrid): MatchResult[] {
  const matches: MatchResult[] = [];
  const visited = new Set<string>();

  // æ°´å¹³æ‰«æ
  for (let row = 0; row < grid.rows; row++) {
    for (let col = 0; col < grid.cols - 2; col++) {
      const match = findHorizontalMatch(grid, row, col);
      if (match && !isVisited(match, visited)) {
        matches.push(match);
        markVisited(match, visited);
      }
    }
  }

  // å‚ç›´æ‰«æ
  for (let col = 0; col < grid.cols; col++) {
    for (let row = 0; row < grid.rows - 2; row++) {
      const match = findVerticalMatch(grid, row, col);
      if (match && !isVisited(match, visited)) {
        matches.push(match);
        markVisited(match, visited);
      }
    }
  }

  return matches;
}

function findHorizontalMatch(grid: GameGrid, startRow: number, startCol: number): MatchResult | null {
  const gemType = grid.cells[startRow][startCol].gem?.type;
  if (!gemType || gemType === GemType.EMPTY) return null;

  let length = 1;
  const positions: Position[] = [{ row: startRow, col: startCol }];

  // å‘å³æ‰©å±•
  for (let col = startCol + 1; col < grid.cols; col++) {
    const cell = grid.cells[startRow][col];
    if (cell.gem?.type === gemType) {
      length++;
      positions.push({ row: startRow, col });
    } else {
      break;
    }
  }

  return length >= 3 ? {
    positions,
    type: gemType,
    length,
    direction: 'horizontal'
  } : null;
}
```

### æ¶ˆé™¤ä¼˜åŒ–ç®—æ³• (Elimination Optimization Algorithm)

#### æ¶ˆé™¤åºåˆ—ä¼˜åŒ–
```typescript
function optimizeEliminationSequence(matches: MatchResult[]): MatchResult[] {
  // æŒ‰ä¼˜å…ˆçº§æ’åºï¼šç‰¹æ®Šå…ƒç´ ä¼˜å…ˆï¼Œé•¿åŒ¹é…ä¼˜å…ˆ
  return matches.sort((a, b) => {
    // ç‰¹æ®Šå…ƒç´ ä¼˜å…ˆçº§
    const aSpecial = isSpecialGem(a.type);
    const bSpecial = isSpecialGem(b.type);

    if (aSpecial !== bSpecial) {
      return aSpecial ? -1 : 1;
    }

    // é•¿åº¦ä¼˜å…ˆ
    if (a.length !== b.length) {
      return b.length - a.length;
    }

    // ä½ç½®ä¼˜å…ˆï¼ˆå·¦ä¸Šä¼˜å…ˆï¼‰
    const aPos = a.positions[0];
    const bPos = b.positions[0];

    if (aPos.row !== bPos.row) {
      return aPos.row - bPos.row;
    }

    return aPos.col - bPos.col;
  });
}
```

## ğŸ“Š æ¸¸æˆæµç¨‹è®¾è®¡

### æ ¸å¿ƒæ¸¸æˆå¾ªç¯
1. **åˆå§‹åŒ–ç½‘æ ¼**ï¼šéšæœºç”Ÿæˆæˆ–åŠ è½½å…³å¡
2. **ç©å®¶æ“ä½œ**ï¼šé€‰æ‹©è¦äº¤æ¢çš„å…ƒç´ 
3. **éªŒè¯ç§»åŠ¨**ï¼šæ£€æŸ¥æ˜¯å¦äº§ç”Ÿæœ‰æ•ˆåŒ¹é…
4. **æ‰§è¡Œæ¶ˆé™¤**ï¼šç§»é™¤åŒ¹é…å…ƒç´ ï¼Œè®¡ç®—åˆ†æ•°
5. **é‡åŠ›ä¸‹è½**ï¼šå…ƒç´ ä¸‹è½å¡«å……ç©ºéš™
6. **ç”Ÿæˆæ–°å…ƒç´ **ï¼šè¡¥å……é¡¶éƒ¨æ–°å…ƒç´ 
7. **è¿é”æ£€æµ‹**ï¼šæ£€æŸ¥æ˜¯å¦äº§ç”Ÿæ–°çš„åŒ¹é…
8. **çŠ¶æ€æ£€æŸ¥**ï¼šåˆ¤æ–­æ¸¸æˆæ˜¯å¦ç»“æŸ

### å…³å¡ç›®æ ‡ç³»ç»Ÿ
```typescript
interface LevelObjective {
  type: 'score' | 'time' | 'moves' | 'collect';
  target: number;
  current: number;
  description: string;
}

class ObjectiveManager {
  // æ£€æŸ¥ç›®æ ‡å®Œæˆ
  static checkObjectives(objectives: LevelObjective[]): ObjectiveResult {
    const completed: LevelObjective[] = [];
    const failed: LevelObjective[] = [];
    let allCompleted = true;

    for (const objective of objectives) {
      const isCompleted = this.evaluateObjective(objective);

      if (isCompleted) {
        completed.push(objective);
      } else if (this.isObjectiveFailed(objective)) {
        failed.push(objective);
        allCompleted = false;
      } else {
        allCompleted = false;
      }
    }

    return { completed, failed, allCompleted };
  }

  private static evaluateObjective(objective: LevelObjective): boolean {
    switch (objective.type) {
      case 'score':
        return objective.current >= objective.target;
      case 'time':
        return objective.current <= objective.target; // æ—¶é—´ç›®æ ‡æ˜¯ä¸Šé™
      case 'moves':
        return objective.current <= objective.target; // æ­¥æ•°ç›®æ ‡æ˜¯ä¸Šé™
      case 'collect':
        return objective.current >= objective.target;
      default:
        return false;
    }
  }
}
```

### éš¾åº¦å¹³è¡¡ç³»ç»Ÿ
- **ç½‘æ ¼å¤§å°**ï¼šæ›´å¤§ç½‘æ ¼å¢åŠ å¤æ‚åº¦
- **æ—¶é—´é™åˆ¶**ï¼šé™æ—¶å…³å¡å¢åŠ å‹åŠ›
- **æ­¥æ•°é™åˆ¶**ï¼šé™åˆ¶ç§»åŠ¨æ¬¡æ•°
- **ç‰¹æ®Šå…ƒç´ **ï¼šå¢åŠ éšœç¢ç‰©å’Œé™åˆ¶å…ƒç´ 

## ğŸ® ç©å®¶ä½“éªŒè®¾è®¡

### è§†è§‰åé¦ˆç³»ç»Ÿ
- **æ¶ˆé™¤ç‰¹æ•ˆ**ï¼šå®çŸ³æ¶ˆå¤±æ—¶çš„åŠ¨ç”»æ•ˆæœ
- **è¿å‡»æ˜¾ç¤º**ï¼šè¿å‡»æ•°å­—å’Œå€ç‡æ˜¾ç¤º
- **åˆ†æ•°åé¦ˆ**ï¼šå®æ—¶åˆ†æ•°æ›´æ–°å’Œå¥–åŠ±æç¤º
- **è¿›åº¦æ¡**ï¼šå…³å¡ç›®æ ‡å®Œæˆè¿›åº¦

### éŸ³æ•ˆè®¾è®¡
- **æ¶ˆé™¤éŸ³æ•ˆ**ï¼šä¸åŒé•¿åº¦çš„åŒ¹é…æœ‰ä¸åŒéŸ³æ•ˆ
- **ç‰¹æ®ŠéŸ³æ•ˆ**ï¼šç‰¹æ®Šå…ƒç´ æ¿€æ´»çš„ç‹¬ç‰¹éŸ³æ•ˆ
- **èƒŒæ™¯éŸ³ä¹**ï¼šæ ¹æ®æ¸¸æˆçŠ¶æ€å˜åŒ–çš„éŸ³ä¹
- **è¿å‡»éŸ³æ•ˆ**ï¼šè¿å‡»æ—¶çš„æ¿€åŠ±éŸ³æ•ˆ

### æ“ä½œä½“éªŒ
- **æ‹–æ‹½äº¤æ¢**ï¼šç›´è§‚çš„æ‹–æ‹½æ“ä½œ
- **è‡ªåŠ¨åŒ¹é…**ï¼šæ™ºèƒ½çš„ç§»åŠ¨å»ºè®®
- **æ’¤é”€åŠŸèƒ½**ï¼šå…è®¸æ‚”æ£‹
- **æš‚åœåŠŸèƒ½**ï¼šæ¸¸æˆæš‚åœå’Œè®¾ç½®

## ğŸ”„ ç³»ç»Ÿä¼˜åŒ–ç­–ç•¥

### æ€§èƒ½ä¼˜åŒ–
- **å¯¹è±¡æ± **ï¼šå¤ç”¨å®çŸ³å’Œç‰¹æ•ˆå¯¹è±¡
- **æ‰¹é‡å¤„ç†**ï¼šæ‰¹é‡æ›´æ–°ç½‘æ ¼çŠ¶æ€
- **å¼‚æ­¥åŠ è½½**ï¼šé¢„åŠ è½½ä¸‹ä¸€å…³çš„èµ„æº
- **å†…å­˜ç®¡ç†**ï¼šåŠæ—¶æ¸…ç†ä¸éœ€è¦çš„å¯¹è±¡

### æ¸²æŸ“ä¼˜åŒ–
- **ç²¾çµè¡¨**ï¼šä½¿ç”¨çº¹ç†åˆé›†å‡å°‘draw call
- **LODç³»ç»Ÿ**ï¼šè¿œå¤„å…ƒç´ ç®€åŒ–æ¸²æŸ“
- **ç²’å­æ± **ï¼šå¤ç”¨ç²’å­æ•ˆæœ
- **åŠ¨ç”»ç¼“å­˜**ï¼šç¼“å­˜é‡å¤çš„åŠ¨ç”»åºåˆ—

## ğŸ“ˆ æ‰©å±•æ€§è®¾è®¡

### å…³å¡ç¼–è¾‘å™¨
- **å¯è§†åŒ–ç¼–è¾‘**ï¼šæ‹–æ‹½å¼å…³å¡è®¾è®¡
- **é¢„è®¾æ¨¡æ¿**ï¼šå¸¸ç”¨å…³å¡å¸ƒå±€æ¨¡æ¿
- **éš¾åº¦è°ƒæ•´**ï¼šåŠ¨æ€è°ƒæ•´å…³å¡å‚æ•°
- **æµ‹è¯•æ¨¡å¼**ï¼šå®æ—¶æµ‹è¯•å…³å¡å¯ç©æ€§

### è‡ªå®šä¹‰å…ƒç´ 
- **æ–°å®çŸ³ç±»å‹**ï¼šæ·»åŠ æ–°çš„å®çŸ³ç§ç±»
- **ç‰¹æ®Šæ•ˆæœ**ï¼šè‡ªå®šä¹‰ç‰¹æ®Šå…ƒç´ æ•ˆæœ
- **éšœç¢ç‰©ç³»ç»Ÿ**ï¼šæ·»åŠ å„ç§éšœç¢ç‰©ç±»å‹
- **Buffç³»ç»Ÿ**ï¼šä¸´æ—¶çŠ¶æ€æ•ˆæœ

## ğŸ¯ æ ¸å¿ƒæˆåŠŸè¦ç´ 

1. **æµç•…æ€§**ï¼šä¸æ»‘çš„æ¶ˆé™¤ä½“éªŒå’ŒåŠ¨ç”»æ•ˆæœ
2. **ç­–ç•¥æ€§**ï¼šåˆç†çš„åŒ¹é…è§„åˆ™å’Œè¿å‡»ç³»ç»Ÿ
3. **é‡ç©æ€§**ï¼šå¤šæ ·åŒ–çš„å…³å¡å’ŒæŒ‘æˆ˜ç›®æ ‡
4. **è§†è§‰ä½“éªŒ**ï¼šç²¾ç¾çš„ç¾æœ¯é£æ ¼å’Œç‰¹æ•ˆ
5. **éš¾åº¦æ›²çº¿**ï¼šåˆç†çš„éš¾åº¦é€’è¿›å’Œæ•™å­¦è®¾è®¡

---

*æ¶ˆé™¤ç±»æ¸¸æˆçš„æ ¸å¿ƒé­…åŠ›åœ¨äºç®€å•è§„åˆ™ä¸‹äº§ç”Ÿçš„å¤æ‚ç­–ç•¥ï¼Œé€šè¿‡ç²¾å¿ƒçš„è§†è§‰è®¾è®¡å’Œæµç•…çš„æ“ä½œä½“éªŒï¼Œå¯ä»¥åˆ›é€ å‡ºä»¤äººä¸Šç˜¾çš„æ¶ˆé™¤ä¹è¶£ã€‚*
