# çº¢ç‚¹ç³»ç»Ÿè®¾è®¡

## ğŸ¯ ç³»ç»Ÿæ¦‚è¿°

çº¢ç‚¹ç³»ç»Ÿï¼ˆRed Dot Systemï¼‰æ˜¯ç°ä»£æ¸¸æˆä¸­ä¸å¯æˆ–ç¼ºçš„UIæç¤ºæœºåˆ¶ï¼Œç”¨äºæé†’ç©å®¶æœ‰æ–°çš„å†…å®¹ã€ä»»åŠ¡æ›´æ–°ã€å¥–åŠ±å¯é¢†å–ç­‰é‡è¦ä¿¡æ¯ã€‚é€šè¿‡è§†è§‰åŒ–çš„çº¢ç‚¹æç¤ºï¼Œå¯ä»¥æœ‰æ•ˆå¼•å¯¼ç©å®¶æ³¨æ„åŠ›ï¼Œæå‡æ¸¸æˆä½“éªŒå’Œç”¨æˆ·ç²˜æ€§ã€‚

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„æ¨¡å—

### æ•°æ®ç»“æ„è®¾è®¡

#### çº¢ç‚¹èŠ‚ç‚¹æ•°æ®ç»“æ„

```typescript
interface RedDotNode {
  // èŠ‚ç‚¹å”¯ä¸€æ ‡è¯†
  id: string;
  // çˆ¶èŠ‚ç‚¹ID
  parentId?: string;
  // å­èŠ‚ç‚¹åˆ—è¡¨
  children: string[];
  // çº¢ç‚¹çŠ¶æ€
  isVisible: boolean;
  // çº¢ç‚¹æ•°é‡ï¼ˆç”¨äºæ˜¾ç¤ºå…·ä½“æ•°å€¼ï¼Œå¦‚"99+"ï¼‰
  count: number;
  // çº¢ç‚¹ç±»å‹
  type: RedDotType;
  // è‡ªå®šä¹‰æ•°æ®
  data?: any;
  // æ›´æ–°æ—¶é—´æˆ³
  lastUpdateTime: number;
}

enum RedDotType {
  NONE = 0,           // æ— çº¢ç‚¹
  DOT = 1,            // çº¯çº¢ç‚¹
  NUMBER = 2,         // æ•°å­—çº¢ç‚¹
  CUSTOM = 3          // è‡ªå®šä¹‰æ ·å¼
}
```

#### çº¢ç‚¹æ ‘å½¢ç»“æ„

```mermaid
graph TD
    A[æ ¹èŠ‚ç‚¹] --> B[é‚®ä»¶ç³»ç»Ÿ]
    A --> C[ä»»åŠ¡ç³»ç»Ÿ]
    A --> D[èƒŒåŒ…ç³»ç»Ÿ]
    A --> E[å¥½å‹ç³»ç»Ÿ]

    B --> B1[ç³»ç»Ÿé‚®ä»¶]
    B --> B2[å¥½å‹é‚®ä»¶]
    B --> B3[å¥–åŠ±é‚®ä»¶]

    C --> C1[ä¸»çº¿ä»»åŠ¡]
    C --> C2[æ”¯çº¿ä»»åŠ¡]
    C --> C3[æ—¥å¸¸ä»»åŠ¡]

    D --> D1[è£…å¤‡]
    D --> D2[é“å…·]
    D --> D3[ææ–™]

    E --> E1[å¥½å‹ç”³è¯·]
    E --> E2[å¥½å‹æ¶ˆæ¯]

    style A fill:#e6f7ff
    style B fill:#fff7e6
    style C fill:#e6ffe6
    style D fill:#ffe6e6
    style E fill:#f0e6ff
```

### ä»£ç æ¶æ„è®¾è®¡

#### æ ¸å¿ƒç»„ä»¶æ¶æ„

```mermaid
classDiagram
    class RedDotManager {
        +Map<string, RedDotNode> nodes
        +List<IRedDotObserver> observers
        +Init()
        +RegisterNode(node: RedDotNode)
        +UpdateNode(id: string, state: RedDotState)
        +GetNodeState(id: string): RedDotState
        +NotifyObservers(id: string)
    }

    class RedDotController {
        +RedDotManager manager
        +UIManager uiManager
        +CheckCondition(id: string): boolean
        +UpdateRedDot(id: string)
        +BatchUpdate(ids: string[])
    }

    class RedDotView {
        +string nodeId
        +GameObject dotObject
        +Text countText
        +Show()
        +Hide()
        +UpdateCount(count: number)
        +UpdateStyle(type: RedDotType)
    }

    class IRedDotObserver {
        <<interface>>
        +OnRedDotChanged(id: string, state: RedDotState)
    }

    RedDotManager --> RedDotNode
    RedDotManager --> IRedDotObserver
    RedDotController --> RedDotManager
    RedDotController --> RedDotView
    RedDotView --> RedDotNode
```

#### çŠ¶æ€æ›´æ–°æµç¨‹

```mermaid
flowchart TD
    A[è§¦å‘äº‹ä»¶] --> B[æ£€æŸ¥æ¡ä»¶]
    B --> C{æ¡ä»¶æ»¡è¶³?}
    C -->|æ˜¯| D[æ›´æ–°èŠ‚ç‚¹çŠ¶æ€]
    C -->|å¦| E[ç»“æŸ]

    D --> F[å‘ä¸Šä¼ æ’­]
    F --> G[é€šçŸ¥è§‚å¯Ÿè€…]
    G --> H[æ›´æ–°UIæ˜¾ç¤º]

    style A fill:#e6f7ff
    style D fill:#fff7e6
    style H fill:#e6ffe6
```

### UIå®ç°æ€è·¯

#### çº¢ç‚¹ç»„ä»¶è®¾è®¡

```mermaid
mindmap
  root((çº¢ç‚¹ç»„ä»¶))
    æ˜¾ç¤ºé€»è¾‘
      é€’å½’æ£€æŸ¥
      æ€§èƒ½ä¼˜åŒ–
      åŠ¨ç”»æ•ˆæœ
    æ ·å¼ç®¡ç†
      é»˜è®¤æ ·å¼
      è‡ªå®šä¹‰æ ·å¼
      ä¸»é¢˜é€‚é…
    ä½ç½®ç®¡ç†
      ç›¸å¯¹å®šä½
      ç»å¯¹å®šä½
      è‡ªé€‚åº”å¸ƒå±€
    äº¤äº’å¤„ç†
      ç‚¹å‡»å“åº”
      çŠ¶æ€åˆ‡æ¢
      äº‹ä»¶ä¼ é€’
```

#### UIå±‚çº§ç»“æ„

```
Canvas
â”œâ”€â”€ MainUI
â”‚   â”œâ”€â”€ TopBar
â”‚   â”‚   â”œâ”€â”€ MailButton
â”‚   â”‚   â”‚   â””â”€â”€ RedDot (é‚®ä»¶)
â”‚   â”‚   â”œâ”€â”€ TaskButton
â”‚   â”‚   â”‚   â””â”€â”€ RedDot (ä»»åŠ¡)
â”‚   â”‚   â””â”€â”€ BagButton
â”‚   â”‚       â””â”€â”€ RedDot (èƒŒåŒ…)
â”‚   â”œâ”€â”€ SideBar
â”‚   â”‚   â”œâ”€â”€ FriendButton
â”‚   â”‚   â”‚   â””â”€â”€ RedDot (å¥½å‹)
â”‚   â”‚   â””â”€â”€ ShopButton
â”‚   â”‚       â””â”€â”€ RedDot (å•†åº—)
â”‚   â””â”€â”€ ContentArea
â”‚       â”œâ”€â”€ MailPanel
â”‚       â”‚   â”œâ”€â”€ SystemMailTab
â”‚       â”‚   â”‚   â””â”€â”€ RedDot (ç³»ç»Ÿé‚®ä»¶)
â”‚       â”‚   â”œâ”€â”€ FriendMailTab
â”‚       â”‚   â”‚   â””â”€â”€ RedDot (å¥½å‹é‚®ä»¶)
â”‚       â”‚   â””â”€â”€ RewardMailTab
â”‚       â”‚       â””â”€â”€ RedDot (å¥–åŠ±é‚®ä»¶)
```

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½å®ç°

### 1. çº¢ç‚¹æ³¨å†Œä¸ç®¡ç†

```typescript
class RedDotManager {
  private nodes: Map<string, RedDotNode> = new Map();
  private observers: IRedDotObserver[] = [];

  // æ³¨å†Œçº¢ç‚¹èŠ‚ç‚¹
  public RegisterNode(node: RedDotNode): void {
    this.nodes.set(node.id, node);

    // å»ºç«‹çˆ¶å­å…³ç³»
    if (node.parentId) {
      const parent = this.nodes.get(node.parentId);
      if (parent && !parent.children.includes(node.id)) {
        parent.children.push(node.id);
      }
    }
  }

  // æ›´æ–°çº¢ç‚¹çŠ¶æ€
  public UpdateNode(id: string, isVisible: boolean, count: number = 0): void {
    const node = this.nodes.get(id);
    if (!node) return;

    node.isVisible = isVisible;
    node.count = count;
    node.lastUpdateTime = Date.now();

    // å‘ä¸Šä¼ æ’­çŠ¶æ€å˜åŒ–
    this.PropagateUp(id);

    // é€šçŸ¥è§‚å¯Ÿè€…
    this.NotifyObservers(id);
  }

  // å‘ä¸Šä¼ æ’­çŠ¶æ€å˜åŒ–
  private PropagateUp(id: string): void {
    const node = this.nodes.get(id);
    if (!node || !node.parentId) return;

    const parent = this.nodes.get(node.parentId);
    if (!parent) return;

    // æ›´æ–°çˆ¶èŠ‚ç‚¹çŠ¶æ€
    const hasVisibleChild = parent.children.some(childId => {
      const child = this.nodes.get(childId);
      return child?.isVisible;
    });

    parent.isVisible = hasVisibleChild;
    parent.lastUpdateTime = Date.now();

    // é€’å½’å‘ä¸Šä¼ æ’­
    this.PropagateUp(node.parentId);
  }
}
```

### 2. æ¡ä»¶æ£€æŸ¥ç³»ç»Ÿ

```typescript
class RedDotController {
  private manager: RedDotManager;
  private conditions: Map<string, () => boolean> = new Map();

  // æ³¨å†Œæ¡ä»¶æ£€æŸ¥å‡½æ•°
  public RegisterCondition(id: string, condition: () => boolean): void {
    this.conditions.set(id, condition);
  }

  // æ£€æŸ¥å¹¶æ›´æ–°çº¢ç‚¹
  public CheckAndUpdate(id: string): void {
    const condition = this.conditions.get(id);
    if (!condition) return;

    const isVisible = condition();
    let count = 0;

    // è·å–æ•°é‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (isVisible) {
      count = this.GetCount(id);
    }

    this.manager.UpdateNode(id, isVisible, count);
  }

  // è·å–çº¢ç‚¹æ•°é‡
  private GetCount(id: string): number {
    // æ ¹æ®ä¸åŒç±»å‹çš„çº¢ç‚¹è®¡ç®—æ•°é‡
    switch (id) {
      case 'mail':
        return this.GetUnreadMailCount();
      case 'task':
        return this.GetUnfinishedTaskCount();
      case 'bag':
        return this.GetNewItemCount();
      default:
        return 0;
    }
  }
}
```

### 3. UIæ˜¾ç¤ºç»„ä»¶

```typescript
class RedDotView extends MonoBehaviour {
  public nodeId: string;
  public dotSprite: Sprite;
  public countText: Text;
  public customStyle: RedDotStyle;

  private isVisible: boolean = false;

  void Start() {
    // æ³¨å†Œåˆ°è§‚å¯Ÿè€…
    RedDotManager.Instance.AddObserver(this);
  }

  void OnDestroy() {
    // å–æ¶ˆæ³¨å†Œ
    RedDotManager.Instance.RemoveObserver(this);
  }

  public void OnRedDotChanged(id: string, state: RedDotState) {
    if (id !== this.nodeId) return;

    this.UpdateDisplay(state);
  }

  private void UpdateDisplay(RedDotState state) {
    if (state.isVisible && !this.isVisible) {
      this.Show();
    } else if (!state.isVisible && this.isVisible) {
      this.Hide();
    }

    if (state.isVisible) {
      this.UpdateCount(state.count);
      this.UpdateStyle(state.type);
    }
  }

  private void Show() {
    this.isVisible = true;
    this.gameObject.SetActive(true);

    // æ’­æ”¾æ˜¾ç¤ºåŠ¨ç”»
    this.PlayShowAnimation();
  }

  private void Hide() {
    this.isVisible = false;
    this.gameObject.SetActive(false);
  }

  private void UpdateCount(count: number) {
    if (count <= 0) {
      this.countText.gameObject.SetActive(false);
      return;
    }

    this.countText.gameObject.SetActive(true);
    this.countText.text = count > 99 ? "99+" : count.ToString();
  }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. æ‰¹é‡æ›´æ–°æœºåˆ¶

```typescript
class RedDotBatchUpdater {
  private pendingUpdates: Set<string> = new Set();
  private updateTimer: number = 0;
  private readonly BATCH_INTERVAL = 0.1f; // 100ms

  public AddToBatch(id: string): void {
    this.pendingUpdates.add(id);
  }

  void Update() {
    this.updateTimer += Time.deltaTime;
    if (this.updateTimer >= BATCH_INTERVAL) {
      this.ProcessBatch();
      this.updateTimer = 0;
    }
  }

  private void ProcessBatch(): void {
    if (this.pendingUpdates.size === 0) return;

    // æ‰¹é‡å¤„ç†æ›´æ–°
    foreach (string id in this.pendingUpdates) {
      RedDotManager.Instance.CheckAndUpdate(id);
    }

    this.pendingUpdates.Clear();
  }
}
```

### 2. æ¡ä»¶ç¼“å­˜æœºåˆ¶

```typescript
class RedDotConditionCache {
  private cache: Map<string, { result: boolean, timestamp: number }> = new Map();
  private readonly CACHE_DURATION = 1.0f; // 1ç§’ç¼“å­˜

  public GetCachedResult(id: string): boolean | null {
    const cached = this.cache.get(id);
    if (!cached) return null;

    if (Time.time - cached.timestamp > CACHE_DURATION) {
      this.cache.delete(id);
      return null;
    }

    return cached.result;
  }

  public SetCacheResult(id: string, result: boolean): void {
    this.cache.set(id, {
      result: result,
      timestamp: Time.time
    });
  }
}
```

## ğŸ“Š æ‰©å±•åŠŸèƒ½

### 1. çº¢ç‚¹ä¼˜å…ˆçº§ç³»ç»Ÿ

```typescript
enum RedDotPriority {
  LOW = 1,
  NORMAL = 2,
  HIGH = 3,
  URGENT = 4
}

interface PriorityRedDotNode extends RedDotNode {
  priority: RedDotPriority;
  expireTime?: number; // è¿‡æœŸæ—¶é—´
  autoHide: boolean;   // è‡ªåŠ¨éšè—
}
```

### 2. çº¢ç‚¹åŠ¨ç”»ç³»ç»Ÿ

```typescript
class RedDotAnimation {
  public static Bounce(node: RedDotView): void {
    // å¼¹è·³åŠ¨ç”»
    DOTween.Sequence()
      .Append(node.transform.DOScale(1.2f, 0.1f))
      .Append(node.transform.DOScale(1.0f, 0.1f))
      .Play();
  }

  public static Pulse(node: RedDotView): void {
    // è„‰å†²åŠ¨ç”»
    node.transform.DOScale(1.1f, 0.5f)
      .SetLoops(-1, LoopType.Yoyo)
      .Play();
  }
}
```

### 3. çº¢ç‚¹ç»Ÿè®¡ç³»ç»Ÿ

```typescript
class RedDotAnalytics {
  public static TrackRedDotShow(id: string): void {
    // ç»Ÿè®¡çº¢ç‚¹æ˜¾ç¤ºæ¬¡æ•°
    AnalyticsManager.TrackEvent("red_dot_show", {
      red_dot_id: id,
      timestamp: Date.now()
    });
  }

  public static TrackRedDotClick(id: string): void {
    // ç»Ÿè®¡çº¢ç‚¹ç‚¹å‡»æ¬¡æ•°
    AnalyticsManager.TrackEvent("red_dot_click", {
      red_dot_id: id,
      timestamp: Date.now()
    });
  }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. è®¾è®¡åŸåˆ™
- **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªçº¢ç‚¹èŠ‚ç‚¹åªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®çš„åŠŸèƒ½
- **å±‚æ¬¡æ¸…æ™°**ï¼šé‡‡ç”¨æ ‘å½¢ç»“æ„ç»„ç»‡çº¢ç‚¹å±‚çº§å…³ç³»
- **æ€§èƒ½ä¼˜å…ˆ**ï¼šå‡å°‘ä¸å¿…è¦çš„UIæ›´æ–°å’Œæ¡ä»¶æ£€æŸ¥
- **æ‰©å±•æ€§å¼º**ï¼šæ”¯æŒåŠ¨æ€æ·»åŠ æ–°çš„çº¢ç‚¹ç±»å‹å’Œæ ·å¼

### 2. å¸¸è§ä½¿ç”¨åœºæ™¯
- **é‚®ä»¶ç³»ç»Ÿ**ï¼šæ–°é‚®ä»¶æé†’
- **ä»»åŠ¡ç³»ç»Ÿ**ï¼šä»»åŠ¡å®Œæˆã€æ–°ä»»åŠ¡æé†’
- **èƒŒåŒ…ç³»ç»Ÿ**ï¼šæ–°ç‰©å“è·å¾—
- **å¥½å‹ç³»ç»Ÿ**ï¼šå¥½å‹ç”³è¯·ã€æ¶ˆæ¯æé†’
- **å•†åº—ç³»ç»Ÿ**ï¼šé™æ—¶ä¼˜æƒ ã€æŠ˜æ‰£æé†’
- **æ´»åŠ¨ç³»ç»Ÿ**ï¼šæ´»åŠ¨å¼€å¯ã€å¥–åŠ±å¯é¢†å–

### 3. æ³¨æ„äº‹é¡¹
- é¿å…çº¢ç‚¹æ³›æ»¥ï¼Œå¯¼è‡´ç©å®¶è§†è§‰ç–²åŠ³
- çº¢ç‚¹çŠ¶æ€è¦ä¸å®é™…æ•°æ®ä¿æŒåŒæ­¥
- è€ƒè™‘ä¸åŒè®¾å¤‡æ€§èƒ½ï¼Œä¼˜åŒ–æ›´æ–°é¢‘ç‡
- æ”¯æŒçº¢ç‚¹å¼€å…³è®¾ç½®ï¼Œæ»¡è¶³ç©å®¶ä¸ªæ€§åŒ–éœ€æ±‚

## ğŸ’¾ æ•°æ®æŒä¹…åŒ–æœºåˆ¶

### æŒä¹…åŒ–ç­–ç•¥

```typescript
interface RedDotPersistence {
  // éœ€è¦æŒä¹…åŒ–çš„çº¢ç‚¹IDåˆ—è¡¨
  persistentIds: string[];
  // æŒä¹…åŒ–é—´éš”ï¼ˆç§’ï¼‰
  saveInterval: number;
  // æœ€åä¿å­˜æ—¶é—´
  lastSaveTime: number;
}

class RedDotPersistenceManager {
  private readonly STORAGE_KEY = "red_dot_states";
  private saveTimer: number = 0;

  // ä¿å­˜çº¢ç‚¹çŠ¶æ€
  public SaveStates(): void {
    const persistentStates: Map<string, RedDotState> = new Map();

    // åªä¿å­˜éœ€è¦æŒä¹…åŒ–çš„çº¢ç‚¹çŠ¶æ€
    for (const id of this.persistentIds) {
      const state = RedDotManager.Instance.GetNodeState(id);
      if (state && state.isVisible) {
        persistentStates.set(id, {
          isVisible: state.isVisible,
          count: state.count,
          lastUpdateTime: state.lastUpdateTime
        });
      }
    }

    const saveData = {
      version: "1.0",
      timestamp: Date.now(),
      states: Object.fromEntries(persistentStates)
    };

    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    LocalStorage.SetItem(this.STORAGE_KEY, JSON.stringify(saveData));
  }

  // åŠ è½½çº¢ç‚¹çŠ¶æ€
  public LoadStates(): void {
    try {
      const saveDataStr = LocalStorage.GetItem(this.STORAGE_KEY);
      if (!saveDataStr) return;

      const saveData = JSON.parse(saveDataStr);

      // ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
      if (saveData.version !== "1.0") {
        this.MigrateData(saveData);
      }

      // æ¢å¤çŠ¶æ€
      for (const [id, state] of Object.entries(saveData.states)) {
        RedDotManager.Instance.UpdateNode(id, state.isVisible, state.count);
      }
    } catch (error) {
      console.error("Failed to load red dot states:", error);
      // åŠ è½½å¤±è´¥æ—¶æ¸…ç†æŸåçš„æ•°æ®
      LocalStorage.RemoveItem(this.STORAGE_KEY);
    }
  }

  // æ•°æ®è¿ç§»
  private MigrateData(oldData: any): void {
    // å¤„ç†ç‰ˆæœ¬å‡çº§æ—¶çš„å…¼å®¹æ€§
    if (oldData.version === "0.9") {
      // ä»0.9ç‰ˆæœ¬è¿ç§»åˆ°1.0çš„é€»è¾‘
      for (const [id, state] of Object.entries(oldData.states)) {
        // è¿ç§»é€»è¾‘...
      }
    }
  }
}
```

## ğŸŒ å¤šè¯­è¨€æœ¬åœ°åŒ–æ”¯æŒ

### æœ¬åœ°åŒ–çº¢ç‚¹æ–‡æœ¬

```typescript
interface LocalizedRedDot {
  id: string;
  textKey: string;        // æœ¬åœ°åŒ–é”®å€¼
  params?: any[];         // å‚æ•°åŒ–æ–‡æœ¬å‚æ•°
}

class RedDotLocalizationManager {
  private localizedTexts: Map<string, LocalizedRedDot> = new Map();

  // æ³¨å†Œæœ¬åœ°åŒ–çº¢ç‚¹
  public RegisterLocalizedRedDot(config: LocalizedRedDot): void {
    this.localizedTexts.set(config.id, config);
  }

  // è·å–æœ¬åœ°åŒ–æ–‡æœ¬
  public GetLocalizedText(id: string): string {
    const config = this.localizedTexts.get(id);
    if (!config) return "";

    const baseText = LocalizationManager.GetText(config.textKey);
    if (!config.params) return baseText;

    // å‚æ•°æ›¿æ¢
    return this.FormatText(baseText, config.params);
  }

  private FormatText(template: string, params: any[]): string {
    return template.replace(/\{(\d+)\}/g, (match, index) => {
      return params[parseInt(index)]?.toString() || match;
    });
  }
}
```

## âš™ï¸ é…ç½®ç³»ç»Ÿ

### çº¢ç‚¹é…ç½®ç®¡ç†

```typescript
interface RedDotConfig {
  id: string;
  type: RedDotType;
  priority: RedDotPriority;
  style: RedDotStyle;
  conditions: RedDotCondition[];
  autoRefresh: boolean;
  refreshInterval?: number;
  expireTime?: number;
  dependencies?: string[];  // ä¾èµ–çš„å…¶ä»–çº¢ç‚¹
}

interface RedDotCondition {
  type: 'data' | 'event' | 'time' | 'custom';
  key: string;
  operator: '>' | '<' | '=' | '!=' | 'contains' | 'not_contains';
  value: any;
  logic?: 'AND' | 'OR';
}

class RedDotConfigManager {
  private configs: Map<string, RedDotConfig> = new Map();

  // åŠ è½½é…ç½®æ–‡ä»¶
  public LoadConfigs(configData: any): void {
    for (const [id, config] of Object.entries(configData)) {
      this.configs.set(id, config as RedDotConfig);
    }
  }

  // è·å–é…ç½®
  public GetConfig(id: string): RedDotConfig | undefined {
    return this.configs.get(id);
  }

  // æ£€æŸ¥æ¡ä»¶
  public CheckConditions(id: string): boolean {
    const config = this.configs.get(id);
    if (!config) return false;

    return config.conditions.every(condition => {
      return this.EvaluateCondition(condition);
    });
  }

  private EvaluateCondition(condition: RedDotCondition): boolean {
    const actualValue = this.GetActualValue(condition);

    switch (condition.operator) {
      case '>': return actualValue > condition.value;
      case '<': return actualValue < condition.value;
      case '=': return actualValue === condition.value;
      case '!=': return actualValue !== condition.value;
      case 'contains': return Array.isArray(actualValue) ?
        actualValue.includes(condition.value) : false;
      case 'not_contains': return Array.isArray(actualValue) ?
        !actualValue.includes(condition.value) : true;
      default: return false;
    }
  }

  private GetActualValue(condition: RedDotCondition): any {
    switch (condition.type) {
      case 'data':
        return DataManager.Get(condition.key);
      case 'event':
        return EventManager.HasPendingEvent(condition.key);
      case 'time':
        return Date.now();
      case 'custom':
        return this.GetCustomValue(condition.key);
      default:
        return null;
    }
  }
}
```

## ğŸ›¡ï¸ é”™è¯¯å¤„ç†å’Œå¼‚å¸¸æƒ…å†µ

### å¼‚å¸¸å¤„ç†æœºåˆ¶

```typescript
class RedDotErrorHandler {
  private errorCounts: Map<string, number> = new Map();
  private readonly MAX_ERROR_COUNT = 5;

  // å¤„ç†çº¢ç‚¹æ›´æ–°é”™è¯¯
  public HandleUpdateError(id: string, error: Error): void {
    console.error(`Red dot update failed for ${id}:`, error);

    const count = (this.errorCounts.get(id) || 0) + 1;
    this.errorCounts.set(id, count);

    if (count >= this.MAX_ERROR_COUNT) {
      // è¾¾åˆ°æœ€å¤§é”™è¯¯æ¬¡æ•°ï¼Œç¦ç”¨æ­¤çº¢ç‚¹
      this.DisableRedDot(id);
      this.ReportError(id, error);
    }
  }

  // å¤„ç†UIæ˜¾ç¤ºé”™è¯¯
  public HandleDisplayError(id: string, error: Error): void {
    console.error(`Red dot display failed for ${id}:`, error);

    // é™çº§å¤„ç†ï¼šéšè—çº¢ç‚¹
    RedDotViewManager.Instance.HideRedDot(id);
  }

  // ç¦ç”¨å¼‚å¸¸çº¢ç‚¹
  private DisableRedDot(id: string): void {
    RedDotManager.Instance.DisableNode(id);
    NotificationManager.ShowSystemMessage(
      `çº¢ç‚¹ç³»ç»Ÿå¼‚å¸¸ï¼Œå·²æš‚æ—¶ç¦ç”¨ ${id} çš„çº¢ç‚¹æç¤º`
    );
  }

  // ä¸ŠæŠ¥é”™è¯¯
  private ReportError(id: string, error: Error): void {
    AnalyticsManager.TrackError({
      category: 'red_dot_system',
      action: 'update_failed',
      label: id,
      value: this.errorCounts.get(id),
      error_message: error.message
    });
  }
}

class RedDotRecoveryManager {
  // ç³»ç»Ÿæ¢å¤
  public RecoverSystem(): void {
    // é‡ç½®æ‰€æœ‰çº¢ç‚¹çŠ¶æ€
    RedDotManager.Instance.ResetAll();

    // é‡æ–°åŠ è½½é…ç½®
    RedDotConfigManager.Instance.ReloadConfigs();

    // é‡æ–°æ³¨å†Œæ‰€æœ‰çº¢ç‚¹
    this.ReregisterAllRedDots();

    // é‡æ–°æ£€æŸ¥æ‰€æœ‰æ¡ä»¶
    RedDotController.Instance.CheckAllConditions();
  }

  // å•ä¸ªçº¢ç‚¹æ¢å¤
  public RecoverRedDot(id: string): void {
    try {
      // é‡ç½®çŠ¶æ€
      RedDotManager.Instance.ResetNode(id);

      // é‡æ–°æ³¨å†Œ
      this.ReregisterRedDot(id);

      // é‡æ–°æ£€æŸ¥æ¡ä»¶
      RedDotController.Instance.CheckCondition(id);

    } catch (error) {
      RedDotErrorHandler.Instance.HandleRecoveryError(id, error);
    }
  }
}
```

## ğŸ§  å†…å­˜ç®¡ç†æœºåˆ¶

### å†…å­˜ä¼˜åŒ–ç­–ç•¥

```typescript
class RedDotMemoryManager {
  private nodePool: RedDotNode[] = [];
  private viewPool: RedDotView[] = [];
  private readonly POOL_SIZE = 50;

  // å¯¹è±¡æ± ç®¡ç†
  public GetNodeFromPool(): RedDotNode {
    if (this.nodePool.length > 0) {
      return this.nodePool.pop()!;
    }
    return new RedDotNode();
  }

  public ReturnNodeToPool(node: RedDotNode): void {
    if (this.nodePool.length < this.POOL_SIZE) {
      // é‡ç½®èŠ‚ç‚¹çŠ¶æ€
      node.Reset();
      this.nodePool.push(node);
    }
  }

  // å®šæœŸæ¸…ç†
  public Cleanup(): void {
    // æ¸…ç†è¿‡æœŸçº¢ç‚¹
    this.CleanupExpiredRedDots();

    // æ¸…ç†æœªä½¿ç”¨çš„è§‚å¯Ÿè€…
    this.CleanupUnusedObservers();

    // æ¸…ç†ç¼“å­˜
    this.CleanupCache();

    // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœæ”¯æŒï¼‰
    if (window.gc) {
      window.gc();
    }
  }

  // å†…å­˜ç›‘æ§
  public GetMemoryUsage(): MemoryStats {
    return {
      nodeCount: RedDotManager.Instance.GetNodeCount(),
      observerCount: RedDotManager.Instance.GetObserverCount(),
      poolSize: this.nodePool.length,
      cacheSize: this.GetCacheSize()
    };
  }
}

interface MemoryStats {
  nodeCount: number;
  observerCount: number;
  poolSize: number;
  cacheSize: number;
}
```

## ğŸ§ª æµ‹è¯•è¦†ç›–æ–¹æ¡ˆ

### å•å…ƒæµ‹è¯•

```typescript
class RedDotSystemTests {
  // æµ‹è¯•çº¢ç‚¹çŠ¶æ€æ›´æ–°
  @Test
  public TestRedDotStateUpdate(): void {
    const manager = new RedDotManager();

    // åˆ›å»ºæµ‹è¯•èŠ‚ç‚¹
    const node: RedDotNode = {
      id: "test_node",
      isVisible: false,
      count: 0,
      type: RedDotType.DOT
    };

    manager.RegisterNode(node);
    manager.UpdateNode("test_node", true, 5);

    const state = manager.GetNodeState("test_node");
    Assert.IsTrue(state.isVisible);
    Assert.AreEqual(5, state.count);
  }

  // æµ‹è¯•æ ‘å½¢ç»“æ„ä¼ æ’­
  @Test
  public TestTreePropagation(): void {
    const manager = new RedDotManager();

    // åˆ›å»ºçˆ¶å­èŠ‚ç‚¹
    manager.RegisterNode({ id: "parent", children: ["child1", "child2"] });
    manager.RegisterNode({ id: "child1", parentId: "parent" });
    manager.RegisterNode({ id: "child2", parentId: "parent" });

    // æ›´æ–°å­èŠ‚ç‚¹
    manager.UpdateNode("child1", true);

    // æ£€æŸ¥çˆ¶èŠ‚ç‚¹çŠ¶æ€
    const parentState = manager.GetNodeState("parent");
    Assert.IsTrue(parentState.isVisible);
  }

  // æµ‹è¯•æ€§èƒ½
  @Test
  public TestPerformance(): void {
    const manager = new RedDotManager();

    // åˆ›å»ºå¤§é‡èŠ‚ç‚¹
    for (let i = 0; i < 1000; i++) {
      manager.RegisterNode({
        id: `node_${i}`,
        isVisible: false,
        count: 0,
        type: RedDotType.DOT
      });
    }

    const startTime = Date.now();

    // æ‰¹é‡æ›´æ–°
    for (let i = 0; i < 1000; i++) {
      manager.UpdateNode(`node_${i}`, true);
    }

    const endTime = Date.now();
    const duration = endTime - startTime;

    // æ€§èƒ½æ–­è¨€ï¼ˆæ‰¹é‡æ›´æ–°åº”åœ¨åˆç†æ—¶é—´å†…å®Œæˆï¼‰
    Assert.IsTrue(duration < 100, `Batch update took ${duration}ms`);
  }
}
```

## ğŸ”§ è°ƒè¯•å·¥å…·

### å¼€å‘è°ƒè¯•é¢æ¿

```typescript
class RedDotDebugPanel {
  private panel: GameObject;
  private isVisible: boolean = false;

  // æ˜¾ç¤ºè°ƒè¯•é¢æ¿
  public Show(): void {
    if (!this.panel) {
      this.CreateDebugPanel();
    }
    this.panel.SetActive(true);
    this.isVisible = true;
    this.UpdateDebugInfo();
  }

  // éšè—è°ƒè¯•é¢æ¿
  public Hide(): void {
    if (this.panel) {
      this.panel.SetActive(false);
    }
    this.isVisible = false;
  }

  // æ›´æ–°è°ƒè¯•ä¿¡æ¯
  private UpdateDebugInfo(): void {
    const stats = this.GetSystemStats();
    const treeInfo = this.GetTreeStructure();

    // æ›´æ–°UIæ˜¾ç¤º
    this.UpdateStatsDisplay(stats);
    this.UpdateTreeDisplay(treeInfo);
  }

  // è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯
  private GetSystemStats(): DebugStats {
    return {
      totalNodes: RedDotManager.Instance.GetNodeCount(),
      visibleNodes: RedDotManager.Instance.GetVisibleNodeCount(),
      observerCount: RedDotManager.Instance.GetObserverCount(),
      memoryUsage: RedDotMemoryManager.Instance.GetMemoryUsage(),
      updateCount: RedDotManager.Instance.GetUpdateCount(),
      lastUpdateTime: RedDotManager.Instance.GetLastUpdateTime()
    };
  }

  // è·å–æ ‘å½¢ç»“æ„ä¿¡æ¯
  private GetTreeStructure(): TreeNode[] {
    return RedDotManager.Instance.GetTreeStructure();
  }

  // åˆ›å»ºè°ƒè¯•é¢æ¿UI
  private CreateDebugPanel(): void {
    this.panel = new GameObject("RedDotDebugPanel");

    // åˆ›å»ºèƒŒæ™¯
    const background = this.CreateBackground();

    // åˆ›å»ºç»Ÿè®¡ä¿¡æ¯åŒºåŸŸ
    const statsPanel = this.CreateStatsPanel();

    // åˆ›å»ºæ ‘å½¢ç»“æ„æ˜¾ç¤ºåŒºåŸŸ
    const treePanel = this.CreateTreePanel();

    // åˆ›å»ºæ§åˆ¶æŒ‰é’®
    const controlPanel = this.CreateControlPanel();
  }
}

interface DebugStats {
  totalNodes: number;
  visibleNodes: number;
  observerCount: number;
  memoryUsage: MemoryStats;
  updateCount: number;
  lastUpdateTime: number;
}
```

---

*æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„çº¢ç‚¹ç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆï¼ŒåŒ…å«æ•°æ®ç»“æ„ã€ä»£ç æ¶æ„ã€UIå®ç°æ€è·¯ä»¥åŠè¡¥å……çš„æŒä¹…åŒ–ã€å¤šè¯­è¨€ã€é…ç½®ã€é”™è¯¯å¤„ç†ã€å†…å­˜ç®¡ç†ã€æµ‹è¯•å’Œè°ƒè¯•åŠŸèƒ½ã€‚åœ¨å®é™…é¡¹ç›®ä¸­å¯æ ¹æ®å…·ä½“éœ€æ±‚è¿›è¡Œè°ƒæ•´å’Œä¼˜åŒ–ã€‚*
