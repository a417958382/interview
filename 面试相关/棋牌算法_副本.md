## 🎯 棋牌博彩游戏中的经典算法与数据结构

### 1. 完全信息博弈算法 ♟️

#### **Minimax算法（极小极大算法）**

**使用场景**：
- **象棋/国际象棋**：计算最佳走子
- **跳棋**：局面评估
- **五子棋**：胜负判断
- **井字棋**：完美游戏

**核心思路**：
```typescript
// 假设MAX玩家想要最大化分数，MIN玩家想要最小化分数
interface GameState {
    board: number[][];
    currentPlayer: 'MAX' | 'MIN';
    depth: number;
}

class MinimaxAlgorithm {
    private maxDepth = 6;                    // 搜索深度限制
    private evaluationCache: Map<string, number>; // 哈希表缓存
    
    minimax(state: GameState, depth: number, isMaximizing: boolean): number {
        // 递归终止条件
        if (depth === 0 || this.isGameOver(state)) {
            return this.evaluate(state);
        }
        
        const stateKey = this.encodeState(state);
        if (this.evaluationCache.has(stateKey)) {
            return this.evaluationCache.get(stateKey)!;
        }
        
        let bestValue: number;
        
        if (isMaximizing) {
            bestValue = -Infinity;
            const moves = this.generateMoves(state);
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const value = this.minimax(newState, depth - 1, false);
                bestValue = Math.max(bestValue, value);
            }
        } else {
            bestValue = Infinity;
            const moves = this.generateMoves(state);
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const value = this.minimax(newState, depth - 1, true);
                bestValue = Math.min(bestValue, value);
            }
        }
        
        this.evaluationCache.set(stateKey, bestValue);
        return bestValue;
    }
    
    // 局面评估函数（象棋例子）
    evaluate(state: GameState): number {
        let score = 0;
        
        // 1. 棋子价值统计
        const pieceValues = { 车: 10, 马: 5, 炮: 5, 兵: 1, 将: 1000 };
        
        // 2. 位置价值（控制中心更有价值）
        const positionBonus = this.calculatePositionBonus(state.board);
        
        // 3. 安全性评估（将军、被将军等）
        const safetyScore = this.calculateSafety(state.board);
        
        return score + positionBonus + safetyScore;
    }
}

console.log("Minimax核心数据结构:");
console.log("🌳 递归调用栈: 深度优先搜索");
console.log("🗂️ 哈希表: 状态评估值缓存");
console.log("📊 二维数组: 棋盘状态表示");
console.log("⏱️ 时间复杂度: O(b^d) b=分支因子, d=深度");
```

#### **Alpha-Beta剪枝优化**

**使用场景**：优化Minimax算法，大幅减少搜索节点

**核心思路**：
```typescript
class AlphaBetaPruning {
    alphaBeta(state: GameState, depth: number, alpha: number, beta: number, isMaximizing: boolean): number {
        if (depth === 0 || this.isGameOver(state)) {
            return this.evaluate(state);
        }
        
        if (isMaximizing) {
            let maxEval = -Infinity;
            const moves = this.generateMoves(state);
            
            // 移动排序优化：优先搜索可能更好的移动
            moves.sort((a, b) => this.moveOrderingHeuristic(b) - this.moveOrderingHeuristic(a));
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const eval = this.alphaBeta(newState, depth - 1, alpha, beta, false);
                
                maxEval = Math.max(maxEval, eval);
                alpha = Math.max(alpha, eval);
                
                // Beta剪枝：如果α ≥ β，后续分支不需要搜索
                if (beta <= alpha) {
                    console.log(`剪枝发生：α=${alpha}, β=${beta}`);
                    break; // 剪枝！
                }
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            const moves = this.generateMoves(state);
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const eval = this.alphaBeta(newState, depth - 1, alpha, beta, true);
                
                minEval = Math.min(minEval, eval);
                beta = Math.min(beta, eval);
                
                // Alpha剪枝
                if (beta <= alpha) {
                    break; // 剪枝！
                }
            }
            return minEval;
        }
    }
    
    // 移动排序启发：历史表记录好的移动
    private historyTable: Map<string, number> = new Map();
    
    moveOrderingHeuristic(move: Move): number {
        // 1. 历史启发：之前导致Beta剪枝的移动优先
        const historyScore = this.historyTable.get(move.toString()) || 0;
        
        // 2. 捕获启发：吃子移动优先
        const captureScore = move.isCapture ? 1000 : 0;
        
        // 3. 中心控制：控制中心的移动优先
        const centerScore = this.calculateCenterControl(move);
        
        return historyScore + captureScore + centerScore;
    }
}

console.log("Alpha-Beta剪枝效果:");
console.log("✂️ 理想情况: 搜索节点减少到 O(b^(d/2))");
console.log("📈 平均情况: 减少50-90%的节点");
console.log("🎯 关键: 移动排序质量影响剪枝效果");
```

### 2. 置换表（Transposition Table）🗂️

**使用场景**：
- **象棋引擎**：避免重复计算相同局面
- **围棋AI**：缓存已计算的位置评估
- **跳棋程序**：提高搜索效率

**核心思路**：
```typescript
interface TranspositionEntry {
    zobristHash: bigint;         // Zobrist哈希值
    depth: number;               // 搜索深度
    nodeType: 'EXACT' | 'LOWER_BOUND' | 'UPPER_BOUND';
    bestMove: Move | null;       // 最佳移动
    evaluation: number;          // 评估值
    age: number;                // 生成时间（用于替换策略）
}

class TranspositionTable {
    private table: (TranspositionEntry | null)[];  // 哈希表主体
    private size: number;                           // 表大小
    private zobristKeys: bigint[][][];              // Zobrist随机数表
    
    constructor(sizeInMB: number = 64) {
        this.size = (sizeInMB * 1024 * 1024) / 32; // 每个条目约32字节
        this.table = new Array(this.size).fill(null);
        this.initializeZobristKeys();
    }
    
    // 初始化Zobrist哈希所需的随机数
    initializeZobristKeys(): void {
        // 为每个位置、每种棋子生成唯一的64位随机数
        this.zobristKeys = [];
        
        for (let row = 0; row < 10; row++) {
            this.zobristKeys[row] = [];
            for (let col = 0; col < 9; col++) {
                this.zobristKeys[row][col] = [];
                for (let piece = 0; piece < 14; piece++) { // 14种不同棋子
                    this.zobristKeys[row][col][piece] = this.randomBigInt();
                }
            }
        }
    }
    
    // 计算当前局面的Zobrist哈希值
    calculateZobristHash(board: number[][]): bigint {
        let hash = 0n;
        
        for (let row = 0; row < board.length; row++) {
            for (let col = 0; col < board[row].length; col++) {
                const piece = board[row][col];
                if (piece !== 0) { // 有棋子
                    hash ^= this.zobristKeys[row][col][piece];
                }
            }
        }
        
        return hash;
    }
    
    // 增量更新哈希值（移动棋子时）
    updateZobristHash(currentHash: bigint, move: Move): bigint {
        let newHash = currentHash;
        
        // 移除原位置的棋子
        newHash ^= this.zobristKeys[move.from.row][move.from.col][move.piece];
        
        // 如果吃子，移除被吃的棋子
        if (move.capturedPiece) {
            newHash ^= this.zobristKeys[move.to.row][move.to.col][move.capturedPiece];
        }
        
        // 添加新位置的棋子
        newHash ^= this.zobristKeys[move.to.row][move.to.col][move.piece];
        
        return newHash;
    }
    
    // 查找置换表
    probe(hash: bigint, depth: number): TranspositionEntry | null {
        const index = Number(hash % BigInt(this.size));
        const entry = this.table[index];
        
        if (entry && entry.zobristHash === hash && entry.depth >= depth) {
            return entry;
        }
        
        return null;
    }
    
    // 存储到置换表
    store(hash: bigint, depth: number, nodeType: string, evaluation: number, bestMove: Move | null): void {
        const index = Number(hash % BigInt(this.size));
        const currentEntry = this.table[index];
        
        // 替换策略：总是替换（简单策略）
        // 更复杂的策略：深度优先、年龄优先等
        if (!currentEntry || currentEntry.depth <= depth) {
            this.table[index] = {
                zobristHash: hash,
                depth: depth,
                nodeType: nodeType as any,
                evaluation: evaluation,
                bestMove: bestMove,
                age: Date.now()
            };
        }
    }
    
    private randomBigInt(): bigint {
        // 生成64位随机数
        const high = BigInt(Math.floor(Math.random() * 0x100000000));
        const low = BigInt(Math.floor(Math.random() * 0x100000000));
        return (high << 32n) | low;
    }
}

console.log("置换表核心数据结构:");
console.log("🗂️ 哈希表: 快速查找O(1)");
console.log("🎲 Zobrist哈希: 局面唯一标识");
console.log("🔄 增量更新: 避免重复计算哈希");
console.log("💾 替换策略: 内存管理关键");
```

### 3. 迭代加深搜索 🔄

**使用场景**：
- **实时对弈**：限定思考时间
- **在线游戏**：避免超时
- **移动设备**：计算资源有限

**核心思路**：
```typescript
class IterativeDeepeningSearch {
    private timeLimit: number;               // 时间限制(毫秒)
    private startTime: number;               // 搜索开始时间
    private bestMoveHistory: Move[];         // 历史最佳移动
    private killerMoves: Move[][];           // 杀手启发表
    
    constructor(timeLimitMs: number = 5000) {
        this.timeLimit = timeLimitMs;
        this.killerMoves = Array(20).fill(null).map(() => []);
    }
    
    search(state: GameState): Move {
        this.startTime = Date.now();
        let bestMove: Move | null = null;
        let bestValue = -Infinity;
        
        // 从深度1开始，逐渐增加搜索深度
        for (let depth = 1; depth <= 20; depth++) {
            
            // 检查时间是否用完
            if (this.isTimeUp()) {
                console.log(`时间用完，停止在深度 ${depth - 1}`);
                break;
            }
            
            console.log(`开始搜索深度 ${depth}`);
            
            try {
                const result = this.alphaBetaWithTimeControl(state, depth, -Infinity, Infinity, true);
                
                if (result.move) {
                    bestMove = result.move;
                    bestValue = result.value;
                    console.log(`深度 ${depth}: 最佳移动 ${bestMove.toString()}, 评估值 ${bestValue}`);
                }
                
                // 如果找到必胜/必败位置，可以提前停止
                if (Math.abs(bestValue) > 10000) {
                    console.log(`找到确定结果，提前停止搜索`);
                    break;
                }
                
            } catch (timeoutError) {
                console.log(`深度 ${depth} 搜索被时间中断`);
                break;
            }
        }
        
        return bestMove!;
    }
    
    alphaBetaWithTimeControl(state: GameState, depth: number, alpha: number, beta: number, isMaximizing: boolean): {value: number, move: Move | null} {
        // 时间检查
        if (this.isTimeUp()) {
            throw new Error('Time limit exceeded');
        }
        
        if (depth === 0 || this.isGameOver(state)) {
            return { value: this.evaluate(state), move: null };
        }
        
        const moves = this.generateMoves(state);
        
        // 移动排序：使用历史表和杀手启发
        this.orderMoves(moves, depth);
        
        let bestMove: Move | null = null;
        
        if (isMaximizing) {
            let maxEval = -Infinity;
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const result = this.alphaBetaWithTimeControl(newState, depth - 1, alpha, beta, false);
                
                if (result.value > maxEval) {
                    maxEval = result.value;
                    bestMove = move;
                }
                
                alpha = Math.max(alpha, result.value);
                
                if (beta <= alpha) {
                    // 记录杀手移动
                    this.updateKillerMoves(move, depth);
                    break;
                }
            }
            
            return { value: maxEval, move: bestMove };
        } else {
            let minEval = Infinity;
            
            for (const move of moves) {
                const newState = this.makeMove(state, move);
                const result = this.alphaBetaWithTimeControl(newState, depth - 1, alpha, beta, true);
                
                if (result.value < minEval) {
                    minEval = result.value;
                    bestMove = move;
                }
                
                beta = Math.min(beta, result.value);
                
                if (beta <= alpha) {
                    this.updateKillerMoves(move, depth);
                    break;
                }
            }
            
            return { value: minEval, move: bestMove };
        }
    }
    
    // 移动排序：提高剪枝效率
    orderMoves(moves: Move[], depth: number): void {
        moves.sort((a, b) => {
            // 1. 历史最佳移动优先
            if (this.bestMoveHistory.includes(a)) return -1;
            if (this.bestMoveHistory.includes(b)) return 1;
            
            // 2. 杀手移动优先
            if (this.killerMoves[depth].includes(a)) return -1;
            if (this.killerMoves[depth].includes(b)) return 1;
            
            // 3. 捕获移动优先，按价值排序
            if (a.isCapture && !b.isCapture) return -1;
            if (!a.isCapture && b.isCapture) return 1;
            if (a.isCapture && b.isCapture) {
                return (b.capturedPieceValue || 0) - (a.capturedPieceValue || 0);
            }
            
            return 0;
        });
    }
    
    // 更新杀手移动表
    updateKillerMoves(move: Move, depth: number): void {
        const killers = this.killerMoves[depth];
        
        // 如果不在杀手表中，添加到前面
        if (!killers.includes(move)) {
            killers.unshift(move);
            
            // 保持表大小（通常2个杀手移动）
            if (killers.length > 2) {
                killers.pop();
            }
        }
    }
    
    isTimeUp(): boolean {
        return Date.now() - this.startTime > this.timeLimit;
    }
}

console.log("迭代加深搜索特点:");
console.log("⏱️ 任何时候可停止: 时间控制友好");
console.log("📈 渐进式改进: 浅层为深层提供启发");
console.log("🎯 移动排序: 历史表+杀手启发提高效率");
console.log("💾 内存友好: 不需要存储整个搜索树");
```

### 4. 概率与期望值计算 🎲

#### **德州扑克牌力计算**

**使用场景**：
- **德州扑克**：计算胜率和期望收益
- **梭哈游戏**：牌型概率分析
- **21点**：剩余牌张概率

**核心思路**：
```typescript
interface Card {
    suit: 'hearts' | 'diamonds' | 'clubs' | 'spades';
    rank: number; // 1-13 (A,2,3...J,Q,K)
}

interface HandStrength {
    handType: string;
    strength: number;     // 相对强度值
    probability: number;  // 形成概率
}

class PokerCalculator {
    private deck: Card[];                    // 完整牌组
    private handRankings: Map<string, number>; // 牌型排名
    private combinationCache: Map<string, number>; // 组合数缓存
    
    constructor() {
        this.initializeDeck();
        this.initializeHandRankings();
        this.combinationCache = new Map();
    }
    
    // 计算胜率（蒙特卡罗方法）
    calculateWinProbability(myCards: Card[], communityCards: Card[], opponents: number, simulations: number = 10000): number {
        let wins = 0;
        const usedCards = [...myCards, ...communityCards];
        
        for (let sim = 0; sim < simulations; sim++) {
            // 随机发剩余的牌
            const availableCards = this.getAvailableCards(usedCards);
            const shuffled = this.shuffle(availableCards);
            
            // 完成我的手牌
            const myFinalCards = [...myCards, ...communityCards];
            const remainingCommunity = 5 - communityCards.length;
            
            for (let i = 0; i < remainingCommunity; i++) {
                myFinalCards.push(shuffled[i]);
            }
            
            const myBestHand = this.getBestHand(myFinalCards);
            let iWin = true;
            
            // 模拟对手的牌
            let cardIndex = remainingCommunity;
            for (let opp = 0; opp < opponents; opp++) {
                const oppCards = [shuffled[cardIndex], shuffled[cardIndex + 1]];
                const oppFinalCards = [...oppCards, ...communityCards];
                
                // 添加剩余公共牌
                for (let i = 0; i < remainingCommunity; i++) {
                    oppFinalCards.push(shuffled[i]);
                }
                
                const oppBestHand = this.getBestHand(oppFinalCards);
                
                if (this.compareHands(oppBestHand, myBestHand) > 0) {
                    iWin = false;
                    break;
                }
                
                cardIndex += 2;
            }
            
            if (iWin) wins++;
        }
        
        return wins / simulations;
    }
    
    // 计算牌型概率（精确计算）
    calculateHandProbabilities(cards: Card[]): Map<string, number> {
        const probabilities = new Map<string, number>();
        
        if (cards.length === 2) {
            // 起手牌，计算到河牌的各种牌型概率
            const totalCombinations = this.combination(50, 5); // C(50,5)
            
            // 计算各种牌型的组合数
            const straightFlushCombos = this.countStraightFlushCombinations(cards);
            const fourKindCombos = this.countFourOfAKindCombinations(cards);
            const fullHouseCombos = this.countFullHouseCombinations(cards);
            // ... 其他牌型
            
            probabilities.set('StraightFlush', straightFlushCombos / totalCombinations);
            probabilities.set('FourOfAKind', fourKindCombos / totalCombinations);
            probabilities.set('FullHouse', fullHouseCombos / totalCombinations);
        }
        
        return probabilities;
    }
    
    // 计算期望收益
    calculateExpectedValue(myCards: Card[], communityCards: Card[], potSize: number, betSize: number, opponents: number): number {
        const winProbability = this.calculateWinProbability(myCards, communityCards, opponents);
        const loseProbability = 1 - winProbability;
        
        // 跟注的期望收益
        const callEV = winProbability * potSize - loseProbability * betSize;
        
        // 弃牌的期望收益（总是0）
        const foldEV = 0;
        
        console.log(`胜率: ${(winProbability * 100).toFixed(2)}%`);
        console.log(`跟注期望收益: ${callEV.toFixed(2)}`);
        console.log(`建议操作: ${callEV > foldEV ? '跟注' : '弃牌'}`);
        
        return Math.max(callEV, foldEV);
    }
    
    // 组合数计算（带缓存）
    combination(n: number, r: number): number {
        const key = `${n},${r}`;
        if (this.combinationCache.has(key)) {
            return this.combinationCache.get(key)!;
        }
        
        if (r > n || r < 0) return 0;
        if (r === 0 || r === n) return 1;
        
        let result = 1;
        for (let i = 0; i < Math.min(r, n - r); i++) {
            result = result * (n - i) / (i + 1);
        }
        
        this.combinationCache.set(key, result);
        return result;
    }
    
    // 获取最佳5张牌组合
    getBestHand(cards: Card[]): HandStrength {
        if (cards.length < 5) throw new Error('Need at least 5 cards');
        
        const allCombinations = this.generateCombinations(cards, 5);
        let bestHand: HandStrength | null = null;
        
        for (const combination of allCombinations) {
            const handStrength = this.evaluateHand(combination);
            
            if (!bestHand || handStrength.strength > bestHand.strength) {
                bestHand = handStrength;
            }
        }
        
        return bestHand!;
    }
    
    // 生成所有可能的5张牌组合
    generateCombinations(cards: Card[], size: number): Card[][] {
        if (size === 1) return cards.map(card => [card]);
        
        const combinations: Card[][] = [];
        
        for (let i = 0; i <= cards.length - size; i++) {
            const head = cards[i];
            const tailCombinations = this.generateCombinations(cards.slice(i + 1), size - 1);
            
            for (const tail of tailCombinations) {
                combinations.push([head, ...tail]);
            }
        }
        
        return combinations;
    }
    
    private shuffle(array: Card[]): Card[] {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }
}

console.log("扑克计算核心数据结构:");
console.log("🃏 数组: 存储牌组和手牌");
console.log("🗂️ 哈希表: 缓存组合数计算结果");
console.log("🎲 概率计算: 排列组合数学");
console.log("🔄 蒙特卡罗: 大量随机模拟");
```

### 5. 回溯算法（数独/填字游戏）🧩

**使用场景**：
- **数独游戏**：求解和生成
- **填字游戏**：单词放置
- **拼图游戏**：碎片匹配
- **N皇后问题**：棋盘放置

**核心思路**：
```typescript
class SudokuSolver {
    private grid: number[][];                // 9x9数独网格
    private possibleValues: Set<number>[][]; // 每个格子的可能值
    private rowUsed: boolean[][];            // 行使用情况
    private colUsed: boolean[][];            // 列使用情况
    private boxUsed: boolean[][];            // 3x3方格使用情况
    
    constructor(initialGrid: number[][]) {
        this.grid = initialGrid.map(row => [...row]);
        this.initializeConstraints();
    }
    
    // 初始化约束条件
    initializeConstraints(): void {
        this.rowUsed = Array(9).fill(null).map(() => Array(10).fill(false));
        this.colUsed = Array(9).fill(null).map(() => Array(10).fill(false));
        this.boxUsed = Array(9).fill(null).map(() => Array(10).fill(false));
        this.possibleValues = Array(9).fill(null).map(() => 
            Array(9).fill(null).map(() => new Set<number>())
        );
        
        // 标记已填入的数字
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const num = this.grid[row][col];
                if (num !== 0) {
                    this.markUsed(row, col, num);
                } else {
                    // 计算可能的值
                    this.updatePossibleValues(row, col);
                }
            }
        }
    }
    
    // 回溯求解
    solve(): boolean {
        // 找到拥有最少可能值的空格（最约束优先启发）
        const cell = this.findMostConstrainedCell();
        
        if (!cell) {
            return true; // 所有格子都填满了
        }
        
        const { row, col } = cell;
        const possibleNums = Array.from(this.possibleValues[row][col]);
        
        // 尝试每个可能的数字
        for (const num of possibleNums) {
            if (this.isValid(row, col, num)) {
                // 做选择
                this.placeNumber(row, col, num);
                
                // 递归解决
                if (this.solve()) {
                    return true;
                }
                
                // 撤销选择（回溯）
                this.removeNumber(row, col, num);
            }
        }
        
        return false; // 无解
    }
    
    // 找到最受约束的空格（启发式优化）
    findMostConstrainedCell(): {row: number, col: number} | null {
        let minOptions = 10;
        let bestCell: {row: number, col: number} | null = null;
        
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (this.grid[row][col] === 0) {
                    const optionCount = this.possibleValues[row][col].size;
                    
                    if (optionCount < minOptions) {
                        minOptions = optionCount;
                        bestCell = { row, col };
                        
                        // 如果只有一个选择，立即返回
                        if (minOptions === 1) {
                            return bestCell;
                        }
                    }
                }
            }
        }
        
        return bestCell;
    }
    
    // 放置数字
    placeNumber(row: number, col: number, num: number): void {
        this.grid[row][col] = num;
        this.markUsed(row, col, num);
        
        // 更新相关格子的可能值
        this.propagateConstraints(row, col, num, 'remove');
    }
    
    // 移除数字（回溯时）
    removeNumber(row: number, col: number, num: number): void {
        this.grid[row][col] = 0;
        this.markUnused(row, col, num);
        
        // 恢复相关格子的可能值
        this.propagateConstraints(row, col, num, 'add');
    }
    
    // 约束传播：更新相关格子的可能值
    propagateConstraints(row: number, col: number, num: number, operation: 'add' | 'remove'): void {
        // 更新同行的格子
        for (let c = 0; c < 9; c++) {
            if (c !== col && this.grid[row][c] === 0) {
                if (operation === 'remove') {
                    this.possibleValues[row][c].delete(num);
                } else {
                    if (this.isValid(row, c, num)) {
                        this.possibleValues[row][c].add(num);
                    }
                }
            }
        }
        
        // 更新同列的格子
        for (let r = 0; r < 9; r++) {
            if (r !== row && this.grid[r][col] === 0) {
                if (operation === 'remove') {
                    this.possibleValues[r][col].delete(num);
                } else {
                    if (this.isValid(r, col, num)) {
                        this.possibleValues[r][col].add(num);
                    }
                }
            }
        }
        
        // 更新同方格的格子
        const boxRow = Math.floor(row / 3) * 3;
        const boxCol = Math.floor(col / 3) * 3;
        
        for (let r = boxRow; r < boxRow + 3; r++) {
            for (let c = boxCol; c < boxCol + 3; c++) {
                if ((r !== row || c !== col) && this.grid[r][c] === 0) {
                    if (operation === 'remove') {
                        this.possibleValues[r][c].delete(num);
                    } else {
                        if (this.isValid(r, c, num)) {
                            this.possibleValues[r][c].add(num);
                        }
                    }
                }
            }
        }
    }
    
    // 验证数字放置是否有效
    isValid(row: number, col: number, num: number): boolean {
        const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
        
        return !this.rowUsed[row][num] && 
               !this.colUsed[col][num] && 
               !this.boxUsed[boxIndex][num];
    }
    
    // 标记数字为已使用
    markUsed(row: number, col: number, num: number): void {
        const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
        this.rowUsed[row][num] = true;
        this.colUsed[col][num] = true;
        this.boxUsed[boxIndex][num] = true;
    }
    
    // 标记数字为未使用
    markUnused(row: number, col: number, num: number): void {
        const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
        this.rowUsed[row][num] = false;
        this.colUsed[col][num] = false;
        this.boxUsed[boxIndex][num] = false;
    }
    
    // 更新单个格子的可能值
    updatePossibleValues(row: number, col: number): void {
        const possible = new Set<number>();
        
        for (let num = 1; num <= 9; num++) {
            if (this.isValid(row, col, num)) {
                possible.add(num);
            }
        }
        
        this.possibleValues[row][col] = possible;
    }
}

console.log("回溯算法核心数据结构:");
console.log("🧩 二维数组: 游戏状态表示");
console.log("✅ 布尔数组: 约束条件检查");
console.log("🎯 集合(Set): 可能值维护");
console.log("🔄 递归栈: 隐式状态保存");
console.log("⚡ 约束传播: 剪枝优化");
```

### 6. 动态规划（博彩概率计算）📊

**使用场景**：
- **累进式彩票**：中奖概率计算
- **体育博彩**：串关投注优化
- **保险游戏**：风险评估
- **投资组合游戏**：最优分配

**核心思路**：
```typescript
interface BettingOption {
    id: string;
    winProbability: number;
    winPayout: number;      // 获胜时的赔付倍数
    cost: number;           // 投注成本
}

class DynamicBettingOptimizer {
    private memo: Map<string, number>;       // 记忆化缓存
    private options: BettingOption[];        // 投注选项
    
    constructor(options: BettingOption[]) {
        this.options = options;
        this.memo = new Map();
    }
    
    // 在给定预算下最大化期望收益
    maximizeExpectedReturn(budget: number, optionsUsed: boolean[] = []): number {
        const key = `${budget},${optionsUsed.join(',')}`;
        
        if (this.memo.has(key)) {
            return this.memo.get(key)!;
        }
        
        if (budget <= 0) {
            return 0;
        }
        
        let maxReturn = 0;
        
        // 尝试每个可用的投注选项
        for (let i = 0; i < this.options.length; i++) {
            if (optionsUsed[i]) continue; // 已使用过的选项
            
            const option = this.options[i];
            
            if (option.cost <= budget) {
                // 选择这个选项的期望收益
                const expectedReturn = option.winProbability * option.winPayout * option.cost;
                const remainingBudget = budget - option.cost;
                
                // 递归计算剩余预算的最优收益
                const newUsed = [...optionsUsed];
                newUsed[i] = true;
                const futureReturn = this.maximizeExpectedReturn(remainingBudget, newUsed);
                
                const totalReturn = expectedReturn + futureReturn;
                maxReturn = Math.max(maxReturn, totalReturn);
            }
        }
        
        // 也考虑不投注任何选项的情况
        maxReturn = Math.max(maxReturn, 0);
        
        this.memo.set(key, maxReturn);
        return maxReturn;
    }
    
    // 计算最优投注组合
    getOptimalBettingStrategy(budget: number): BettingOption[] {
        const strategy: BettingOption[] = [];
        let remainingBudget = budget;
        const usedOptions = new Array(this.options.length).fill(false);
        
        while (remainingBudget > 0) {
            let bestOption: BettingOption | null = null;
            let bestIndex = -1;
            let bestAdditionalReturn = 0;
            
            // 找到能带来最大额外收益的选项
            for (let i = 0; i < this.options.length; i++) {
                if (usedOptions[i] || this.options[i].cost > remainingBudget) {
                    continue;
                }
                
                const option = this.options[i];
                const currentReturn = this.maximizeExpectedReturn(remainingBudget, usedOptions);
                
                // 临时标记这个选项为已使用
                const tempUsed = [...usedOptions];
                tempUsed[i] = true;
                const newReturn = option.winProbability * option.winPayout * option.cost + 
                                this.maximizeExpectedReturn(remainingBudget - option.cost, tempUsed);
                
                const additionalReturn = newReturn - currentReturn;
                
                if (additionalReturn > bestAdditionalReturn) {
                    bestAdditionalReturn = additionalReturn;
                    bestOption = option;
                    bestIndex = i;
                }
            }
            
            if (bestOption && bestAdditionalReturn > 0) {
                strategy.push(bestOption);
                remainingBudget -= bestOption.cost;
                usedOptions[bestIndex] = true;
            } else {
                break; // 没有更好的选项了
            }
        }
        
        return strategy;
    }
    
    // 计算投注组合的风险指标
    calculateRiskMetrics(strategy: BettingOption[]): RiskMetrics {
        let totalCost = 0;
        let expectedReturn = 0;
        let variance = 0;
        
        // 计算所有可能的结果组合
        const outcomes = this.generateAllOutcomes(strategy);
        
        for (const outcome of outcomes) {
            totalCost += outcome.totalCost;
            expectedReturn += outcome.probability * outcome.return;
            variance += outcome.probability * Math.pow(outcome.return - expectedReturn, 2);
        }
        
        const standardDeviation = Math.sqrt(variance);
        const sharpeRatio = expectedReturn / standardDeviation; // 风险调整收益
        
        return {
            expectedReturn,
            variance,
            standardDeviation,
            sharpeRatio,
            maxLoss: Math.min(...outcomes.map(o => o.return)),
            maxGain: Math.max(...outcomes.map(o => o.return))
        };
    }
    
    // 生成所有可能的结果组合
    generateAllOutcomes(strategy: BettingOption[]): Outcome[] {
        const outcomes: Outcome[] = [];
        const n = strategy.length;
        
        // 遍历所有可能的胜负组合 (2^n种)
        for (let mask = 0; mask < (1 << n); mask++) {
            let probability = 1;
            let totalReturn = 0;
            let totalCost = 0;
            
            for (let i = 0; i < n; i++) {
                const option = strategy[i];
                totalCost += option.cost;
                
                if (mask & (1 << i)) {
                    // 这个选项获胜
                    probability *= option.winProbability;
                    totalReturn += option.winPayout * option.cost;
                } else {
                    // 这个选项失败
                    probability *= (1 - option.winProbability);
                    // 失去投注成本（已在cost中计算）
                }
            }
            
            outcomes.push({
                probability,
                return: totalReturn - totalCost,
                totalCost
            });
        }
        
        return outcomes;
    }
}

interface Outcome {
    probability: number;
    return: number;
    totalCost: number;
}

interface RiskMetrics {
    expectedReturn: number;
    variance: number;
    standardDeviation: number;
    sharpeRatio: number;
    maxLoss: number;
    maxGain: number;
}

console.log("动态规划核心数据结构:");
console.log("🗂️ 哈希表: 记忆化存储子问题解");
console.log("📊 数组: 状态转移表示");
console.log("🎯 位运算: 组合状态枚举");
console.log("📈 概率计算: 期望值和方差");
```

## 📊 算法选择总结表

| 游戏类型 | 核心算法 | 主要数据结构 | 时间复杂度 | 适用场景 |
|----------|----------|--------------|------------|----------|
| **完全信息博弈** | Minimax + Alpha-Beta | 哈希表+递归栈 | O(b^d) → O(b^(d/2)) | 象棋、围棋 |
| **实时对弈** | 迭代加深搜索 | 栈+哈希表+历史表 | O(b^d) 时间可控 | 在线游戏 |
| **概率游戏** | 蒙特卡罗模拟 | 数组+随机数生成器 | O(模拟次数) | 扑克、彩票 |
| **约束求解** | 回溯+约束传播 | 二维数组+集合 | O(k^n) 剪枝优化 | 数独、填字 |
| **优化问题** | 动态规划 | 哈希表+状态表 | O(状态数×选择数) | 投注优化 |
| **状态缓存** | 置换表 | 哈希表+Zobrist | O(1) 查找 | 所有搜索算法 |

**关键原则**：
- 🎯 **完全信息 → 搜索算法**
- 🎯 **不完全信息 → 概率计算**  
- 🎯 **实时要求 → 时间控制**
- 🎯 **重复计算 → 缓存优化**

这些算法都可以在客户端或服务器单独实现，不依赖外部AI服务！💪